<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>浅谈离散傅里叶变换简化算法--Goertzel算法 | Granvallen;Nest</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'bf1ecb4728a04112cb191bc2e62aa815';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浅谈离散傅里叶变换简化算法--Goertzel算法</h1><a id="logo" href="/.">Granvallen;Nest</a><p class="description">人生苦短</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/about/"><i class="fa fa-terminal"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">浅谈离散傅里叶变换简化算法--Goertzel算法</h1><div class="post-meta">Oct 28, 2016<span> | </span><span class="category"><a href="/categories/Lab/">Lab</a><a href="/categories/Lab/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/">信号处理</a><a href="/categories/Lab/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/DSP/">DSP</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2,086</span><span class="post-meta-item-text"> 字</span></span></span><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>契机是之前对Matlab与Mathematica实现FFT算法(Fast Fourier Transformation快速傅里叶变换算法)感到好奇, 加之学习《数字信号处理》这门基础课, 于是就好好研究了下这部分内容. 边看边写, 目测写不到什么高深的内容里去. 说了半天Goertzel算法又是什么东西呢?在讨论FFT之前, 这次先来谈谈这个Goertzel算法. </p>
<span id="more"></span>
<p>在Matlab中实现离散傅里叶变换用fft函数:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a0 = <span class="built_in">fft</span>(f1)/<span class="built_in">length</span>(f1)*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><br>在Mathematica中实现离散傅里叶变换用Fourier函数: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1 = <span class="number">2</span> Fourier[f1, FourierParameters -&gt; &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;];</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2 = <span class="number">2</span> Fourier[f1, FourierParameters -&gt; &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;]/Length[f1];</span><br></pre></td></tr></table></figure><br>Goertzel算法简单说就是计算离散时间信号傅里叶变换的一种方法, 由Gerald Goertzel 在1958年首次提出. Goertzel算法是直接计算离散信号傅里叶变换的简化, 从效率上说, 这种算法所需要的计算实数乘法次数大约是直接计算的一半, 而加法次数稍逊于直接计算. 尽管如此, 这在当时主要靠人工手算的时代, 还是十分欢迎. 当N值很大, 正比于$N^{2}$次的浮点运算量十分庞大, 直到1965年J. W. Cooley和J. W. Tukey合作发表了快速傅里叶变换算法后, 计算量下降了几个数量级, 才开启了数字系统处理信号的时代. </p>
<p>虽然Goertzel算法的地位与FFT算法比起来像是个配角, 但当我们不需要计算所有点的傅里叶变换时, Goertzel算法是可取的, 理解实现起来也相对容易, 因此比较适合小型处理器中实现. </p>
<p>计算离散傅里叶变换还得从源头说起, 也就是直接手算开始, 并以此为参照, 容易体会到计算的简化. </p>
<script type="math/tex; mode=display">X[k]= \sum\limits_{n=0}^{N-1} x[n] W_{N}^{kn}\quad k=0,1,...,N-1</script><p>这是大家熟悉的长度为N有限长序列的离散傅里叶变换计算方法（以下简称DFT）,用这个式子我们可以讨论下直接计算X[k]的计算量. </p>
<p>考虑最大计算量时视x[n]与$W_N^{kn}$皆为复数. </p>
<script type="math/tex; mode=display">x[n]W_{N}^{kn}=(Re\{x[n]\}Re\{W_N^{kn}\}-Im\{x[n]\}Im\{W_N^{kn}\})  \\ \quad \quad \quad \quad +j(Re\{x[n]\}Re\{W_N^{kn}\}+Im\{x[n]\}Im\{W_N^{kn}\})</script><p>可以看到两个复数相乘需要4次实数乘法与2次实数加法. 计算每一个k的X[k]需要$4N$次实数乘法以及$2N+2(N-1)=4N-2$次实数加法, 因此如果计算所有N个k值再分别乘以N就行了, 也就是$N^{2}$级的计算总量. </p>
<p>后面改善DFT计算效率的算法大多利用了$W_N^{kn} (=e^{-j(2 \pi /N)kn})$这个因子的对称性与周期性, 也就是:</p>
<script type="math/tex; mode=display">W_N^{k(N-n)}=W_N^{-kn} \quad</script><script type="math/tex; mode=display">W_N^{kn}=W_N^{k(N+n)}=W_N^{(k+N)n}</script><p>以上两式都容易看出来, 第一个式子说明了这个因子的对称性, 第二个式子说明这个因子对于$k$和$n$有周期性, 周期为$N$. </p>
<hr>
<p>Goertzel算法便是利用了周期性改善计算的栗子. </p>
<p>首先根据周期性: </p>
<script type="math/tex; mode=display">W_N^{-kN}=e^{j(2 \pi /N)Nk}=e^{j2\pi k}=1</script><p>在计算的的目标$X[k]$中插入这个因子</p>
<script type="math/tex; mode=display">X[k]=W_N^{-kN} \sum\limits_{n=0}^{N-1}x[n]W_N^{kn} =\sum\limits_{n=0}^{N-1}x[n]W_N^{-k(N-n)}</script><p>然后我们需要构造这么一个序列, $u[n]$为单位阶跃序列</p>
<script type="math/tex; mode=display">y_k [n]=\sum\limits_{r=-\infty}^{\infty}x[r] W_N^{-k(n-r)} u[n-r]</script><p>发现当$n=N$时</p>
<script type="math/tex; mode=display">y_k [N]=\sum\limits_{r=-\infty}^\infty x[r] W_N^{-k(N-r)} u[N-r]</script><p>由于$x[n]$是有限长序列, 对于上式, r只在[0, N-1]取的值$x[r]$才不为0, 因此, 对比之后发现, $X[k]=y_k [N]$. 这样就把序列$y_k [n]$与$X[k]$联系起来了. </p>
<p>回过头再来看我们构造的离散序列$y_k [n]$, 可以看成有限长序列$x[n]$与$W_N^{-kn} u[n]$序列的离散卷积和是不是. 联想到离散卷积可以求得系统响应, 故$y_k [n]$也可以看作单位脉冲响应为$W_N^{-kn} u[n]$的系统对输入$x[n]$的响应, 这点对于之后的推导有重要意义. </p>
<p>利用上述这一点, 能够表述出系统的差分方程, 这个我们能从系统单位脉冲响应的Z变换中得出. </p>
<script type="math/tex; mode=display">H(z)=Z\{W_N^{-kn} u[n]\}=\frac{1}{ 1-W_N^{-k} z^{-1} }</script><p>我们知道系统函数$H(z)$能够描述离散LTI系统, 并从中得出系统差分方程的系数, 关系是这样的(可以从对系统差分方程两边同时Z变换得到): </p>
<script type="math/tex; mode=display">\sum\limits_{k=0}^{N}a_k y[n-k]=\sum\limits_{k=0}^{M}b_k x[n-k]</script><script type="math/tex; mode=display">H(z)=\frac{Y(z)}{X(z)}=\frac{\sum\limits_{k=0}^M b_k z^{-k} }{\sum\limits_{k=0}^N a_k z^{-k} }</script><p>对比就可得到描述这个LTI系统差分方程的系数, 即</p>
<script type="math/tex; mode=display">H(z)=\frac{1}{ 1-W_N^{-k} z^{-1} }=\frac{b_{0}z^{0}}{a_{0}z^{0}+a_{1}z^{-1}}</script><p>于是, 可写出差分方程: </p>
<script type="math/tex; mode=display">y_k [n]=W_N^{-k} y_k [n-1]+x[n]</script><p>它是一个递推式, 这意味着每一个$y_k [n]$的计算都可由前一个计算值计算. 若画出递推计算的信号流图, 大概是这样的: </p>
<p><img class="" src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/X%5Bk%5D%E4%B8%80%E9%98%B6%E9%80%92%E6%8E%A8%E8%AE%A1%E7%AE%97%E6%B5%81%E5%9B%BE.PNG" width="360" height="180" alt="X[k]一阶递推计算流图" /> </p>
<p>这是Mathematica做的信号流图, 画了一下午看来还是没能画出想要的效果, 我只能说用GraphPlot画比之前用Graph函数画的效果好一点´_&gt;`. </p>
<p>有了简单明了的信号流图, 再来看看求$X[k]$的计算量. 计算每一个新的$y_k [n]$需要4次实数乘法与4次实数加法, 为了递推计算到$y_k [N]$需要计算之前的N-1个值, 也就是大约4N次实数乘法, 4N次实数加法, 而到这只是计算了X[k]的其中一个k的值. 如此看来乘法次数差不多而加法次数比直接计算稍逊一筹. </p>
<p>然而这种递推的计算方法也带来了改善效率的可能, 通过变换离散信号结构使用直接II型来实现系统, 就能得到令人满意的结果. </p>
<p>之前我们得到了$H(z)$(因为是某个k值下的, 其实更应该写做$H_k (z)$), 进行如下变形: </p>
<script type="math/tex; mode=display">H(z)=\frac{1-W_N^{-k} z^{-1}}{(1-W_N^{-k} z^{-1})(1-W_N^k z^{-1})}=\frac{1}{1-2Cos(2\pi k/N) z^{-1}+z^{-2} } (1-W_N^{-k }z^{-1})</script><p>$H(z)$重新看作两个系统级联:</p>
<script type="math/tex; mode=display">H(z)=H_{1}(z)H_{2}(z)</script><p>系统函数分别为: </p>
<script type="math/tex; mode=display">H_1 (z)=\frac{1}{1-2Cos(2\pi k/N) z^{-1}+z^{-2} }</script><script type="math/tex; mode=display">H_2 (z)=1-W_N^{-k} z^{-1}</script><p>用之前的方法可以求得两个系统的差分方程, 引入中间信号$v_k[n]$: </p>
<script type="math/tex; mode=display">H_{1}(z)=\frac{V_{k}(z)}{X(z)}</script><script type="math/tex; mode=display">H_{2}(z)=\frac{Y_{k}(z)}{V_{k}(z)}</script><script type="math/tex; mode=display">v_k [n]=2Cos(2\pi k/N) v_k [n-1]- v_k [n-2]+x[n]</script><script type="math/tex; mode=display">y_k [n]=v_k [n]-W_N^{k} v_k [n-1]</script><p>此时系统的信号流图可表示为: </p>
<p><img class="" src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/X%5Bk%5D%E4%BA%8C%E9%98%B6%E9%80%92%E6%8E%A8%E8%AE%A1%E7%AE%97%E6%B5%81%E5%9B%BE.PNG" width="360" height="266" alt="X[k]二阶递推计算流图" /></p>
<p>图中可以发现为了计算$y_k [N]$不用再计算之前的所有n从0到N-1的值了, 从图上看只需左边回路循环计算N次, 右边回路计算一次就行了. 也就是: </p>
<script type="math/tex; mode=display">y_k [N]=v_k [N]-W_N^{k} v_k [N-1]</script><p>对于计算每一个$v_k [n]$, 由于计算式中的系数都是实数, 需要两次实数乘法与4次实数加法, 迭代N次需要2N次实数乘法与4N次实数加法, 接着计算一次右边回路需要4次实数乘法与4次实数加法. 总结一下, 计算某个k值下$y_k [N]$一共需要大约$2N+4$次实数乘法与$4N+4$次实数加法, 因此如果计算所有k值再乘以N, 大约需要$2N(N+2)$次实数乘法与$4N(N+1)$次实数加法, 说了半天可见实数乘法计算量约是直接计算的一半. </p>
<p>Goertzel算法在N值较小或只是计算部分N值时能体现出这种方法的优势. 另一个不得不提的优势来自于迭代的计算方法, 这使得计算在输入第一个样值点后就可以开始. </p>
<hr>
<p>下面是几个简单实现的例子, 先来最近折腾的Mathematica</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(*Mathematica*)</span></span><br><span class="line"><span class="built_in">Clear</span><span class="punctuation">[</span><span class="variable">Gortzel</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">Gortzel</span><span class="punctuation">[</span><span class="type">signal_List</span><span class="punctuation">]</span><span class="operator">:=</span> </span><br><span class="line">  <span class="built_in">Block</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="built_in">Length</span><span class="punctuation">[</span><span class="variable">signal</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">ini</span> <span class="operator">=</span> <span class="variable">signal</span> <span class="operator">//</span> <span class="built_in">First</span><span class="operator">,</span> <span class="variable">signallist</span> <span class="operator">=</span> <span class="variable">signal</span><span class="operator">~</span><span class="built_in">Append</span><span class="operator">~</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="operator">,</span> </span><br><span class="line">   <span class="built_in">Table</span><span class="punctuation">[</span><span class="type">#2</span> <span class="operator">-</span> <span class="built_in">E</span><span class="operator">^</span><span class="punctuation">(</span><span class="operator">-</span><span class="built_in">I</span> <span class="punctuation">(</span><span class="number">2</span> <span class="built_in">Pi</span><span class="operator">/</span><span class="variable">n</span><span class="punctuation">)</span> <span class="variable">k</span><span class="punctuation">)</span> <span class="type">#1</span><span class="operator">&amp;@@</span> <span class="built_in">Block</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="operator">,</span> </span><br><span class="line"><span class="built_in">Nest</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="type">#</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">,</span> <span class="built_in">N</span><span class="punctuation">[</span><span class="number">2</span> <span class="built_in">Cos</span><span class="punctuation">[</span><span class="punctuation">(</span><span class="number">2</span> <span class="built_in">Pi</span> <span class="variable">k</span><span class="punctuation">)</span><span class="operator">/</span><span class="variable">n</span><span class="punctuation">]</span><span class="type">#</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">-</span> <span class="type">#</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">signallist</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="variable">i</span><span class="operator">++</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span> <span class="operator">&amp;,</span> <span class="punctuation">&#123;</span><span class="number">0</span><span class="operator">,</span> <span class="variable">ini</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">,</span> </span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">k</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br></pre></td></tr></table></figure>
<p>算出结果没问题, 但不够高效, 计算几百个点的序列就得等好一会儿了. </p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%Matlab</span></span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">[xk]</span>=<span class="title">Goertzel</span><span class="params">(xn)</span></span></span><br><span class="line">clear xk;</span><br><span class="line">signallist = [xn, <span class="number">0</span>];</span><br><span class="line">N=<span class="built_in">length</span>(xn);</span><br><span class="line">xk=<span class="built_in">ones</span>(<span class="number">1</span>,N);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">0</span>:N<span class="number">-1</span></span><br><span class="line">    box=[<span class="number">0</span>, signallist(<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">for</span> ii=<span class="number">2</span>:N+<span class="number">1</span></span><br><span class="line">        box=[box(<span class="number">2</span>), <span class="number">2</span>*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*k/N)*box(<span class="number">2</span>)-box(<span class="number">1</span>)+signallist(ii)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xk(k+<span class="number">1</span>)= box(<span class="number">2</span>)-<span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span>*<span class="number">2</span>*<span class="built_in">pi</span>*k/N)*box(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>看了下原来Matlab自带这个算法, 使用goertzel函数, 试了下还挺高效. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mycomplex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="number">2.718281828459</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.1415926535898</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Complex&gt; <span class="title">Goertzel</span><span class="params">(vector&lt;Complex&gt; xn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Complex&gt; xk;</span><br><span class="line">    <span class="type">int</span> n = xn.<span class="built_in">size</span>();</span><br><span class="line">    xn.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex box[<span class="number">2</span>] = &#123; <span class="number">0</span>, xn[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = xn.<span class="built_in">begin</span>() + <span class="number">1</span>; it != xn.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            Complex temp = box[<span class="number">1</span>];</span><br><span class="line">            box[<span class="number">1</span>] = box[<span class="number">1</span>] * <span class="number">2</span> * (<span class="built_in">cos</span>(<span class="number">2</span> * PI*k / n)) - box[<span class="number">0</span>] + *it;</span><br><span class="line">            box[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        xk.<span class="built_in">push_back</span>(box[<span class="number">1</span>] - <span class="built_in">Complex</span>(<span class="built_in">cos</span>(<span class="number">2</span> * PI*k / n), -<span class="built_in">sin</span>(<span class="number">2</span> * PI*k / n)) * box[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考: <a href="https://book.douban.com/subject/26307919/" target="_blank">《离散时间信号处理（第三版）》</a>Alan V. Oppenheim, Ronald W. Schafer 著.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>
</div><div class="tags"><a href="/tags/C-C/"><i class="fa fa-tag"></i>C/C++</a><a href="/tags/DFT/"><i class="fa fa-tag"></i>DFT</a><a href="/tags/Matlab/"><i class="fa fa-tag"></i>Matlab</a><a href="/tags/Mathematica/"><i class="fa fa-tag"></i>Mathematica</a></div><div class="post-nav"><a class="pre" href="/comicrecom1/">个人向漫画推荐 -- 生存</a><a class="next" href="/grammarclub2/">《语法俱乐部》笔记 2.中级篇</a></div><div id="tcomment"></div><script src="https://cdn.staticfile.org/twikoo/1.6.10/twikoo.all.min.js"></script><script>twikoo.init({
  envId: 'https://granvallen.zeabur.app',
  el: '#tcomment',
  region: '',
  path: ''
})</script></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Granvallen.</a> <br /> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a> Theme by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>