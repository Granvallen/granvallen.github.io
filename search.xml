<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈Pixel Art缩放及抗锯齿问题</title>
      <link href="/PixelArtUpscaling/"/>
      <url>/PixelArtUpscaling/</url>
      
        <content type="html"><![CDATA[<p>米娜桑, 我又回来更新了…. 嗯, 年更博主的地位保住了…</p><p>其实我在准备一个更长~篇的更新, 千真万确, 不过目前可公开的情报还不多. 那么在我们仍未知道的更新到来之前, 这次, 难得正经地, 来简单聊聊 Pixel Art 的缩放及抗锯齿问题吧…</p><span id="more"></span><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>さて, 为什么会谈及这个问题? 我在处理像素艺术(Pixel Art)相关渲染的过程中, 遇到了这个问题. 具体可以描述为, 当<strong>像素风格纹理的精灵图(Sprite)在缩放或移动时, 会出现像素抖动与闪烁的现象</strong>, 看上去像是像素的波浪, 非常影响观感. 如图1左上角的例子.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_1.gif" style="zoom:50%;" /></p><p>顺带一提, 精灵图上的角色是GBA游戏<a href="https://zh.wikipedia.org/wiki/%E8%81%96%E5%8A%8D%E5%90%8C%E7%9B%9F">《公主联盟》</a>中的<a href="https://lacrimacastle.net/index.php?game=Yggdra&amp;c=PSP&amp;sec=sprites">大天使マリエッタ</a>.</p><p>这个问题其实非常常见, 稍作检索就能找到原因与解决方法. 一个简单的规则是, <strong>像素图的放大需要是原尺寸的整数倍, 否则会出现畸变(Distorted)</strong>. 这种畸变是规律性的, 在放大或移动过程中就会出现有规律抖动和闪烁. 这里, 通常我们默认像素原图是比较小的, 所以在屏幕显示时主要是进行图像放大操作, 即Upscaling.</p><p>以上, 虽然是简单的理解, 但从某种角度说确实是最优解, 即不做任何的妥协, 让像素艺术分毫不损地显示到屏幕上吧! 在大部分时候, 上述方法并不会增加什么负担, 不过是限制游戏分辨率而已. 也可以参考 unity 官方的 <a href="https://github.com/Unity-Technologies/2d-pixel-perfect">2d-pixel-perfect: Pixel Perfect Camera</a>项目的方案.</p><p>但还是让人不禁想问, 是否有什么办法能让 Pixel Art 突破分辨率的桎梏, 同时不丢失太多表现力呢? 说到这里, 我回忆起之前3DS模拟器上玩到的结合3D场景与像素角色的游戏, 也有类似的观感.</p><p>相比之下, 尝试解决突破这个限制的分享和讨论则不是很多. 不过, 好在以我的检索能力依然能找到一些, 同时看到方法演进的思路. 我觉得更重要的是, 这些分享的内容都丰富且详尽, 是相当好的参考. 只是这样, 我也会认为这些技术值得分享.</p><p>这里自然不必把别人发明的东西再发明一遍, 我会在下面列出这些参考. 如果你也在解决类似问题, 可以参考看看(保佑你不是先看过了下面的内容后才看到这里).</p><ul><li><a href="https://csantosbh.wordpress.com/2014/01/25/manual-texture-filtering-for-pixelated-games-in-webgl/">Manual texture filtering for pixelated games in WebGL – Algorithmic Pensieve</a></li><li><a href="https://csantosbh.wordpress.com/2014/02/05/automatically-detecting-the-texture-filter-threshold-for-pixelated-magnifications/">Superior texture filter for dynamic pixel art upscaling</a></li><li><a href="https://colececil.io/blog/2017/scaling-pixel-art-without-destroying-it/">Scaling Pixel Art Without Destroying It</a></li><li><a href="https://www.youtube.com/watch?v=d6tp43wZqps">Crafting a Better Shader for Pixel Art Upscaling - YouTube</a></li><li><a href="https://www.patreon.com/posts/pixel-art-aa-83276362">Pixel Art AA Video Notes | Patreon</a></li></ul><p>上面的顺序正好是这几个作者相互引用的顺序, 其中第五个参考是 t3ssel8r 对于第四个参考(其所制作视频)的进一步解释. 关于 <a href="https://www.youtube.com/@t3ssel8r">t3ssel8r</a> 大佬还想多说几句, 很早之前看到过 t3ssel8r 关于3D像素艺术渲染的 Demo, 效果非常惊艳, 竟然能把像素画面调教地这么舒服. 至今还能在油管上看到其他人对 t3ssel8r demo 的 recreation. 不仅如此, t3ssel8r 其他游戏开发相关的分享, 质量也是高的可怕. 只是最近一年里频道貌似不怎么活动了, 不知进展是否顺利.</p><p>那么, 这篇文章到这里就结束了… 即使不理解原理, 只拿参考中简短的 shader 代码就能够得到图1下边一行的结果, 肉眼可见, 效果是相当明显的. 对了, 可能唯一容易漏掉的是, 如果使用Unity, <strong>记得把对应纹理的滤波模式(Filter Mode)从最近邻插值(Point)调整为双线性插值(Biliner)</strong>.<br>.<br>.<br>.<br>.<br>.<br>虽然就想这样结束, 但出于笔记的完备, 我依然想稍微深入地谈谈对于这个问题的理解, 这些理解大体也不会超出参考的内容, 只算作是一个注解罢了.</p><h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>让我们试着重新理解为什么像素 Sprite 在放大后(非整数倍放大), 会出现像素畸变.</p><p>要理解这个问题, 需要先理解像素(pixel), 纹素(texel)与纹理采样(Texture Sampling)的概念. 像素通常意义下指的是屏幕显示的最小单元, 我们知道显示器分辨率即是用显示多少像素定义的. 而纹素指的是纹理贴图(Texture)最小色块单元. 在 Pixel Art 的语境下, 纹理贴图也通常带有明显的风格化特点. 纹理采样即是把贴图显示到屏幕上的过程. 某个像素的屏幕坐标$(x, y)$, 通过纹理坐标映射转换到归一化的纹理坐标$(u, v)$, 最终采样到纹理的颜色并显示在像素上.</p><p>如此我们可以知道, 在一定条件下, 像素与纹素是可以相同大小的, 此时像素与纹素将一一对应, 每个像素显示一个纹素的颜色. 在使用 Pixel Art 的纹理贴图时, 大部分情况下, 都需要对贴图进行放大显示, 因为原始像素素材通常是很小的, 而现代显示器的分辨率又辣么大. 一旦进行贴图的放大操作, 可以想见, 此时纹素色块也被扩大了, 会出现多个像素对应同一个纹素的情况.</p><p>事实上在 Unity 中, 当 Sprite 放大时, 会使用设定的 Filter Mode 对纹理进行插值操作. 插值是为了让像素在纹理放大后依然采样到期望的颜色. 就像上面提到的, 即使此时多个像素对应同一个纹素, 在不同应用场景下(比如期望像素颜色平滑过渡), 这些像素也并非就期望取对应纹素的颜色, 而是交由插值方法来最终决定的. 可以说, 不同的插值方法定义了像素纹理采样时参考纹素颜色的方式. </p><p>特别地, 对于像素艺术风格的纹理, 通常 Filter Mode 会选择设置为 Point, 即<a href="https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation">最近邻插值(Nearest Neighbor Interpolation)</a>. 简单说, 就是直接使用距离最近纹素颜色作为采样像素的颜色. 这种插值方式不会造成像素的模糊, 保持了像素色块间颜色的锐利变化, 也即保持了所谓的”像素感”. 可以说是像素艺术纹理理想的插值方法.</p><p>唯一的问题是, 当放大倍数为非整数倍时, 会有部分落在插值参考纹素边缘的采样像素, 这些像素无论最终选择插值为边界哪一边的颜色, 都不可避免地让色块组成的形状产生畸变. 这里引用下 Cole 在 <a href="https://colececil.io/blog/2017/scaling-pixel-art-without-destroying-it/">Scaling Pixel Art Without Destroying It</a> 一文中的图, 非常直观地说明了这一点. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_2.png" style="zoom:50%;" /></p><p>从图2可以看到, 下边的纹理在放大$\frac{7}{3}$倍后, 采样后的像素色块的形状发生了扭曲. 但是又如上边的例子所示, 却可以无损地放大2倍. 观察一下最近邻插值的过程, 纹理放大后, 每个像素的颜色都被定义为距离最近的放大后原纹素的颜色.</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>上述提到的参考, 核心的解决思路其实是相同的. 如果牺牲在所难免, 那就只能尽可能减少牺牲. 事实上, 我们对于最近邻插值在靠近参考的原纹素中心附近的插值结果还是很满意的. 而落在那些参考纹素边缘的, 模棱两可的像素采样点(如图2中被虚线横穿的那些采样点)择需要被进一步调教. 具体来说, 我们希望这些像素的颜色是作为边缘两侧颜色的过渡(平滑). 这样就避免在放大或移动过程中, 因为边界线的移动, 导致这些像素颜色的跳变. 也就是类似图3(依然引自 Cole 文章)中的效果. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_3.png" style="zoom:50%;" /></p><p>毫无疑问, 这会损失一些”像素感”, 但好在这些平滑只发生在边界处, 通常占像素数量的比例很少. 那么接下来的问题就剩两个了, 如何找到这些边界处的采样像素, 以及如何确定这些采样点的颜色. 当然, 一个足够好的解决方法, 最好能同时解决这两个问题. </p><p>在上面两个问题中, 相对容易确定的是后者. 对于采样点颜色的平滑, 依然可以借助插值. 作为应用最广泛的<a href="https://en.wikipedia.org/wiki/Bilinear_interpolation">双线性插值(Bilinear Interpolation)</a>正满足这种需求. 二维平面上, 在给定4个参考点的情况下, 双线性插值对于任意一个参考点范围内的采样点进行两个维度上共三次线性插值. 双线性插值得到的采样是平滑的, 因而非常不适合 Pixel Art 纹理, 而对于绝大部分其他类型的纹理来说, 则是兼具性能与效果的选择. 其也作为基础插值方法, 内置于各大引擎. 因为不算很复杂, 我在附录1中也简单解释了其插值原理及性质, 算是对<a href="https://granvallen.github.io/sift/">SIFT特征提取算法理解与实现</a>中提到的三线性插值做一个补充.</p><p>解决第一个问题的思路最早在<a href="https://csantosbh.wordpress.com/2014/01/25/manual-texture-filtering-for-pixelated-games-in-webgl/">Manual texture filtering for pixelated games in WebGL – Algorithmic Pensieve</a>这篇博客中被分享. 其提出的解决问题的思路可用下图来说明,</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_4.png" style="zoom:50%;" /></p><p>我们首先定义一个 <strong>tpp(texel per pixel)</strong> 值, 这个值描述了像素与纹素的大小比例. 如 tpp = $\frac{1}{2}$, 表示一个纹素有两个像素长或宽. 当纹理放大时, 纹素对于像素就越大, tpp 的值就会相应变小. 接着, 我们可以把纹理上的纹素视作紧密排布的方形色块, 如图4中较大正方形所示. 同时像素也可以视为方形色块. 采样时像素方块映射到纹理坐标下, 如图四中较小正方形所示. 图四中 tpp 为 $\frac{1}{2}$, 此时可见, 像素是纹素方块的$\frac{1}{4}$大小. </p><p>图四上下两图中可以看到, 经过纹理映射的采样像素在水平方向上穿越一个纹素的过程. 当采样像素的区域完全落在同一纹素区域内时(如紫色方块之间的部分), 像素应该采样该纹素的颜色, 即之前认为的像素离这个纹素中心足够近的情况. 而采样区域如果落在多个纹素之间(如绿色方块附近), 此时就需要进行平滑插值计算采样值. 可以想象, 当区域落在4个纹素的交界中心时, 此时插值效果最平滑, 即插值需要平均地参考4个覆盖纹素的颜色.</p><p>如果这个纹理插值方法直接使用双线性插值, 而非最近邻插值, 那么此时在纹素内部采样得到的颜色是已经经过线性插值平滑的(如图四紫色采样区域, 虽然区域完全在单纹素区域内, 但采样结果也是经过附近纹素颜色线性插值过的). 只有当采样区域落在纹素正中心时, 采样值才与纹素颜色完全一致(线性插值完全参考某个参考值的情况).</p><p>这篇<a href="https://csantosbh.wordpress.com/2014/01/25/manual-texture-filtering-for-pixelated-games-in-webgl/">文章</a>中提出, 可以在纹理采样时手动调整纹理坐标$(u,v)$, 调整的结果是使得上图两紫色区域之间位置的纹理坐标的$u$修正为0.5, 即此时采样的是原本纹素颜色. 而其余位置的$u$则不做处理, 直接采样纹理平滑插值后的值. 同时在另一个维度$v$也进行同样的修正操作.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_5.png" style="zoom:50%;" /></p><p>上述的$(u,v)$坐标的修正可以用图5所示的分段函数实现. 注意, 图5中横坐标为$lu$, 含义为采样点(采样区域中心)落在纹素上的局部$u$坐标(如右侧图示). 当$lu=0.5$, $lv=0.5$时, 采样点将位于纹素的中心. 我们可以通过微调$(lu,lv)$间接调整纹理坐标$(u,v)$. 可以发现, 图5中从$lu$调整为$lu’$的映射是一个分段函数, $lv$的映射也是类似.</p><p>关注下这个映射函数的分段点$\alpha$. 这个$\alpha$的位置即图4中上方一图的紫色采样区域, 此时正处于采样平滑插值与采样纹素中心颜色的分界点. 如果我们定义像素采样区域的宽高为$[pw, ph]$, 纹素宽高为$[tw,th]$, 那么有,</p><script type="math/tex; mode=display">tpp = \frac{pw}{tw}</script><script type="math/tex; mode=display">\alpha=\frac{1}{2}\frac{pw}{tw}=\frac{1}{2}tpp</script><p>可见这个$\alpha$与 tpp 的值有关, 也即与纹理放大倍数有关. 以上就是该方法的核心思路, 接下来是针对效果及实现上的优化, 在上述参考中也都有提及.</p><p>首先, 图5的分段映射函数存在两个问题. 其一是分段点的突变. 当采样点在边界采样经过临界点$\alpha$时, 该处的平滑插值与纹素颜色存在一个突变的色差. 为了有一个平滑过渡, 可以调整从0~$\alpha$的采样点分布, 如图6所示,</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_6.png" style="zoom:50%;" /></p><p>调整后的映射使得平滑插值处采样点向远离原点的方向偏移, 从而消除了颜色的突变.</p><p>第二个问题是如何在 shader 中实现这个分段函数, 为避免使用条件逻辑, <a href="https://csantosbh.wordpress.com/2014/01/25/manual-texture-filtering-for-pixelated-games-in-webgl/">文章</a> 中使用两个 clamp 函数组合的形式来实现. 如图7中红色与蓝色两个 clamp 函数所示, 可知两个函数之和即为上述分段函数.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_7.png" style="zoom:50%;" /></p><p>这两个 clamp 和可以表达为,</p><script type="math/tex; mode=display">\begin{aligned}lu'&=clamp(\frac{lu}{2\alpha},\ 0,\ 0.5) + clamp(\frac{lu-1}{2\alpha}+0.5,\ 0,\ 0.5) \\    &=clamp(\frac{lu}{tpp},\ 0,\ 0.5)+clamp(\frac{lu-1}{tpp}+0.5,\ 0,\ 0.5)\end{aligned}</script><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>Cole 在 <a href="https://colececil.io/blog/2017/scaling-pixel-art-without-destroying-it/">Scaling Pixel Art Without Destroying It</a> 中将上述思路在 unity 中进行了实现, 其核心的 shader 代码如下,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> tpp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float2 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 vertex : SV_POSITION;</span><br><span class="line">    float2 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f <span class="title function_">vert</span><span class="params">(a2v input)</span></span><br><span class="line">&#123;</span><br><span class="line">    v2f output;</span><br><span class="line">    output.vertex = UnityObjectToClipPos(input.vertex);</span><br><span class="line">    output.texcoord = input.texcoord * _MainTex_TexelSize.zw; <span class="comment">// 乘以纹理尺寸</span></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f input)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    float2 luv = frac(input.texcoord);</span><br><span class="line">    float2 txOffset = clamp(luv / tpp, <span class="number">0</span>, <span class="number">0.5</span>) + clamp((luv - <span class="number">1</span>) / tpp + <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">    float2 uv = (<span class="built_in">floor</span>(input.texcoord) + txOffset) * _MainTex_TexelSize.xy;</span><br><span class="line">    <span class="keyword">return</span> tex2D(_MainTex, uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简化-clamp-计算"><a href="#简化-clamp-计算" class="headerlink" title="简化 clamp 计算"></a>简化 clamp 计算</h2><p>Cole 在评论中说明了关于 tpp 值的设定问题, 其做法是在相机的脚本中根据相机的 size 进行设置. 后续我们可以看到这个流程可以进一步优化. 不过在此之前, 我们先进一步简化上面的 clamp 计算.</p><p>上述讨论中, 我们默认把$(lu, lv)$设定为采样区域的中心. 为了简化, 我们也可以定义$(lu’’, lv’’)$设定为左上角, 用$lu’’$和$lv’’$来描述偏移. 此时上述分段映射函数可以调整为图8所示,</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_8.png" style="zoom:50%;" /></p><p>其中,</p><script type="math/tex; mode=display">lu''=lu-\alpha</script><p>此时映射函数可以用 saturate 函数来描述,</p><script type="math/tex; mode=display">\begin{aligned}lu'&=saturate(\frac{1}{2\alpha}lu''+1-\frac{1}{2\alpha})+\frac{1}{2} \\&=saturate(\frac{lu''+2\alpha-1}{2\alpha})+\frac{1}{2} \\&=saturate(\frac{lu''+tpp-1}{tpp})+\frac{1}{2}\end{aligned}</script><p>这里稍微再多解释下图8. 同样是为了保证平滑过渡, 当$lu’’$取1时, 需映射为1.5而不是1, 也即此时需采样右侧纹素的中心. 因为, 当采样点在这个临界值继续向右移动时, 将完全地进入右侧纹素.</p><p>由此, 片元着色器的代码可以进一步简化. 这也是 t3ssel8r 在视频 <a href="https://www.youtube.com/watch?v=d6tp43wZqps">Crafting a Better Shader for Pixel Art Upscaling - YouTube</a> 中所进行简化的由来.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f input)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    float2 tx = input.texcoord - <span class="number">0.5</span> * tpp;</span><br><span class="line">    float2 txOffset = saturate((frac(tx) + tpp - <span class="number">1</span>)) / tpp) + <span class="number">0.5</span>; <span class="comment">// luv = frac(tx)</span></span><br><span class="line">    float2 uv = (<span class="built_in">floor</span>(tx) + txOffset) * _MainTex_TexelSize.xy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tex2D(_MainTex, uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化-tpp-变量"><a href="#优化-tpp-变量" class="headerlink" title="优化 tpp 变量"></a>优化 tpp 变量</h2><p>前面提到, tpp(texel per pixel) 变量描述了纹素与像素的大小关系. Cole 曾提到可以通过相机参数计算该值并传入 shader. 我们希望能更合理地设置这个值, 以便在任何缩放尺度下达到最佳的效果. 相关技术最早在 <a href="https://csantosbh.wordpress.com/2014/02/05/automatically-detecting-the-texture-filter-threshold-for-pixelated-magnifications/">Superior texture filter for dynamic pixel art upscaling</a> 中被提及, t3ssel8r 在其视频中做了更深入的阐释.</p><p>在比较少见的 Sprite 三维旋转的情况下, 前述方法会出现新的问题, 如图9所示,</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_9.png" style="zoom:50%;" /></p><p>图9左侧为不做任何处理的效果, 最右侧为使用前述方法和固定 tpp 后的效果, 中间的在右侧基础上使用动态计算的 tpp. 从上图可以看到, 使用固定 tpp 值在旋转角度较大时, 依然会出现像素抖动. </p><p>原因可以理解, 发生旋转后, 纹理上的纹素不再与像素轴对齐, 此时上述讨论方法就会失效. t3ssel8r 在视频中非常直观地展示了这个过程, 并重新对这个问题进行了建模. 其核心思路是<strong>用最小轴对称包围盒</strong>替代像素经过纹理映射后被旋转的采样区域进行采样, 如图12所示. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_10.png" style="zoom:50%;" /></p><p>重新回到纹理映射, 该过程把像素坐标$(x, y)$映射为归一化纹理坐标$(u,v)$, 可以用矩阵乘法进行描述,</p><script type="math/tex; mode=display">\pmatrix{u\\v}=\pmatrix{\frac{\partial u}{\partial x}&\frac{\partial u}{\partial y}\\\frac{\partial v}{\partial x}&\frac{\partial v}{\partial y}}\pmatrix{x\\y}=\pmatrix{\frac{\partial u}{\partial x}x+\frac{\partial u}{\partial y}y\\\frac{\partial v}{\partial x}x+\frac{\partial v}{\partial y}y}</script><p>代入归一化后的像素方格四个顶点坐标$(0,0)$, $(0,1)$, $(1, 0)$和$(1, 1)$, 得到经过对应纹理坐标为$(0, 0)$, $(\frac{\partial u}{\partial y}, \frac{\partial v}{\partial y})$, $(\frac{\partial u}{\partial x}, \frac{\partial v}{\partial x})$和$(\frac{\partial u}{\partial x}+\frac{\partial u}{\partial y}, \frac{\partial v}{\partial x}+\frac{\partial v}{\partial y})$. </p><p>分别取四个坐标$u$, $v$两方向上的最大值与最小值相减, 就得到了包围盒的长与宽.</p><script type="math/tex; mode=display">w = \left| \frac{\partial u}{\partial x} \right|+\left| \frac{\partial u}{\partial y} \right|</script><script type="math/tex; mode=display">h = \left| \frac{\partial v}{\partial x} \right|+\left| \frac{\partial v}{\partial y} \right|</script><script type="math/tex; mode=display">\boldsymbol{tpp}=\pmatrix{\frac{w}{tw}\\\frac{h}{th}}</script><p>上式中的 w 与 h 即前面讨论中使用的 pw 与 ph. 其值可借助 fwidth 函数计算得到. 于是我们可以调整 shader 为,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a2v</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float2 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 vertex : SV_POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f <span class="title function_">vert</span><span class="params">(a2v input)</span></span><br><span class="line">&#123;</span><br><span class="line">    v2f output;</span><br><span class="line">    output.vertex = UnityObjectToClipPos(input.vertex);</span><br><span class="line">    output.uv = input.texcoord;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 <span class="title function_">frag</span><span class="params">(v2f input)</span> : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    float2 tpp = clamp(fwidth(input.uv) * _MainTex_TexelSize.zw, <span class="number">1e-5</span>, <span class="number">1</span>);</span><br><span class="line">    float2 tx = input.uv * _MainTex_TexelSize.zw - <span class="number">0.5</span> * tpp;</span><br><span class="line">    float2 txOffset = saturate((frac(tx) + tpp - <span class="number">1</span>)) / tpp) + <span class="number">0.5</span>;</span><br><span class="line">    float2 uv = (<span class="built_in">floor</span>(tx) + txOffset) * _MainTex_TexelSize.xy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tex2D(_MainTex, uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是关于这个话题我想说明的所有内容. 前文提到的参考中(如 t3ssel8r 的视频)解决了更多关联问题, 这里就不再展开了. 最终的效果即图1左下所示, 而右下为 Cole 的效果, tpp 根据相机参数设置.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="1-关于双线性插值-Bilinear-Interpolation"><a href="#1-关于双线性插值-Bilinear-Interpolation" class="headerlink" title="1 关于双线性插值(Bilinear Interpolation)"></a>1 关于双线性插值(Bilinear Interpolation)</h2><p>让我们先从基础的一维线性插值开始. 线性插值简单来说, 是用直线连接两个参考点, 采样点居于参考点之间, 根据其与两个参考点距离的比例关系作为权重, 对两个参考值线性加权后计算得到采样值. 如下图,</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_f1.png" style="zoom:50%;" /></p><p>其中, $x_0$与$x_1$为两个参考点, $x$为插值采样点, 目的是求得插值$f(x)$. 利用简单的相似三角形即可求得.</p><script type="math/tex; mode=display">\frac{x-x_0}{x_1-x_0} = \frac{f(x)-f(x_0)}{f(x_1)-f(x_0)}</script><script type="math/tex; mode=display">\begin{aligned}f(x)&=\frac{x-x_0}{x_1-x_0}\big[f(x_1) - f(x_0)\big]+f(x_0) \\    &=\frac{x_1-x}{x_1-x_0}f(x_0)+\frac{x-x_0}{x_1-x_0}f(x_1)\end{aligned}</script><p>如果把 $x$ 归一化到 $[0, 1]$, $x’=\frac{x-x_0}{x_1-x_0}$则有,</p><script type="math/tex; mode=display">f(x')=(1-x')f(x_0)+x'f(x_1)</script><p>线性插值中, $f(x_0)$与$f(x_1)$的权值即$x$分别到$x_0$与到$x_1$距离的反比. 也就是距离越远的参考点, 其权重就越小, 非常符合插值的直觉.</p><p>要把线性插值应用到二维平面会稍微麻烦些, 不过这些麻烦只是形式上的. 具体来说, 可以分维度依次进行线性插值, 如下图,</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_f2.png" style="zoom:50%;" /></p><p>A, B, C, D为二维平面四个参考点, 其构成的四边形为轴对齐矩形. 先选择一个方向进行两次线性插值. 这里选择x还是y轴方向不影响最终结果, 如上图为先进行x轴方向插值, 得到$f(x, y_0)$与$f(x,y_1)$. 直接套用线性插值的结果有,</p><script type="math/tex; mode=display">f(x,y_0)=\frac{x_1-x}{x_1-x_0}f(x_0, y_0)+\frac{x-x_0}{x_1-x_0}f(x_1, y_0)</script><script type="math/tex; mode=display">f(x,y_1)=\frac{x_1-x}{x_1-x_0}f(x_0,y_1)+\frac{x-x_0}{x_1-x_0}f(x_1, y_1)</script><p>接着进行y方向线性插值,</p><script type="math/tex; mode=display">f(x, y) = \frac{y_1-y}{y_1-y_0}f(x, y_0)+\frac{y-y_0}{y_1-y_0}f(x,y_1)</script><p>代入前面的插值结果, 化简得,</p><script type="math/tex; mode=display">\begin{aligned}f(x,y)&=\frac{x_1-x}{x_1-x_0}\frac{y_1-y}{y_1-y_0}f(x_0,y_0)+\frac{x_1-x}{x_1-x_0}\frac{y-y_0}{y_1-y_0}f(x_0,y_1) \\&+\frac{x-x_0}{x_1-x_0}\frac{y_1-y}{y_1-y_0}f(x_1,y_0)+\frac{x-x_0}{x_1-x_0}\frac{y-y_0}{y_1-y_0}f(x_1,y_1)\end{aligned}</script><p>若对x, y进行归一化, 令$x’=\frac{x-x_0}{x_1-x_0}$, $y’=\frac{y-y_0}{y_1-y_0}$,</p><script type="math/tex; mode=display">f(x', y') = (1-x')(1-y')f(x_0,y_0)+(1-x')y'f(x_0, y_1)+x'(1-y')f(x_1,y_0)+x'y'f(x_1, y_1)</script><p>与线性插值时相同, 这里各参考值线性加权的权重比例按面积划分. 采样点越靠近参考点, 此时<strong>对角的参考点</strong>与采样点围成的面积越大, 即权重越大. 各面积区域作为权重与对应参考点关系如下图.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pixel_aa_f3.png" style="zoom:50%;" /></p><p>同样原理, 可以类推<a href="https://en.wikipedia.org/wiki/Trilinear_interpolation">三线性插值(Trilinear interpolation)</a>, 其分别在三个维度方向上依次进行线性插值. 并且也具有体积比权重性质.</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> unity </tag>
            
            <tag> PixelArt </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用Python开发Unity</title>
      <link href="/unitypython/"/>
      <url>/unitypython/</url>
      
        <content type="html"><![CDATA[<p>话说, 为什么想不开要用Python开发Unity, 快跑, 全是坑. 也许……你已经在坑里了?</p><p>这篇文章粗浅地介绍用Python开发Unity的一种可行的姿势, 以及可能会踩的一些坑.<br><span id="more"></span></p><p>背景是最近在尝试用Unity开发独立项目, 说实话, 一开始打算使用Python与Unity的组合确实没有料想到会有这么多问题, 毕竟一边是当前最主流的商业游戏引擎, 而另一边则是当前最主流的编程语言, 官方支持暂且不提, 各种应用一定很丰富吧. 但当我开始检索不得不认清事实, 相关资料少得可怜, 这个技术路线更多被应用于科研, 这倒也并非不可理解.</p><p>如前所述, 本文只是粗浅介绍一种用Python开发Unity的姿势, 除自己折腾外实则并不推荐. 显然就商业项目而言, Lua+Unity才是各种成本最小的选择. 简单一提, 因为热更新的需要, 通常把需要频繁更新的逻辑用解释型语言来编码. 除此之外, 在Unity中引入动态语言的好处还有不少, 比如相比原生C#有更高编码效率, 更容易上手, 改写动态语言编码的逻辑也不会触发Unity耗时的重编译. 至于为什么选择用Python更多是个人喜好, Python原生支持面向对象, 基础设施较为完备, 语法优雅, 美中不足是牺牲一些运行效率.</p><p>本文并不会涉及如何构建基于Unity的Python框架, 及优化Unity和Python调用性能等高级话题, 或许等到我有了些许心得的时候再聊.</p><p>当我们决定用Python来开发Unity时, 我们在想什么? 首先, 这从理论上可行性如何? 因为目前主流已有不少使用Lua开发Unity的方案, 所以应该可行, 需要了解下Python相关的支持如何. 也许可以试试Unity官方Python插件?</p><h1 id="Python-Scripting插件"><a href="#Python-Scripting插件" class="headerlink" title="Python Scripting插件"></a>Python Scripting插件</h1><p>没错, 实际上Unity官方确实提供了一个<a href="https://docs.unity3d.com/Packages/com.unity.scripting.python@7.0/manual/index.html">Python插件</a>, 利用该插件可以在Unity编辑器中执行Python脚本, 具体用法可参考官方文档与插件包内的例程. 安装可以参考这个讨论<a href="https://forum.unity.com/threads/python-for-unity-install.1112248/">Python for Unity Install - Unity Forum</a>. 截至目前, 这个插件竟然已迭代到了第七版(然而文档依然很简略), 安装插件会自带一个Python解释器. </p><p>然而经过简短的使用后发现一些问题, 首先这个Python解释器似乎是与Unity编辑器进程绑定的, 每次进入Play模式依然保留有上次运行的状态, 包括导入的module等, 更关键的是在代码中使用了Python插件相关接口Unity会无法build, 也就是无法利用这个插件开发独立的Unity应用. 也许是我看漏了, 我好像没有注意到官方文档有相关的说明, 直到我看到了这个讨论<a href="https://forum.unity.com/threads/python-for-unity-editor-only.914843/">Python for Unity Editor Only - Unity Forum</a>.</p><p>所以, 如果只是拿Unity和Python做个编辑器应用这个插件还是绰绰有余的, 但想更进一步就得自己动手了. 这个讨论也启示了一种使用Python开发Unity独立应用的方法, 最新的回帖坛友分享了他解决方案的一个例子<a href="https://forum.unity.com/threads/python-for-unity.1313007/">Showcase - Python for Unity - Unity Forum</a>.</p><p>启示, Python Scripting插件底层接口是依赖于一个叫<a href="http://pythonnet.github.io/">Python.NET</a>的开源项目, 借助这个开源项目能够实现Python与C#的相互调用, 这正是我们所需要的.</p><h1 id="Python-NET"><a href="#Python-NET" class="headerlink" title="Python.NET"></a>Python.NET</h1><p>因为Unity本身是基于.Net平台的, 可以把思路转换成Python在.Net环境下开发. 检索了一下, 目前比较主流有两种方案. 其一是前面提到的Python.NET, 另一个是同样开源的<a href="https://github.com/IronLanguages/ironpython3">IronPython</a>项目. IronPython是C#的Python实现, 有更好的C#支持, 而Python.Net支持的是CPython实现, Python这边的支持更好, 接口调用方式来看差异倒不是很大, 都值得尝试. 这里选择更新稍勤奋的Python.NET进行测试.</p><p>为了便于测试, 首先创建一个的Unity目录结构, 只列举必要的文件夹.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Assets/</span><br><span class="line">    |- Plugins/               第三方插件dll</span><br><span class="line">    |    |- PythonRuntime/</span><br><span class="line">    |</span><br><span class="line">    |- PythonScripts/         Python代码</span><br><span class="line">    |    |- main.py</span><br><span class="line">    |    </span><br><span class="line">    |- Scripts/               C<span class="comment">#代码</span></span><br><span class="line">    |    |- Manager/</span><br><span class="line">    |    |    |- PythonMgr.cs</span><br><span class="line">    |    |- GameLauncher.cs</span><br><span class="line">    |</span><br><span class="line">    |- SteamingAssets/</span><br><span class="line">    |    |- Python/</span><br><span class="line">    |</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>然后需要下载一个Python实现及Python.NET项目编译输出的dll, 分别放在Python与PythonRuntime文件夹内.</p><p>以Python3.10为例, 从<a href="https://www.python.org/downloads/windows/">Python Releases for Windows | Python.org</a>下载3.10版本的Windows embeddable package压缩包, 解压后放到Python目录即可, 这个package的python貌似是不带pip, 可能需要手动安装.</p><p>至于Python.NET编译的dll需要把项目源码从Github上下载下来, VS打开并编译一下Runtime这个子项目, 拿到Python.Runtime.dll并放入PythonRuntime目录. </p><p>Python.NET源码版本的选择这里有个问题, 即前面提到的, Unity编辑器进入Play模式运行Python脚本后, 再退出Play模式, Python运行时不会关闭, 依然会保留之前运行的状态(重新初始化也不会生效), 这自然对开发过程带来很大的不便. 而且可能因为Python侧引用失效, 存在第二次运行Play模式时崩溃的隐患. Python.NET在早前的一个版本中加入了SoftShutdown模式可用来处理上述情况, 但在最近的几次更新中把上述功能移除了(尽管不会再崩溃). 具体细节可参考以下资料</p><ul><li><a href="https://github.com/pythonnet/pythonnet/issues/957">Python can’t reliably re-initialize; new proposal for Unity’s domain reload · Issue #957 · pythonnet/pythonnet · GitHub</a></li><li><a href="https://github.com/pythonnet/pythonnet/pull/958">Add soft shutdown by amos402</a></li><li><a href="https://docs.google.com/document/d/1a9OLsdKHXJ6MxHjo0WlVRcfjAiaP5hONNKUKKH6Tr-o/edit">Python for NET domain reload</a></li><li><a href="https://github.com/pythonnet/pythonnet/pull/1638">Removed ShutdownMode. Now always behaves like original Reload by lostmsu · Pull Request #1638</a></li></ul><p>如果为了使用soft shutdown带来的便利, 我们可以暂时使用<a href="https://github.com/pythonnet/pythonnet/releases/tag/v3.0.0-a2">pythonnet 3.0.0 alpha-2版本</a>来编译.<br>关于Python.NET开发相关资料可参考:</p><ul><li><a href="http://pythonnet.github.io/">Python.NET</a></li><li><a href="https://github.com/pythonnet/pythonnet/wiki">Home · pythonnet/pythonnet Wiki · GitHub</a></li><li><a href="https://pythonnet.github.io/pythonnet/">Python.NET documentation</a></li></ul><h1 id="Python与C-互相调用"><a href="#Python与C-互相调用" class="headerlink" title="Python与C#互相调用"></a>Python与C#互相调用</h1><p>总算看到点希望了, 简单说下测试环境. Unity空场景中创建一个Game空物体, 给Game挂上一个GameLauncher.cs作为应用的启动脚本.<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GameLauncher.cs</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameLauncher</span> : <span class="title">MonoSingleton</span>&lt;<span class="title">GameLauncher</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PythonMgr.instance.InitEnv();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;[GameLauncher] EinS Start!&quot;</span>);</span><br><span class="line">        PythonMgr.instance.StartGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>PythonMgr类用于管理Python运行时, 内容如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PythonMgr.cs</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Python.Runtime;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PythonMgr</span> : <span class="title">Singleton</span>&lt;<span class="title">PythonMgr</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> python_code_path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitEnv</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Runtime.PythonDLL = Path.Combine(Application.streamingAssetsPath, <span class="string">&quot;Python\\python310.dll&quot;</span>);</span><br><span class="line">        PythonEngine.Initialize(mode: ShutdownMode.Soft);</span><br><span class="line">        Debug.Log(<span class="string">&quot;[PythonMgr] python interpreter version: &quot;</span> + PythonEngine.Version);</span><br><span class="line"></span><br><span class="line">        python_code_path = Path.Combine(Application.dataPath, <span class="string">&quot;PythonScripts/&quot;</span>);</span><br><span class="line">        Debug.Log(<span class="string">&quot;[PythonMgr] python_path: &quot;</span> + python_code_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartGame</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;[PythonMgr] StartGame&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (Py.GIL())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dynamic</span> sys = Py.Import(<span class="string">&quot;sys&quot;</span>);</span><br><span class="line">            sys.path.append(python_code_path);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dynamic</span> main = Py.Import(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">            <span class="built_in">dynamic</span> res = main.StartGame();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PythonEngine.Shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了通过Python.NET调用Python运行时需要用到Python.Runtime命名空间. 根据Python.Net的文档, 初始化PythonEngine前需要设置Runtime.PythonDLL到对应Python版本dll的路径, 或者设置PYTHONNET_PYDLL环境变量. 接着使用ShutdownMode.Soft进行初始化. StartGame中运行Python代码前需使用using(Py.GIL())获取到Python的GIL锁. 然后就可以使用Py.Import导入模块, 并调用模块方法了. 这里我们把PythonScripts路径加入sys.path, 然后加载Python脚本启动模块main, 并调用其StartGame方法.</p><p>注意要让untiy支持dynamic关键字, 需要在Unity project settings/player 中把api compatibility level 调整为 .Net Framework.</p><p>来到Python一侧, main.py内容如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> clr <span class="keyword">import</span> GameLauncher</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UnityEngine <span class="keyword">as</span> ue</span><br><span class="line"><span class="keyword">from</span> System.IO <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">StartGame</span>():</span><br><span class="line">    ue.Debug.Log(Path.Combine(ue.Application.dataPath, <span class="string">&quot;PythonScripts/main.py&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    game = ue.GameObject.Find(<span class="string">&quot;Game&quot;</span>)</span><br><span class="line">    gameluncher = game.GetComponent(GameLauncher)</span><br><span class="line">    ue.Debug.Log(gameluncher.name)</span><br></pre></td></tr></table></figure></p><p>通过clr模块, 我们可以把自定义的类类型导入进来使用, 如果这些自定义类是在命名空间中, 则需要先导入命名空间. </p><p>关于这个话题的一些参考:</p><ul><li><a href="https://forum.unity.com/threads/python-for-unity-doesnt-support-custom-class.969111/">Python for Unity doesn’t support Custom class - Unity Forum</a></li><li><a href="https://github.com/pythonnet/pythonnet/wiki/How-to-call-a-dynamic-library">How to call a dynamic library · pythonnet/pythonnet Wiki · GitHub</a></li></ul><h1 id="开发与调试环境"><a href="#开发与调试环境" class="headerlink" title="开发与调试环境"></a>开发与调试环境</h1><p>最后再简单聊一下另一个比较关键的问题, 开发与调试环境. 本来可以期待着可以All In One, 使用VS code作为开发环境, 但是Unity官方最近放弃了继续支持VS Code的插件, 具体见<a href="https://forum.unity.com/threads/update-on-the-visual-studio-code-package.1302621/">Official - Update on the Visual Studio Code package - Unity Forum</a>. 所以对于C#的调试还是使用Visual Studio吧. 至于Python依然可以使用VS Code + Python插件来调试.</p><p>使用VS调试Unity的C#代码不用说是容易的, 而使用VS Code调试Python可以参考Python.NET的建议, 参考<a href="https://github.com/pythonnet/pythonnet/wiki/Various-debugging-scenarios-of-embedded-CPython">Various debugging scenarios of embedded CPython · pythonnet/pythonnet Wiki · GitHub</a>, 我们可以使用最简单的第三种远程调试方式, 其中<a href="https://github.com/microsoft/ptvsd">ptvsd</a>已被微软所废弃, 作为替代可以使用<a href="https://github.com/microsoft/debugpy/">debugpy</a>库. 原理就是VS Code开启一个调试服务, 执行的Python脚本使用debugpy.connect进行连接调试.</p><p>VS Code新建一个Python调试配置, 内容如下<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// launch.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Python debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;python&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;attach&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;justMyCode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;listen&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">5678</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;pathMappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;localRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;remoteRoot&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><p>然后在main.py中增加<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> debugpy</span><br><span class="line">debugpy.connect((<span class="string">&quot;localhost&quot;</span>, <span class="number">5678</span>))</span><br></pre></td></tr></table></figure></p><p>完成后VS Code先开启调试, Unity进入Play模式运行python脚本即可, 与调试普通Python脚本相同.</p><p>Enjoy.<br>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Unity </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Python </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊我对P5R的感受与观察</title>
      <link href="/persona5/"/>
      <url>/persona5/</url>
      
        <content type="html"><![CDATA[<p>我又回来水文章了…过去的一年于我而言也经历了很多事, 疫情之外, 其中像是虾米关闭一事对我影响还挺大, 毕竟是用了8年的老app了. 在我这称得上情怀的应用不多, 但虾米确实能算上一个, 关于这个话题也有一些我自己的观察, 这里就先按下不表. 说回正题, 就3天前Clear了女神异闻录5皇家版(P5R), 个人非常喜欢, 所以<del>怀着激动的心情来吹一吹</del>想分享一下我喜欢P5的一些地方(我看网上的舆论相较P5, 对于P5R可能争议会比较大, 这里并不会严格地去区分两者, 或者说都指的是P5R)以及我游玩过程中的一些思考(毕竟干聊P5也没什么意思). 由于我确实各方面经验有限(比如P系列除此之外只几年前玩过P4G还没通, 正传真女神转生系列更是没碰过), 有些内容大概会聊得比较浅, 只是点到为止, 如果之后有更深的体会再做补充. 总之, 本文还是会有比较强烈的个人喜好, 大部分属于想到什么写什么, 当然我其实也不满足于此, 会尽可能尝试从鉴赏的角度去看P5. 动手之前根本想象不到本文会写成什么样, 只能先把千头万绪一条条理出来, 无论如何, 我想这样也算表达对P5喜欢的方式之一吧.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/p5_2.jpg" style="zoom:50%" alt="" /></p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=454224842&auto=0&height=66"></iframe><h1 id="P5华丽不失精致的外壳"><a href="#P5华丽不失精致的外壳" class="headerlink" title="P5华丽不失精致的外壳"></a>P5华丽不失精致的外壳</h1><p>当代电子游戏作为一种高度工业化的商品, 可以从很多视角去说, 像是美术, 配乐, 故事设定等. 初见P5, 上述三个方面是最直接能感受到制作组用心的地方, P5的这个组合更是有意思, 至少已经勾起了我浓厚的兴趣继续玩下去.</p><h2 id="美术"><a href="#美术" class="headerlink" title="美术"></a>美术</h2><p>P5的美术绝对值得单独拿出来提的. P5在色彩上为了和怪盗的设定契合大量使用了红黑的配色, 不得不说非常符合怪盗即优雅又神秘的气质. 在菜单画面的设计上也用了非常多的大色块, 使得很多画面非常鲜艳. 此外, 也许是为了让玩家能在眩目的菜单中抓到重点, 也用了很多动态的元素, 比如背景是大色块的缓慢变化, 而所选的选项则用不规则抖动的色块所包裹, 这也是我经验中很少看到的. 我在游戏里第一次看到约瑟交换花朵的菜单时被彻底惊艳到了.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/p5_1.jpg" style="zoom:50%" alt="" /></p><p>P5除了在菜单画面中用了非常多的动态元素, 另一个特别细节的设计是界面间的切换使用了大量转场动画(切换动画). 如三角键进入的菜单切换是joker各种连续改变姿势的动画(LoadData菜单还有几率刷出joker出糗的动画, 太细节了). 在游戏的战斗界面中这种转场更是无处不在, 选择一种操作就进行一次镜头切换, 人物的姿态也对应发生变化. 再比如制作潜入道具时把菜单像纸一样揉成团和展开的动画. 这些转场让菜单的操作也变得如此炫酷, 同时提升了流畅度. 看到网上调侃, P5是第一个用转场动画强行延长游戏时间的游戏, 当然, 我不清楚做这些动画是否会带来过高的成本. 上述提到的这些设计在P4中是几乎没有的.</p><p>聊到P5的人设反而没什么可聊的, P4P5都是中规中矩的日系人设. 反而人格面具的形象设计可能是P系列风格化的另外一点, 因为出乎意料地非常不符合日式审美. 精神象征人格面具这东西在P系列中也是玩法的核心之一(没错, 就是jojo的替身), 每个人格面具设计的出发点是世界各国文化与传说中的一些人神魔兽等, 还是相当考究的, 只是有些我觉得设计得非常放飞自我, 一些魔物的设计真是有点让我联想到剑风蚀之刻里的怪物(当然也没那么夸张, 剑风里的怪物设计真是狂掉san值).</p><p>游戏的剧情对话界面则和大部分日式游戏没有太大区别, 对话框用的抖动气泡, 比较特别的是为了增强表现力常常在对话中插入人物面部特写, 我个人是很喜欢这些漫画式的表现方式.</p><h2 id="配乐"><a href="#配乐" class="headerlink" title="配乐"></a>配乐</h2><p>除了画面之外, 另一个能直接让人喜欢上的就是P系列祖传的目黑的配乐了. 最开始吸引我接触女神异闻录系列就是P4G的配乐, 那时候就觉得P4G的配乐真是时髦度爆表, P4G的背景明明是乡下, 听着逛街曲《Heartbeat,Heartbreak》楞是感觉来到了灯红酒绿的大都会. 由于配乐而入了某个坑在我这也挺常见的, 奥日与大逆转也差不多是这种情况, 未来大概也会去试试尼尔吧.</p><p>单从风格上说, 目黑将司拿手的我大概知道是爵士和蓝调, 虽然在P4中略显不搭, 只能说配乐风格太强烈, 但到了P5里, 却和怪盗的主题意外地很相称. 说来也非常有意思, 爵士配黑帮怪盗其实很早就有这种印象, 但一直不知道缘由. 看网上有介绍说在jazz最为盛行的20世纪20年代, 当时出了几部比较有影响力的黑帮电影, 像是美国往事, 都大量采用了爵士配乐, 所以这种印象被保留下来, 并且被后世的作品不断强化. 就我自己接触到的像黑帮动画《永生之酒》与怪盗《鲁邦三世》也都大量采用了爵士配乐, 前者的《GUN’S &amp; ROSES》和后者大野雄二的《Theme From Lupin 3》可说是经典中的经典了. 但是也能明显感觉到, 虽说都是爵士, 目黑的爵士与前面提到的还是不太一样, 看网上评论说应该更接近酸爵士(Acid Jazz), 或称迷幻爵士, 属于爵士和Hip-hop的融合, 其实就不太有爵士味了, P5的曲子中有一首《Life Goes On》我觉得应该是非常标准的酸爵士. 顺着这条线, 我也非常幸运地找到了这一风格喜欢的音乐人, 比如加拿大的Four80East组合, 比较有代表性的作品是《Noodle Soup》和《Drive Time》.</p><p>说回P5, 当然目黑除了一些风格强烈的配乐外, 更多是比较常见的偏”洗脑”(重复旋律)的RPG配乐, 比如几个固定场景, 战斗和迷宫探索的配乐. 日式RPG游戏时长一般都比较长, 在跑图, 探索以及一些需要刷刷刷的部分会花很多时间, 自然需要一些可长时间循环且不会让玩家烦躁的配乐, 这部分我觉得P5做得也还不错. 就我自己来说, 这部分的配乐我会更关注也更喜欢, 因为每当听到这些配乐, 在游玩过程中经历的种种场景仿佛又重现于脑海. 如网上在这些曲子下的评论都是玩家的各种回忆, 如果是一些较难关卡的配乐, 甚至听到时会产生PTSD. P5的几个迷宫曲子都还挺”洗脑”的, 双叶殿堂的《母のいた日々》, 生存游戏商店的《Layer Cake》, 新岛殿堂的《The Whims of Fate》以及丸喜殿堂的《Gentle Madman》印象都挺深. 这些曲子如果单拿出来听感觉一般, 但是在重复了几十个小时后已经牢牢地和游戏体验绑定在一起, 或许这也是配乐或者说原声音乐(OST)的魅力所在吧.</p><p>P5配乐的另一个有意思的地方在于有相当一部分配乐是有英语人声的, 事实上整个P系列都一直如此, 现在这一类反传统的配乐也是出现得越来越多了. P5的几个主要战斗曲都有人声的版本, 只在战斗的最高潮时切入, 像是《Last Surprise》和《Rivers In the Desert》. 至于为什么用英语人声, 貌似并没有什么特别的理由, 我记得在一个什么目黑的访谈中提到只是因为日本人对于英文发音有种”虽然听不懂但是很厉害的样子”这种印象?</p><p>要从乐理层面聊配乐我是完全不够格的, 好在网上也能找到一些比较专业的评价, 如音乐人Alex做过的一个系列<a href="https://www.bilibili.com/video/BV1bp4y117nC">音乐制作人谈P5名曲《Last Surprise》好在哪？</a>, <a href="https://www.youtube.com/watch?v=Z5td7jZgaYs&amp;ab_channel=AlexMoukalaMusic">Ranking Persona 5’s Palace Themes (as a Music Producer)</a>.</p><h2 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h2><p>抛开没接触过的P3等前几作不谈, P系列的主要设定都是与人精神世界的冒险相关, 现实中人的认知与具现化精神世界(即殿堂)中的人(或者称为阴影)相联系, 而主角们正是进入精神世界展开各种行动, 最终达到改变现实中人认知的目的. 在殿堂中, 主角们自然也是使用精神世界的代表来进行战斗, 这就是人格面具(Persona). 这一设定在每作之间大体相同, 只是在细节上略有差异. 另一个则是每作与之联系的主题设定, 在P4中主角们是以事件调查团的身份行动, 目的是让现实中的人接受真实的自己, 而在P5中主角们化身怪盗团, 通过借由偷走殿堂中的秘宝来改变现实中人的认知并使其悔改. 我确实也更喜欢P5的设定, 一是感觉靠最后一通让人幡然悔悟的嘴炮, 不如像偷秘宝这样来得简单直接(不过设定的解释会是一个瑕疵), 整个行动过程也非常帅气优雅. 二是还有什么比作品里那些满是丑恶嘴脸的大人亲口忏悔自己的罪过来得更爽快的呢.</p><h1 id="简单聊聊P5的玩法"><a href="#简单聊聊P5的玩法" class="headerlink" title="简单聊聊P5的玩法"></a>简单聊聊P5的玩法</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=454231893&auto=0&height=66"></iframe><p>如前所述, P5的主要玩法可分为现实世界与精神世界的体验两部分, 在现实世界的部分主要是日常生活的体验, 像是上学, 打工, 与某个社群(coop)的伙伴加深羁绊等, 这些活动的目地除了推进剧情, 更是为了解锁在探索精神世界时非常有用的技能(主要是通过提升coop等级解锁). 所谓精神世界的探索即是探索悔改目标的殿堂(设定上欲望扭曲者会拥有殿堂), 殿堂是一个有着特定主题, 并集战斗, 探索, 解谜一体的大型迷宫, 直至最后找到殿堂的秘宝, 战胜殿堂主盗走秘宝, 推动剧情进入下一章.</p><p>简单说一说其中我关注的一些设计. 我觉得P系列和其他jrpg很不一样的一个地方是用了替身战士即人格面具的设计, 也就是P系列的战斗不仅要关注角色的成长, 更要关注人格面具的培养, 这是两套相互联系却又很不同的系统. 在使用人格面具的战斗中, 敌人攻击的是玩家而不是人格面具, 因此在日常生活中的锻炼提升的是角色的5维属性, 但玩家又能获得所装备人格面具的抗性与弱点, 也可以使用人格面具进行魔法物理攻击, 反而角色则很少进行攻击行动(平A). 那么如何培养强大的人格面具呢? 只是通过传统的战斗是不行的, 虽然我不知道战斗的经验值是如何分配的, 就我自己的体验来看, 战斗也主要是提升角色等级, 而让人格面具升级提升5维属性是比较困难的, 一般需要在装备同一个人格面具的情况下进行大量战斗, 这是不现实的, 因为战斗中需要利用不同人格面具的抗性与技能, 总体玩下来在战斗中让主角人格面具升级的次数屈指可数. 当然这种设计也是有意为之的, 不然这么大本人格面具图鉴就白设计了. 游戏机制给出的引导是提升现实生活中coop的等级, 这样可以合成出5维属性更高, 抗性也更好的面具, 属性通常都会大大高于已经拥有的人格面具. 这种设计在我初次接触P系列还蛮不适应的, 因为我此前在玩其他的时候总想着主角可以不断地成长, 一些技能的搭配越来越完善, 逐渐形成一种套路化的战斗流程, 到了P系列这, 每次为了提升自己的实力, 都需要对已有的人格面具重新洗牌, 重新搭配技能, 才能确保自己有全属性的打击面. 所以到中期的时候我基本就放弃这种想法了, 只盯几个特殊的打击面, 其他有什么用什么. 不过到了后期…嗯…后期的人格面具培养是另外一种玩法了.</p><p>P系列另一个有特点的系统就是coop社群系统, 虽然P4也有, 但P5中才把这个系统做得更具价值. 要说明这点还是要先回过头去说P5的殿堂, 我觉得P5的殿堂体验真是太棒了.</p><p>P5中的殿堂迷宫总算是有迷宫的样子了, 除了一些常规的迷宫收集要素, 密道, 近道等设计, 每个迷宫都有别出心裁的主题, 并且围绕这个主题设计了一些剧情和谜题. 不过就解谜来说P5的设计还是相当简单, 都是一些非常经典谜题, 但聊胜于无. 而反面教材我觉得就可以拿P4举例, 体验基本上就是P5中印象空间的简化版. P5的迷宫相比P4有另外两个我觉得非常人性化的改进, 可能是P4的失望在先, 当我看到有安全小屋和加入隐匿移动时不由拍手叫好. 安全小屋让探索迷宫时去某个地方可以更方便地快速移动, 利用后者在迷宫拐角也不用一直先盯着小地图红点, 等着阴影转身时慌张地冲过去, 开房间门时也不用因为突然出现阴影而吓个半死. P5的迷宫还有一点也非常有意思, 隐藏, 跳跃, 使用钩爪都使用的是提示加弹出操作按钮的设计, 而非可自由地做这些动作(固定场景才可执行这些操作), 这不知道是成本上的限制, 还是觉得迷宫复杂容易让玩家摸不着头脑, 总之体验还算流畅, 游戏中的机制第三只眼可高亮这些场景. P5迷宫中的大头除了探索自然就是战斗, P系列的战斗由于人格面具加入还蛮有意思的, P5又通过增加属性和新的战斗要素(如枪械), 使回合制的战斗过程也充满了乐趣. 我个人最喜欢换手这个设计, 当打击弱点致使敌人倒地时会触发One more, 即可再行动一次, 此时可执行换手即把行动权让给队友, 换手后队友获得回血回蓝攻击力buff, 通常队友会再次击中敌人弱点(已倒地敌人不行), 从而换手的过程得到连锁, 我感觉这种不断换手打出高伤害的设计真是燃爆了, 当然特效也非常燃, 另外被换手的队员并不消耗他自己本回合的行动权. P5双人合体技Show time也依旧保持了无厘头搞笑的风格.</p><p>说回coop系统, 在P5中把战斗和探索殿堂各种方便的技能作为coop升级的奖励, 因此随着游戏的进行, 战斗与迷宫探索的丰富和便利程度也在上升, 如龙司coop后期可获得的对于等级低很多的阴影冲刺可瞬杀, 再比如东乡coop最后解锁的东乡系统, 可让伙伴自行交换上场也非常实用. P5战斗时通常是固定的4人上场, 前期只有joker行动时可以更换伙伴上场, 像这种后期体验的改善还有不少. P5游玩体验做到了即使到了中期依然不断地有新的战斗和探索的要素解锁, 从而能一直保持新鲜感. 然而这个设计有一个微妙的地方. 在P5中coop的提升意味着和特定伙伴羁绊的加深, 达到一定程度可发展为特殊关系, 没错, P5是有简单的恋人系统的(要不怎么说不少人就是拿P5当Galgame玩的). 但是即使和某人成为恋人关系后, 由于游戏机制, 为了提升coop解锁技能, 玩家依然需要和其他角色单独约会, 参与游戏设计好的逛街看电影等等. 当然, 在游戏中(或者任何其他文艺作品中)带入现实考量是否有必要这一话题也一直是存在争议的, 这一话题之后聊到jrpg时可能仍然会提起. 至于P5在这点上倒也没有做得特别过分就是了.</p><p>关于P5的战斗最后再提一点, 就像攻壳的聂俊(说好的P5鉴赏视频呢?)在<a href="https://www.bilibili.com/video/BV1yE411376q">P5S鉴赏</a>中提到的, 击中弱点(Weak)倒地触发One more的设计实际上降低了战斗的容错率, 使得战斗更加惊险刺激. 利用得当, 玩家可无伤解决战斗, 而一旦被敌人击中弱点也会被连续打击致使我方损失惨重. 不过由于这个机制过于强大, Boss战的设计就需要一些特别考虑. 我记得之前的感受就是打打小怪的时候各种利用弱点, 而到了Boss就特没劲, 为了突出难度通常就是全属性抗性, 只能硬着头皮打. 因此可以看到P5中的有些Boss有多个部分的设计, 各个部分抗性与弱点各不相同, 像是斑目Boss的设计. 另外一些Boss的设计就不是战斗这么简单了, 比如新岛Boss和双叶殿堂的Boss, 加入了新的互动要素和机制, 比如能够改变自身的抗性等.</p><p>顺便一说, P系列魔法的名字一直念起来很怪, 什么玛哈, 米吉多, 其实是有所考究的, 可参考这篇文章: <a href="https://www.gcores.com/articles/19888">闲聊女神转生及Persona系列技能命名方式</a></p><p>人格面具的合成是我到后期才发掘的乐趣, 本身还是达成某一种套路的成就感, 这种感觉类似于培养一支宝可梦对战的队伍. 人格面具也有特性与技能的搭配, 特性只能通过合成遗传, 技能可以通过遗传, 技能卡或者人格面具绞刑进行组合搭配, 5维可以通过人格面具的升级或监禁焚香培养. 各个人格面具的合成本身遵循特定的规律, 因此最后要合成并培养一个人格面具, 需要对整个流程进行计算和设计, 细节就不多说了, 我甚至在网上看到有用Dijkstra算法优化合成路径的<a href="https://www.bilibili.com/read/cv6565204/?from=readlist">文章</a>. 我自己也花了点时间合成了几个比较知名的p(网上一般把人格面具简称为p, xxp即是某些做好技能抗性搭配, 专门用于某种用途的面具), 比如物攻p易经, 即死p爱丽丝, 开场p湿婆, 魔法p兰达等. 不得不说P5R中的公开处刑机制(联机使用网络上的人格面具进行合成)大大降低了玩家自己合成一个理想面具的难度, 主要是很多吸收的抗性都可以很方便地获得. 一旦合成了这些最终人格面具, 战斗就变成了另一个画风, 不再需要小心翼翼地试探敌人弱点, 因为大多数时候都是一回合结束战斗, 不过用自己辛苦合成出来的面具战斗本身就是非常愉悦的.</p><p>最后再说说对P系列对日常生活模拟的观察(不一定是这么回事), 看似琐碎枯燥的日常生活也是P系列最具特色的玩法之一. 现代很多游戏的简化设计利用了玩家的生活经验和想象力, 这在P系列中也已经随处可见. 比较明显的几个例子, 比如P5中对看DVD与玩游戏的模拟, 镜头是对着joker看不到电视画面的, 只能听到散乱的剧情对话配音或者8bit游戏音乐. 再比游戏中角色说话不是全语音的, 而是只在适当的时间点, 比如表达惊讶, 说话转折时才有几个语气和单词的配音, 我记得早时候如果游戏不用配音还想说话有声音就一般用机械音代替, 像是逆转裁判这一类. 其他游戏如塞尔达旷野之息也是同样处理, 只有音调的配音. 另外比如动森里很多生活中有的道具都可简单的交互, 雷电做客天地无用播客聊动森时提到了他最爱的咖啡机, 互动就只有咕咚一下, 但就是能让人想象出使用咖啡机的场景. 我个人是能接受也挺喜欢这种简化的表现的, 制作也确实省下了成本.</p><p>关于玩家看不到的场景设计细节, 看到一个好玩的视频: <a href="https://www.bilibili.com/video/BV1ub41177nj">P5视角外的世界</a></p><h1 id="是时候聊聊P5的故事和表达了"><a href="#是时候聊聊P5的故事和表达了" class="headerlink" title="是时候聊聊P5的故事和表达了"></a>是时候聊聊P5的故事和表达了</h1><p>依然是剧透预警, 但这里不会聊太细节的剧情.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.<br>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=454231902&auto=0&height=66"></iframe><p>P5充满欢乐的日常故事和P4一样, 已经处理得足够好不必多谈, 只简单说说P5R主线故事的表达(P5R与P5剧情上存在差异, 这也是争议点之一). P5R的故事作为一个重故事的jrpg来讲已经很不错了, 相信是不会让大部分jrpg玩家失望的. 设定上虽然有不严谨的地方但总体上能自圆其说(或者说那些细节对于表达无伤大雅), 故事也是有曲折有高潮以及多次的反转, 也不像某作留下了一堆坑没填就匆匆结束. 当然我觉得最重要的还是把故事想要表达的东西清楚表达出来了, 并且这个东西能得到大家的认可.</p><p>P5R的故事感受下来, 算上皇家版追加的第三学期, 我觉得是要表达或者说探讨三个问题. 击败狮童与第三学期开始可以看作两个分界点. </p><p>第一段的故事主要就是心之怪盗团的成长, 不停地寻找悔改目标(其实都是目标自己撞上来的), 结识新伙伴, 提升怪盗团的社会影响力. 在怪盗团的努力下, 社会中的恶人一次次悔改并当众忏悔自己的罪行. 然而就在这个当下, 怪盗频道上抛出了一个问题: 你认为怪盗团是正义的吗? 嗯, 这恐怕不是一个可以简单回答的问题, 可以从很多的角度看这个问题, 比如是不是应该把强制执行的悔改看作一种手段不明的私刑. 或者从上帝视角, 那些恶人也是因为威胁到了怪盗团, 怪盗团才不得不对他们进行悔改. 又或者可以不用想那么多, 这些恶人的悔改自然促进了社会的正义, 而不用在乎使用的是什么手段, 有没有得到社会大众的认可.  这些角度的讨论在故事进行中是相互角逐的, 也体现在怪频上怪盗团的支持率来回摆动. 不由得想起死亡笔记中夜神月的理想与其所作所为, 不过在那个作品里, 月的正义和对其的探讨其实已经无关紧要, 月和L的斗智才更被人们所关心. 回到P5R, 击败了最后一个恶人狮童, 故事突然画风一转, 伪神圣杯出现, 怪盗团的任务突然变成了拯救世界拯救人类. 后半段故事的转向用到了前半段的几条暗线, 回过来看, 也不能说处理得太突兀, 只是前面提到的第一个问题因为这样的转向而忽略了. 这里当然不能说因为最后怪盗团拯救了人类所以取得了正义性, 这和前面的故事是两码事不是吗. 对于第一个问题, 虽然P5R没有给出正面的回答, 但我隐约觉得是想表达对于怪盗团来说, 被认为正义不正义不重要, 怪盗团自己行动的初心才更重要.</p><p>第二段与第三段的表达比较直白. 比如第二段我觉得表达的就是经常被提起的相信人类的可能性这一点, 这就非常适合用一个人类危机的环境来表达. 虽然略显中二, 但还是很感动, 现在脑海里还能回忆起打败伪神后的播片, Mona发着光离开时感慨: 世上并不存在”真实的世界”, 世界是由每个人的感受所形成的, 这便是世界的真相, 所以世界是无限的, 就算眼前一片漆黑, 只要握着别人的手, 用羁绊连结在一起的话, 世界就不会终结, 世界就在你们的心里. 回到家后, Mona? 你怎么诈尸了, 把我感动的眼泪还给我!</p><p>第三段我也挺喜欢, 是P5R中新加的故事. 丸喜可以说是P5R里非常不同的Boss了, 他继承了之前被怪盗团打败的伪神的力量(窃取了革命的果实), 获得了能够改写现实的能力. 虽然这个能力很强大, 但经历了失去至爱之痛的丸喜决心用这个能力让人类远离痛苦. 嗯, 确实到这里有不少设定上的瑕疵, 也把人类的痛苦说得过于轻巧了, 但要抛给玩家的问题我想已经表达出来了: 我们是否应该或者说有资格剥夺他人的痛苦. 这个问题有意思的地方在于不是剥夺快乐和美好, 而是负面情绪和苦痛. 丸喜给出的选择就是作为神一样的存在, 为自己看到的每一个人改写原本现实的不幸之处, 为此丸喜也甘愿承受无法被人理解的孤独. 丸喜无疑和本作中其他Boss一样有自己的欲望, 但是其欲望本身的内容却是剥夺他人痛苦. 在游戏中丸喜不断给joker时间, 让他好好感受身边伙伴是否因为新创造的现实而过得更快乐. joker可以选择在期限之日与丸喜战斗, 否定他的所作所为, 或者也可以选择接受. 这里选择抗争也是有理由的, 我觉得关键倒不是说丸喜创造的现实就是虚伪的, 而是人类的苦痛同样可以提取出人类完善自己的碎片, 放弃即意味着设限. 约定之日, 丸喜带着忧伤且失落的神情说道: 还以为是你的话能够理解我的理想…作为一款游戏遗憾之处也在于最终只能用战斗的方式来击碎丸喜傲慢的理想. 最后的最后, 在高楼上, 失去人格面具的两人因信念的不同肉身扭打在一起…</p><p>P5R中明智这个角色的塑造一直很有争议. 我觉得是前半段塑造得太好了, 确实有名侦探的样子, 与joker也建立了很深的羁绊(相爱相杀), 不是说不能接受后面明智因为立场出卖怪盗团或者有自己的野心, 而是在表现上把他往变态愉快犯的方向塑造(这类日系人设最近还挺流行的).</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>P系列是一个以现代生活为背景的jrpg, 以我有限的jrpg经验来说感受是非常特别的. P4G是现代的乡下生活, P5R则是现代的都市生活. 并且P系列尝试去关注和描绘现代生活中人们的精神状态, 我觉得挺好的. </p><p>本来只是想把玩P5R时所有想法和感想都写下来, 没想到篇幅已经这么长了, 还是有一些没有记下来, 比如关于丸喜我不知道怎么想到了漫画犬屋敷(鬼知道当时我是怎么联想的), 总之先到这里结束吧(摊手)…</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=454231899&auto=0&height=66"></iframe><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>終わり</p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> P5R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点灯游戏与数学之美</title>
      <link href="/lightoutgame/"/>
      <url>/lightoutgame/</url>
      
        <content type="html"><![CDATA[<p>最近由于疫情隔离在家, 所以正好抽空刷一刷leetcode, 于是刷到了<a href="https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/">Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</a>这题, 题中讲的是一个将二元数组中的1根据特殊规则全消减成0的游戏. 看到规则, 虽然我记不得这游戏是叫什么名字, 但我确定曾经玩过几次这个游戏, 最近的一次是我拿Lue和Love游戏引擎写点格棋游戏的时候, 在社区里看到有人分享了用Love做的这个游戏. 查了一下, 原来叫灭灯游戏(<a href="https://en.wikipedia.org/wiki/Lights_Out_%28game%29">Lights Out</a>), 在国内貌似一般叫点灯游戏? 不过也没差, 这个点灯游戏规则很简单, 相信很多人都玩过, 长方形中划分网格, 每个网格是盏灯, 且有亮与暗两种状态, 游戏中唯一的操作是选择一盏灯改变状态, 同时这盏灯上下左右的灯(如果存在的话)状态也将同时改变, 游戏初始状态时可能有几盏灯已经是点亮的, 游戏的目的是经过一系列的开关灯的操作, 使网格中的灯全部点亮. 这里有个<a href="https://www.geogebra.org/m/JexnDJpt#material/YXt3VhPn">在线版本</a>可以重温一下.</p><p>本来感觉这个点灯游戏也没什么, 感觉还是有博弈的游戏像是<a href="https://en.wikipedia.org/wiki/Dots_and_Boxes">点格棋</a>更有意思一些, 直到我看到了知乎专栏的这篇文章<a href="https://zhuanlan.zhihu.com/p/21265602">点灯游戏: 简单的游戏能否很美?</a>, 说实话确实很美, 甚至感到有些震撼. 于是我打算稍微探索一下这个游戏, 所幸文章作者写得非常认真, 相关的结论和参考都有总结, 遗憾的是没有提到结论的证明. 虽然是已经被前人研究得比较透彻的问题, 但我还是想写点自己的理解, 于是就诞生了这篇不务正业的文章…</p><span id="more"></span><h1 id="搜索算法解"><a href="#搜索算法解" class="headerlink" title="搜索算法解"></a>搜索算法解</h1><p>要用搜索算法来解点灯问题就比较简单粗暴, 遍历所有点灯方案找出满足要求的方案即可(在leetcode中还需要得到操作最少的方案). 在解决问题之前首先必须对问题有足够的理解, 我们必须先说明下面虽明显但重要的两点, 即:</p><ul><li>操作的顺序无关性. 对于将所有灯从初始状态状态转换成全亮的点灯方案, 其一系列操作的顺序可以是任意的, 这很好理解, 因为对于点灯游戏, 灯的最终状态只取决于两点, 即初始状态与状态翻转的次数, 而与翻转的先后次序无关.</li><li>操作的非重复性. 这即是说如果我们需要找到一个操作最少的方案, 那么每盏灯被选择改变状态的次数是最多一次. 结合前面操作的顺序无关性很容易说明. 假设有这么一组操作方案是点灯游戏的一个解, 而这组操作中包含了多次选择同一盏灯进行翻转的操作, 我们可以利用顺序无关把这些操作集中到一起, 也就是连续对同样的灯进行翻转. 由于灯只有两种状态, 偶数次的相同操作相当于没操作, 奇数次的相同操作相当于操作了一次, 因此该方案都不可能是操作最少的方案.</li></ul><p>了解了上面两点我们才可以尝试着去解决问题, 其实这里我还尝试着考虑了下操作的唯一性, 但是无果. 有了更多的了解之后才意识到解确实不是唯一的.</p><p>算法的大致构思即测试所有点灯方案, 如满足要求记录下该方案. 剩下来的就是一些技术问题, 我们怎么存储点灯方案, 灯的当前状态又如何表示? 这里用二进制数来进行表示是一个比较好的想法, 其一是比较节省存储空间, 其二是状态的翻转可以用对相应位的异或来实现. 但是二进制矩阵不太容易实现, 对于小型规模的点灯游戏, 用c++内置类型即可, 如4字节int型可以用于存储32盏灯的状态, 这里涉及到的一个问题是两者从矩阵到数列坐标的转换. 对于测试的每一种点灯方案, 也可以用一个int来存储, 1的那些位表示直接选择翻转的灯. 当然别忘了选择翻转的灯的上下左右(如果存在的话)也需要进行翻转. 操作的次数只需要计算存储电灯方案int中二进制下1的个数即可. 下面是code.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minFlips</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>(); <span class="comment">// 灯矩阵行数</span></span><br><span class="line">        <span class="type">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">// 灯矩阵列数</span></span><br><span class="line">        <span class="type">int</span> stat = <span class="number">0</span>; <span class="comment">// 存储初始灯的状态</span></span><br><span class="line">        <span class="type">int</span> plan = <span class="number">0</span>; <span class="comment">// 当前应用的电灯方案</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>; <span class="comment">// 存储最少的操作次数 若不可解则返回-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; i++) <span class="comment">// 初始状态生成</span></span><br><span class="line">        &#123;</span><br><span class="line">            stat = stat &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            stat += mat[i / n][i % n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (plan &lt; <span class="built_in">pow</span>(<span class="number">2</span>, m * n)) <span class="comment">// 遍历所有点灯方案 共 2^(mn) 种</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 存储当前点灯方案操作次数</span></span><br><span class="line">            <span class="type">int</span> num = plan;</span><br><span class="line">            <span class="keyword">while</span> (num)</span><br><span class="line">            &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                num &amp;= (num - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 如果该方案操作次数超过了之前解的操作次数 直接跳过该方案</span></span><br><span class="line">            <span class="keyword">if</span> (ans != <span class="number">-1</span> &amp;&amp; ans &lt;= cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                plan += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> temp = stat ^ plan; <span class="comment">// 将temp初始化为 初始状态下翻转该方案选择操作的那些灯 后的结果</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; i++) <span class="comment">// 遍历plan</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (plan &amp; (<span class="number">1</span> &lt;&lt; m * n - i - <span class="number">1</span>)) <span class="comment">// 翻转选择操作的那些灯上下左右的灯</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i / n - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                        temp ^= (<span class="number">1</span> &lt;&lt; (m * n - (n*(i / n - <span class="number">1</span>) + i % n) - <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span> (i / n + <span class="number">1</span> &lt; m)</span><br><span class="line">                        temp ^= (<span class="number">1</span> &lt;&lt; (m * n - (n*(i / n + <span class="number">1</span>) + i % n) - <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span> (i % n - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                        temp ^= (<span class="number">1</span> &lt;&lt; (m * n - (n*(i / n) + i % n - <span class="number">1</span>) - <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span> (i % n + <span class="number">1</span> &lt; n)</span><br><span class="line">                        temp ^= (<span class="number">1</span> &lt;&lt; (m * n - (n*(i / n) + i % n + <span class="number">1</span>) - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">0</span>) <span class="comment">// 当temp为0时 即灯全亮 是一个解</span></span><br><span class="line">                ans = cnt;</span><br><span class="line">            plan += <span class="number">1</span>; <span class="comment">// 处理下一个点灯方案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的实现思路是比较简单的, 具体实现中其实也并没有遍历所有点灯方案的必要(在只要求找到最少操作方案的条件下), 因此当我们遍历到一个点灯方案操作灯的数量多于已经找到的解时, 将直接跳过这个方案的处理(无论这个方案是否为解). 上述搜索算法时间复杂度显见是$O(2^{mn}*mn)$的. 这意味着当灯的数量较少时才可能在比较短的时间内找到解, 以我现在手头上的i5surface laptop来说, 找到4*4规模初始状态为灯全灭的点灯游戏的最优解(操作最少的解)需0.007s, 5*5需要11.829s, 而6*6则已经在30分钟以上了. </p><h1 id="线性代数解"><a href="#线性代数解" class="headerlink" title="线性代数解"></a>线性代数解</h1><p>讨论完了暴力的搜索算法, 那么从数学的角度如何求解点灯问题呢? 根据<strong>每盏灯最终状态可由总翻转次数与初始状态确定</strong>这一点, 可以列线性方程来求解. 以下内容可参考Mathematica博客的这篇文章<a href="http://mathworld.wolfram.com/LightsOutPuzzle.html">Lights Out Puzzle</a>. </p><p>以3*3规模的点灯游戏为例, 我们首先需要得到一个9*9的二元对称矩阵$\boldsymbol{A}$,</p><script type="math/tex; mode=display">\boldsymbol{A}=\begin{pmatrix}1&1&0&1&0&0&0&0&0\\1&1&1&0&1&0&0&0&0\\0&1&1&0&0&1&0&0&0\\ 1&0&0&1&1&0&1&0&0\\0&1&0&1&1&1&0&1&0\\0&0&1&0&1&1&0&0&1\\0&0&0&1&0&0&1&1&0\\0&0&0&0&1&0&1&1&1\\0&0&0&0&0&1&0&1&1\\\end{pmatrix}</script><p>矩阵$\boldsymbol{A}$中只有元素0和1, 且是对称矩阵, 对于同样规模和规则的点灯游戏, 矩阵$\boldsymbol{A}$都是相同的. $\boldsymbol{A}$的每一行是这么来的, 依然把3*3的9盏灯按行展开排成一行, $\boldsymbol{A}$的第i行由将第i盏灯和其上下左右灯(如果存在的话)的位置置1其余置0得到. 如$\boldsymbol{A}$的第一行, 先把第一个位置自己置1, 然后在点灯游戏中第一盏灯在最左上角, 把其下与其右的灯的位置(2与4)也置1, 其余位置为0. 也可以说成$\boldsymbol{A}$的第i行相当于把所有影响第i盏灯状态的位置都置1, 其余置0. </p><p>一旦构成了$\boldsymbol{A}$, 那么顺理成章, 我们将点灯方案排成一列, 为9*1的列向量, 规定选择翻转的位置为1其余为0, 用$\boldsymbol{x}$表示. 同理我们可以假设$\boldsymbol{r}$为所有灯最终状态, 而$\boldsymbol{c}$表示所有灯初始状态, 那么上述向量之间的关系为,</p><script type="math/tex; mode=display">\boldsymbol{Ax}+\boldsymbol{c}=\boldsymbol{r}</script><p>注意上式我们只在GF(2)内进行讨论(关于伽罗华域顺便安利一下介绍纠错码的<a href="https://blog.openacid.com/storage/ec-2/">这篇文章</a>), 因为灯的状态只有0和1这两种. 将上式改成,</p><script type="math/tex; mode=display">\boldsymbol{Ax}=\boldsymbol{r}-\boldsymbol{c}=\boldsymbol{c'}</script><p>剩下来的问题就是解上面的非齐次线性方程组了. 可以用我们熟悉的高斯消元法(<a href="https://en.wikipedia.org/wiki/Gaussian_elimination">Gaussian elimination</a>)来解, 就是用初等变换将增广矩阵化为行阶梯型来求解, 解不唯一时需要先求对应齐次方程组通解与其本身一个特解, 然后组合通解与特解得到所有方程组的解. 由于方程组是定义在GF(2)上的, 解的每一位从0与1中取值, 因此化为阶梯型后对于有$d$个自由变量的方程组共有有$2^d$个解. 所以这个解的数目确实不是唯一的, 下图是2*3规模点灯游戏初始状态为全灭的4个解(黑色表示选择翻转的灯, 下同). 从图中可以看出解具有对称性.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/2_3.png" style="zoom:20%;" /></p><p>求解代码放在<a href="https://github.com/Granvallen/LightOutGame">这里</a>, 为了能够存储任意位数的二元矩阵使用了bitset类型, 其支持一些方便的位操作. 高斯消元法的时间复杂度为$O((mn)^3)$, 接着遍历找多解复杂度$O(2^d)$, 同样初始全灭的条件下, 解100*100规模点灯游戏找到所有的解需要15s, 相比搜索算法已经快了不少. 至于更快的方法主要是优化GF(2)下的方程组求解, 使用并行计算或改进高斯消元法. 下图为100*100的唯一解,</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/100_100.png" style="zoom:50%;" /></p><p>随便再放些不同规模解的图案吧, 可以发现有相当多的解是对称的, 特别是5倍数规模的解, 非常具有对称美. 以下为部分5倍数规模且解唯一的解图.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/5x.png" style="zoom:100%;" /></p><p>对于一些多解的情况也有不少是对称的, 下面是4*4, 5*5, 9*9, 16*16的多解图.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/4_4.gif" style="zoom:100%;" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/5_5.gif" style="zoom:100%;" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/9_9.gif" style="zoom:100%;" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/16_16.gif" style="zoom:100%;" /></p><p>部分规模的解实在是太多了, 如30*30规模有$2^{20}$个解. 另外一个比较有意思的是对于有多解的情况, 存在着一种或多种最终不改变所有灯状态的点灯方案, 可由对应齐次方程组的解得到. 如下图是5*5不变的方案.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/5_5qp.png" style="zoom:10%;" /></p><hr><h1 id="番外-解存在性讨论"><a href="#番外-解存在性讨论" class="headerlink" title="番外 解存在性讨论"></a>番外 解存在性讨论</h1><p>事实上对于任意的m和n, 只要是满足自反(reflexive)与对称(symmetric)的点灯游戏, 初始状态为灯全灭的情况下, 可以证明游戏必定有解. 当然, 如果初始状态时已经有部分灯点亮则不一定有解. 证明之前先解释一下点灯游戏满足的自反与对称是什么.</p><p>自反即是说当选择一盏灯时, 除了翻转与这盏灯相邻灯的状态, 这盏灯本身也会状态翻转. 而对称是说相邻的两盏灯的状态相互影响, 当其中一盏翻转时, 另一盏灯的状态也会翻转. 其实点灯游戏有非常多的变种(就和魔方一样), 有些并不完全满足上面的两点, 比如<a href="https://en.wikipedia.org/wiki/Merlin_%28console%29">Merlin Magic square</a>游戏. </p><p>说明完毕, 推理证明如下.</p><p>使用反证, 假设存在着满足上述要求(自反, 对称, 初始状态为灯全灭)的点灯游戏无解, 且我们认为无解的情况中规模最小的有n盏灯, 此时n-1盏灯的点灯游戏则是可解的(如果不可解, 那么无解情况中规模最小的就应该是n-1盏灯了). 需要注意的是, 这里我们其实无视了灯的空间排列, 前面的讨论中, 点灯游戏普遍把所有灯排列成一个正方形或矩形, 这样只是为了让人容易看清(共享边的两盏灯是相互影响的), 但就本质上说, 我们完全可以用有向图(Directed Graphs)的结构来描述这个点灯游戏, 每盏灯是图中的一个结点, 由于游戏是对称的, 相互影响的灯的关系可以用双向的连线来表示, 因此这里不需要纠结n或者n-1盏灯能不能排列成矩形的空间结构的问题, 或者说能构成矩形空间结构的有向图在我们现在讨论的图的基础上需要更苛刻的条件.</p><p>如前所述, 那么我们必然有把这n盏灯中<strong>n-1盏灯点亮而只剩1盏灯灭掉</strong>的点灯方案(点灯方案指的就是n盏灯中选择哪几盏灯进行状态翻转), 这里的根据就是n-1盏灯的点灯游戏是可解的. 从n盏灯中选出n-1盏灯构成一个更小规模且可解的点灯游戏, 如果当这个小规模的点灯问题解决后(这n-1盏灯全点亮), 剩下来的那盏灯的状态是点亮的, 那么这个n盏灯的点灯游戏就也是可解的了, 这与假设矛盾, 因此孤立出来的那盏灯的状态必定是灭掉的. 对于总共n盏灯, 这n-1盏灯的选择显然有n种, 且这n种选择都能够完成上面所说的n-1盏灯亮1盏灯灭, <strong>如此便得到了相应的n种点灯方案</strong>.</p><p>将上面得到的n种点灯方案从灯全灭的初始状态开始连续施行一次, 我们发现当n为偶数时, 所有灯的状态正好翻转奇数(n-1)次, 如此一来最终n盏灯的状态就都是点亮的了! 因而n盏灯的点灯游戏就可解, 与假设再次矛盾, <strong>推出结论n只可能是奇数</strong>(当n为奇数时, 我们执行完上述n种点灯方案后, 所有灯翻转偶数次, 即状态不变, 全为灭).</p><p>我们继续讨论这n盏灯中是否存在着与偶数(包含0)盏其他灯相关联的灯(从有向图的观点来说, 就是这n个结点中是否存在着与偶数个其他结点双向连接的结点), 也就是这盏灯的状态翻转将影响其他奇数盏灯的状态翻转. 我们先假设存在这样满足条件的灯, 取其中的一盏来讨论, 把这盏灯和其关联的另外奇数盏灯单独划分为一组, 组内就有奇数盏灯. 我们从前面得到的n种点灯方案中挑选出<strong>以组内灯为最后灭掉的灯的那些方案</strong>, 将挑选出的这奇数个点灯方案同样从灯全灭的初始状态开始连续施行一次, 此时n盏灯中非组内灯的状态都改变了奇数次, 故都为点亮状态, 而组内灯状态则都改变了偶数次, 状态不变. 最后我们选择改变前面提到的满足条件的那盏灯, 如此组内灯的状态将再都改变一次, 即也都将被点亮. 此时我们发现所有灯都被点亮, 此n盏灯的点灯游戏可解, 再次与假设矛盾, 由此得到结论<strong>这n盏灯的每一盏灯都与其他奇数盏灯相关联, 而不可能是偶数盏</strong>.</p><p>推到这里, 其实我们已经找到了矛盾, 只是不是特别明显, 即<strong>点灯游戏的对称性</strong>与我们前面推出的<strong>有奇数盏灯且每盏灯都与其他奇数盏灯相关联</strong>之间存在矛盾. 点灯游戏的对称性也可以推出一个结论, 那就是<strong>当执行所有灯都选择点亮一次的点灯方案时, 不计算那些直接选择的灯的那次翻转, 只计算那些因其他灯选择翻转由于受关联而间接翻转的次数, 在这个意义下所有灯的累计翻转次数总是偶数次的</strong>. 道理也是显而易见的, 这里所谓游戏的对称性就是两盏相关联的灯是相互影响的, 选择一盏灯直接地状态翻转会间接地翻转相关联的另一盏灯, 而对那另一盏灯来说也同理. 当上述点灯方案都选择一次翻转后, 就这两盏相互关联的灯来说实际翻转了4次, 前面说这里我们不计算因直接选择的翻转, 所以计间接翻转的2次. 可见每一组相关联的灯都会计间接翻转的两次, 故最终所有灯累计的间接翻转次数必为2的倍数即偶数. 严谨起见, 我想还需要补充两点说明. 其一是这里计算的是因间接影响的翻转次数, 这仅仅是为了推理讨论的便利性(虽然其本身的理解增加了复杂性?). 其二是严格来说, 对于实际的一个点灯问题自然是不会出现<strong>孤立的灯</strong>的情况(这盏灯不与其他任何灯相关联), 但当存在孤立的灯时, 上述由对称性得到的结论仍然是正确的, 因为当选择点亮孤立的灯时, 由于没有与其相关联的灯, 所以计入的翻转次数为0. </p><p>但是如果点灯游戏中有奇数盏灯, 依然执行所有灯都选择翻转状态一遍的点灯方案, 为了能获得总共偶数次的间接翻转, 必然不可能每盏灯相关联的灯的数目都是奇数的, 或者说必定存在着与其他偶数盏灯(包括关联0盏的孤立的灯)相关联的灯, 这样我们就推得了最后一个矛盾, 从而否定了最开始无解的n盏灯的点灯游戏的存在性假设, 命题得证. </p><p>文字描述的证明有些地方确实啰嗦了点, 但我想还是尽可能留下更多的细节便于理解. 用线性代数的视角我们可以得到更简洁又严密的证明. 这里最后再说明一点, 在我参考的<a href="https://www.jaapsch.net/puzzles/lomath.htm#refs">The Mathematics of Lights Out</a>博客中, 作者对于最后一个矛盾的阐述举了一个更生动的例子, 但需要注意其与点灯游戏之间的差异. 这个例子是说<strong>有奇数个人参加聚会, 在聚会上自然少不了有些人会相互握手, 但是无论有多少人握手, 总存在和偶数个其他人握手的人(包括一次都没有和其他人握手的人)</strong>. 这个例子确实容易理解很多, 而这个例子与点灯游戏的差异在于握手是关联的双方同时进行的, 且每一次握手操作都只涉及握手的双方. 而对于点灯游戏, 每一次的操作是选择一盏灯进行状态翻转, 故灯之间的相互影响(间接翻转)是分开进行的, 且一次操作同时影响多盏其他的灯, 但我们依然可以理解这背后其实是一回事, 也就是对称性的体现. 另一个差异则是点灯游戏具有自反性, 握手则自然不可能自己与自己握手, 因此在上面讨论中我们忽略了直接选择时的状态翻转.</p><hr><p>同样引入线性代数能很大程度简化证明, 我们知道当非齐次线性方程组无解时有$\mathrm{rank}(\boldsymbol{A})&lt;\mathrm{rank}(\boldsymbol{A|\boldsymbol{c}’})\leqslant mn$. 那么必然存在着非$\boldsymbol{0}$列向量$\boldsymbol{v}$有,</p><script type="math/tex; mode=display">\boldsymbol{v}^T\boldsymbol{A}=\boldsymbol{0}^T</script><p>并且,</p><script type="math/tex; mode=display">\boldsymbol{v}^T\boldsymbol{c}'=1</script><p>这里稍微解释下, 若上式不成立则,</p><script type="math/tex; mode=display">\boldsymbol{v}^T\boldsymbol{A}\boldsymbol{x}=\boldsymbol{v}^T\boldsymbol{c}'=0</script><script type="math/tex; mode=display">\boldsymbol{0}^T\boldsymbol{x}=0</script><p>这样方程组便有解了. </p><p>由于点灯游戏的自反与对称性, $\boldsymbol{A}$是定义在GF(2)上的对称矩阵, 且对角线元素都为1, 因此有,</p><script type="math/tex; mode=display">\boldsymbol{v}^T\boldsymbol{A}\boldsymbol{v}=\boldsymbol{v}^T\boldsymbol{v}</script><p>这是因为左边展开后混合项都是成对出现, 故其系数皆为0, 只留下二次项. 结合最前面的式子便可得到,</p><script type="math/tex; mode=display">\boldsymbol{v}^T\boldsymbol{v}=0</script><p>于是,</p><script type="math/tex; mode=display">\boldsymbol{v}\boldsymbol{v}^T\boldsymbol{c}'=\boldsymbol{v}=\boldsymbol{0}</script><p>这与$\boldsymbol{v}$为非零向量矛盾, 假设不成立, 因此解必定存在.</p><p>其实在线性代数中有一个更强的定理, 对于定义在GF(2)上的对称矩阵$\boldsymbol{A}$, 存在$\boldsymbol{x}$满足$\boldsymbol{Ax}=\mathrm{Diag}(\boldsymbol{A})$, 翻译过来就是二元对称矩阵$\boldsymbol{A}$对角线元素构成的列向量必定在$\boldsymbol{A}$的列空间中, 详细证明见<a href="http://www.cs.toronto.edu/~yuvalf/Range.pdf">这里</a>. 如果知道这个定理对点灯游戏解的存在性甚至都不需要进一步说明, 因为在点灯游戏的设定下, 对称保证了$\boldsymbol{A}$是对称矩阵, 自反保证了$\boldsymbol{A}$对角线元素全为1, 而初始状态的$\boldsymbol{c}’$也总是全为1…</p><hr><p>最后的最后, 这点灯游戏竟然让我找回了小时候摆弄万花筒的感觉, 这大概也算是数学的魅力之一吧…</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://en.wikipedia.org/wiki/Lights_Out_%28game%29">Lights Out (game) wiki</a></li><li><a href="https://www.jaapsch.net/puzzles/lomath.htm#refs">The Mathematics of Lights Out</a></li><li><a href="http://mathworld.wolfram.com/LightsOutPuzzle.html">Lights Out Puzzle</a></li><li><a href="https://www.geogebra.org/m/JexnDJpt#material/YXt3VhPn">5x5 Lights Out</a></li><li><a href="https://www.brand.site.co.il/riddles/201103a.html">Using your Head is Permitted March 2011 riddle</a></li><li><a href="https://www.jaapsch.net/puzzles/lights.htm#desc">Lights Out</a></li><li><a href="http://www.cs.toronto.edu/~yuvalf/Range.pdf">Range of Symmetric Matrices over GF(2)</a></li><li><a href="https://people.sc.fsu.edu/~jburkardt/classes/imps_2017/11_28/2690705.pdf">Turning Lights Out with Linear Algebra</a></li><li><a href="https://blog.openacid.com/storage/ec-2/">Erasure-Code-擦除码</a></li></ul><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=30051839&auto=0&height=66"></iframe><p>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematica </tag>
            
            <tag> C++ </tag>
            
            <tag> oj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeCraft 2019</title>
      <link href="/codecraft2019/"/>
      <url>/codecraft2019/</url>
      
        <content type="html"><![CDATA[<p>又是一篇拖了好长时间的文章…</p><p>CodeCraft是华为2015年起开始举办的编程挑战赛, 强调享受用coding解决问题的乐趣. 其实那段时间(两个月前)有好几个华为组织的比赛什么销售, 云计算等等. 我因为之前都没参加过, 加之感觉coding会好玩一些所以报名了CodeCraft. 虽然最后完成了程序但没及时上传（；´д｀）ゞ, 嗯, 从结果来说好像连炮灰也没当成?</p><span id="more"></span><p>题目在<a href="https://codecraft.huawei.com/">这里</a>, 简单来说就是车辆调度的问题, 官方给出car.txt, road.txt和cross.txt三个文件即车, 路和路口信息, 根据简化后的交通规则, 你的程序需要输出每辆车的上路时间以及行驶路线. 拿到题目首先就必须研究下这个设定的交通规则, 其中涉及到不少细节问题, 大体规则可以参考官方文档, 以下是一些当时有疑问的细节和官方解答.</p><h1 id="规则细节"><a href="#规则细节" class="headerlink" title="规则细节"></a>规则细节</h1><h2 id="关于车辆在路上行驶的规则"><a href="#关于车辆在路上行驶的规则" class="headerlink" title="关于车辆在路上行驶的规则"></a>关于车辆在路上行驶的规则</h2><blockquote><p>车辆如果行驶过程中, 发现前方有车辆阻挡, 且阻挡的车辆为终止车辆, 则该辆车也被标记为终止车辆. （与前方阻挡的车辆的距离记为s）则该车辆最大行驶速度为v = min(最高车速, 道路限速, s/t) 其中t=1, 该车辆最大可行驶距离为s. </p></blockquote><p>这里官方文档第二句话少了”否”字, 应为</p><blockquote><p>否则该车辆最大行驶速度为v = min(最高车速, 道路限速, s/t) 其中t=1, 该车辆最大可行驶距离为s. </p></blockquote><p>也就是说当有前车开得比较慢时, 该车也要降低速度. 而第一句是说如果前车停了, 则该车立即停止. <strong>因此, 每辆车的速度每次轮到时都要根据前车情况重新计算. </strong> 另外如果前车是等待调度状态, 那么该车也是等待状态.</p><p>下面是官方给出的例子:</p><blockquote><p>假定道路有如下车辆, 车AB车速为3, CD均为车速为1<br><strong>A空空B空空CD （路口）</strong></p><p>按步骤一后ABCD均为等待状态. </p><p>在处理待状态车辆D后, 假定D前进到其他道路后, 此刻道路状态变化为</p><p><strong>A空空B空空C空   （路口）</strong></p><p><strong>接下来因D车辆的前进后, 需要对该条道路该车道的所有车辆进行一次调度</strong></p><p>因此:</p><p>C的车速为1, 则C车前进1个距离, 且为终止状态. <strong>A空空B空空空C   （路口）</strong></p><p>B的车速为3, 则B车前进3个距离, 且为终止状态. <strong>A空空空空空BC   （路口）</strong></p><p>A的车速为3, 则A车前进3个距离, 且为终止状态. <strong>空空空A空空BC   （路口）</strong></p><p><strong>调度后道路车辆分布为: 空空空A空空BC   （路口）, 且ABC均为终止状态</strong></p></blockquote><h2 id="关于车辆在路口调度的规则"><a href="#关于车辆在路口调度的规则" class="headerlink" title="关于车辆在路口调度的规则"></a>关于车辆在路口调度的规则</h2><p>例子如下图:</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/cross.png" style="zoom:67%;" /></p><blockquote><p>在本路口调度道路的顺序为</p><p>5000、5001、5010、5018、5000、5001、5010、5018、5000、5001、5010、5018…5000、5001、5010、5018</p><p>整个系统调度按路口ID升序进行调度各个路口, 路口内各道路按道路ID升序进行调度. </p></blockquote><p>也就是说, <strong>路口调度顺序与各道路的调度顺序是固定的.</strong></p><blockquote><p>首先调度5000道路, 只有D100可以走, 因为D101左转与5010道路的D200冲突, 所以必须等待5010车道上没有直行冲突. </p></blockquote><p>这里的<code>D101</code>官方又写错了, 应该是<code>L101</code>, 该车是当前5000道路优先级最高的车, 但与5010最高优先级直行的车<code>D200</code>冲突(都要到5018道路), 直行的优先级更高, 故对5000道路的调度先搁下了(当道路最高优先级的车停下, 其他车也不能动). </p><p><strong>因此, 当对路口的一条道路调度时, 首先看这条道路优先级最高的车, 若不与其他道路最高优先级的车冲突, 则立即行驶, 然后看该道路第二优先级的车. 如果有冲突, 则调度下一条道路.</strong></p><blockquote><p>其次再调度5001道路, 因5001道路的L300与道路5018的D400冲突, 所以L300必须等待道路5018的D400先行后再调度行驶. </p><p>再次调度道路5010, D200、D201、D202不与其他道路的车辆冲突, 可以直接行驶. L203左转, 且道路5001无左转车辆与其冲突, 因此L203可以左转. L204也可以左转. L205为右转, 与左侧道路5000的车辆L101不冲突（只与道路5000的直行会发生冲突）, 且与道路5018的D400不发生冲突（只与道路5018的左转车辆发生冲突）, 因此车辆L205可以右转, 依次道路5010上的剩余车辆全部可以通过. </p></blockquote><p>在道路通畅的条件下(驶入道路没有限制), 路口调度应该是这样的:</p><ul><li>当调度一辆车是直行的时候一定可以立即直行</li><li>当调度一辆车左转时, 只需要看右边道路最高优先级的车是否直行</li><li>当调度一辆车右转时, 需要看左边道路优先级最高的车是否直行以及对面车道优先级最高的车是否左转</li></ul><p>在实际情况时还要考虑车驶入车道的情况, 比如驶入车道是拥堵的, 此时该车的调度也只能先搁下.</p><blockquote><p>接着调度5018道路上的车辆…..</p><p>再调度道路5000….</p><p>再调度道路5001…</p><p>再调度道路5000….</p><p>是否发生冲突, 只与相关道路的第一优先级车辆的行驶方向进行比较, 看是否发生冲突. </p><p>每次调度到一条道路, 直到该道路无车辆可调度, 或该条道路上车辆处于冲突状态. 也就是说尽可能多地让该道路行驶, 直到没有车辆或者车辆与其他车辆发生冲突不可行驶. </p></blockquote><h2 id="关于车辆从路口进入道路"><a href="#关于车辆从路口进入道路" class="headerlink" title="关于车辆从路口进入道路"></a>关于车辆从路口进入道路</h2><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/enterroad.png" style="zoom: 80%;" /></p><p>这里要注意的是<strong>发车顺序</strong>, 先是100-&gt;200-&gt;300, 然后101-&gt;201-&gt;301. 这里200比101更靠近路口, 尽管101在1号道, 200在2号道, 依然是200先行. 这一点在上面的路口冲突判断的图里也有体现, 当<code>D101</code>走后是判断<code>L101</code>, 而不是<code>L103</code></p><h2 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h2><blockquote><p>基于10, <strong>参赛选手需要注意</strong>, 一次调度能使所有车辆均到达各车辆的行驶速度行驶, 就得保证不能出现各车辆循环等待的情况, 否则该次调度就会<strong>锁死</strong>. 循环等待是指比如车辆A等待车辆B, 车辆B等待车辆C, 车辆C等待车辆D, 车辆D等待车辆E, 车辆E等待车辆F, 车辆F等待车辆A的情况. </p></blockquote><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>问: 如果一个路口的所有道路的车都冲突不动了, 怎么办? 是直接结束该路口的调度? 这样的话如果下一路口调度了导致上一路口可以再进行调度, 还需要对上一路口进行调度吗? 如果不进行调度那么路口的调度顺序对结果影响很大?</p><p>答: 是的, 会对上一路口再次进行调度(会进行下一次路口的调度循环), 只要有一个路口还需要调度, 就会再进行一次调度所有路口的循环</p><p>问: 每辆车都有出发时间的限定, 但是规则中出现<code>实际出发时间</code>的说法, 那么是程序可以调节车的实际出发时间吗? 还是只能是因为道路堵塞推迟出发时间?</p><p>答: 车辆的实际出发时间由参赛选手自行决定, 但是不得早于车辆的计划出发时间</p><p>问: 起步车辆放置于车道的位置确定问题?</p><p>答: 进入道路依然按车道小的优先策略进行</p><p>问: 那么起步车辆与路口调度时的车辆比, 优先级如何?</p><p>答: 系统调度先调度在路上行驶的车辆进行行驶, 当道路上所有车辆全部不可再行驶后再调度等待上路行驶的车辆</p><p>问: 多辆车同地点同时发车?</p><p>答: 交通规则有说明, 同一时刻多辆车上路行驶, 按车辆编号升序进行优先上路</p><p>其他: </p><blockquote><p>整个系统限制参赛选手程序编译时间最大为60s, 程序运行生成answer.txt时间为300s. </p><p>车辆的长度为1(占一格), 行驶速度的含义是一个时间单位内前进的格数</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>整个系统要调度的只有车, 更确切点说是车的两个值: <strong>实际出发时间</strong>和<strong>车在每个路口选择的行驶方向</strong>, 除此之外都由规则定死了. 也就说只要确定了每辆车的这两个值, 那么最后的结果就是确定的, 不存在任何的随机性.</p><p>总的来说, 解决这个问题的想法大概有两个吧.</p><p>其一直接最优化, 系统根据输入和规则直接给出最优的调度方案. 因为本质上说这是一个最优化问题. 但我还是怀疑有没有这种解法, 题目设定的规则还是过于复杂, 于是没有做这方面的尝试, 而偏向于使用模拟或尝试性的解决办法.</p><p>退而求其次可以逐步最优, 系统首先对输入进行模拟, <strong>在每个时间片上(只考虑当前时刻)进行最优调度</strong>, 但每个时间片上的最优策略就结果来说并不能保证是最优的. 不过即使简化到这样可能对我来说实现还是比较困难. 不怕, 大不了在逐步最优的基础上, 再进行简化嘛, 比如变成在<strong>每个时间片上对每辆车单独进行最优调度</strong>. 还不够, 因为这个系统中的车的行驶过程不是独立的, 可能会相互影响, 因此即使单独考虑每一辆车的最优可能也是困难的, 所以只能是<strong>尽可能地靠近最优调度</strong>.</p><p>综上, 目前考虑的方法是建立在模拟运行的基础上, <strong>每一个时间片对每辆车单独地做出尽可能接近最优的调度</strong>. 这个方法可能比较好的一点是策略是动态的, 可以根据模拟运行时的情况对调度进行调整, 而这个调整(如何尽可能接近最优)也可以有发挥的余地.</p><p>以上讨论的都是车在路口的行驶方向的选择问题, 还有一部分是车实际出发时间的确定问题, 时间比较紧就没怎么考虑过. 总之现阶段考虑车能出发则出发, 不能出发则等到能出发为止. 当然一个理想的系统可能会故意延长车的实际出发时间(能出发不出发), 以达到系统更优.</p><p>要解决这个问题路径规划(Pathfinding)算法是必不可少的, 用于实际在每个路口确定行驶方向. 这方面优先考虑的是启发式路径搜索的A*, 在<a href="http://theory.stanford.edu/~amitp/GameProgramming/">Amit’s A* Pages</a>有比较详细的介绍和生动的例子, 同时也参考了部分将启发性路径搜索算法应用于实际导航路径规划的文献. 正当要动手开始写的时候发现了一个致命的问题—比赛给的地图不保证是物理可实现的. 启发式路径搜索不同于传统路径搜索的地方在于在计算路径cost的时候多了一个启发函数项(heuristic function), 因此路径搜索受启发函数影响优先往函数值小的方向搜索. 这类方法的主要问题在于如何选择这个启发函数, 选择的好坏最终将影响路径搜索的效率, 这也是为什么这个名字这么玄乎的原因. 通常采用欧式距离(平面坐标)和曼哈顿距离(网格坐标)作为启发函数, 这通常来说是合理的, 但都要求知道每个节点确切的坐标信息, 而赛题中只是知道节点与边的关系, 需要自己去构建一个位置关系, 由于是非实际可实现的道路, 先不说能不能构建或容不容易构建, 即使构建出来, 要设计一个符合的启发函数也不容易. というわけで, 最后还是采用了Dijkstra算法(摊手), 顺带稍稍优化了权重计算.</p><h1 id="程序大体框架"><a href="#程序大体框架" class="headerlink" title="程序大体框架"></a>程序大体框架</h1><ul><li>car.hpp实现了Car与CarList两个类, 用于封装车辆信息</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Car</span>() &#123;&#125; <span class="comment">// 为什么没有默认构造函数会报错</span></span><br><span class="line"><span class="built_in">Car</span>(<span class="type">long</span> id, <span class="type">long</span> from, <span class="type">long</span> to, <span class="type">int</span> speed, <span class="type">long</span> planTime):</span><br><span class="line"><span class="built_in">id</span>(id), <span class="built_in">from_id</span>(from), <span class="built_in">to_id</span>(to), <span class="built_in">max_speed</span>(speed), </span><br><span class="line"><span class="built_in">plan_time</span>(planTime), <span class="built_in">next_cross</span>(from), <span class="built_in">isSetoff</span>(<span class="literal">false</span>), <span class="built_in">isStoped</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">Car</span>(<span class="type">long</span>* carinfo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (carinfo)</span><br><span class="line">&#123;</span><br><span class="line">id = carinfo[<span class="number">0</span>];</span><br><span class="line">from_id = next_cross = carinfo[<span class="number">1</span>];</span><br><span class="line">to_id = carinfo[<span class="number">2</span>];</span><br><span class="line">max_speed = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(carinfo[<span class="number">3</span>]);</span><br><span class="line">plan_time = carinfo[<span class="number">4</span>];</span><br><span class="line">isSetoff = isStoped = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showRoute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Car &amp;car);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> id; <span class="comment">// 车的id</span></span><br><span class="line"><span class="type">long</span> from_id; <span class="comment">// 起始路口id</span></span><br><span class="line"><span class="type">long</span> to_id; <span class="comment">// 终点路口id</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max_speed; <span class="comment">// 最大车速</span></span><br><span class="line"><span class="type">int</span> curr_speed; <span class="comment">// 当前车速  这个变量到目前为止好像没起什么作用 可能到考虑实时路况时才能起参考</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 车在一条路上的坐标 如一条长为4的路坐标为 1 2 3 4</span></span><br><span class="line"><span class="comment">// 这个值在车进入道路时初始化 行进过程中更新</span></span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isSetoff; <span class="comment">// 是否已出发</span></span><br><span class="line"><span class="type">long</span> plan_time; <span class="comment">// 原计划出发时间</span></span><br><span class="line"><span class="type">long</span> real_time; <span class="comment">// 实际出发时间</span></span><br><span class="line"><span class="type">long</span> dally_time; <span class="comment">// 已延迟的时间</span></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">long</span>&gt; route_plan; <span class="comment">// 计划路线经过的路口id 不包括已经走过的路口 虽然答案里要求是行驶道路的id</span></span><br><span class="line">list&lt;<span class="type">long</span>&gt; route_real; <span class="comment">// 实际行驶经过路口id</span></span><br><span class="line"><span class="type">int</span> next_turn; <span class="comment">// 下一个路口转弯方向 0-上 1-右 2-下 3-</span></span><br><span class="line"><span class="type">long</span> next_road; <span class="comment">// 下一条行驶的道路id 行驶到路口更新</span></span><br><span class="line"><span class="type">long</span> next_cross; <span class="comment">// 下一个路口id</span></span><br><span class="line"><span class="type">int</span> lane_num; <span class="comment">// 所行驶的车道号 车在上路时更新</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isStoped; <span class="comment">// 是否停车</span></span><br><span class="line"><span class="type">bool</span> isScheduled; <span class="comment">// 是否在当前时间片段经过调度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CarList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CarList</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">CarList</span>(string carfile) &#123; <span class="built_in">initCarList</span>(carfile); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initCarList</span><span class="params">(string carfile)</span></span>;</span><br><span class="line">Car&amp; <span class="keyword">operator</span>[](<span class="type">long</span> i) &#123; <span class="keyword">return</span> carlist[i]; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Car&amp; car)</span> </span>&#123; carlist[car.id] = car; &#125; <span class="comment">// unordered_map这里[]实现深复制</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">long</span> id)</span> </span>&#123; carlist.<span class="built_in">erase</span>(id); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> unordered_map&lt;<span class="type">long</span>, Car&gt;&amp; <span class="title">getList</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> carlist; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> carlist.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> carlist.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">long</span>, Car&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> carlist.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">unordered_map&lt;<span class="type">long</span>, Car&gt;::<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> carlist.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">long</span>, Car&gt; carlist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>road.hpp实现了Road与RoadList两个类, 用于封装道路信息</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Road</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Road</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">Road</span>(<span class="type">long</span>* roadinfo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (roadinfo)</span><br><span class="line">&#123;</span><br><span class="line">id = roadinfo[<span class="number">0</span>];</span><br><span class="line">length = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(roadinfo[<span class="number">1</span>]);</span><br><span class="line">max_speed = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(roadinfo[<span class="number">2</span>]);</span><br><span class="line">channel = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(roadinfo[<span class="number">3</span>]);</span><br><span class="line">from_id = roadinfo[<span class="number">4</span>];</span><br><span class="line">to_id = roadinfo[<span class="number">5</span>];</span><br><span class="line">isDuplex = roadinfo[<span class="number">6</span>] &gt; <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">road_from_to.<span class="built_in">resize</span>(channel);</span><br><span class="line"><span class="keyword">if</span> (isDuplex)</span><br><span class="line">road_to_from.<span class="built_in">resize</span>(channel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Road &amp;road);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> id;</span><br><span class="line"><span class="type">int</span> length; <span class="comment">// 路长</span></span><br><span class="line"><span class="type">int</span> max_speed; <span class="comment">// 最大车速</span></span><br><span class="line"><span class="type">int</span> channel; <span class="comment">// 车道数</span></span><br><span class="line"><span class="type">long</span> from_id; <span class="comment">// 起始路口id</span></span><br><span class="line"><span class="type">long</span> to_id; <span class="comment">// 终点路口id</span></span><br><span class="line"><span class="type">bool</span> isDuplex; <span class="comment">// 是否双向</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isBlock; <span class="comment">// 是否堵路</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Lane&gt;&amp; <span class="title">getRoadCars</span><span class="params">(<span class="type">long</span> to)</span></span>; <span class="comment">// 返回一个方向的所有车道</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getCarsNum</span><span class="params">(<span class="type">long</span> crossid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTo</span><span class="params">(<span class="type">long</span> crossid)</span> </span>&#123; <span class="keyword">return</span> crossid == to_id || (crossid == from_id &amp;&amp; isDuplex); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Lane&gt; road_from_to; <span class="comment">// 记录从from节点到to节点 各个channel行驶车的队列 存车的id</span></span><br><span class="line">vector&lt;Lane&gt; road_to_from; <span class="comment">// 如果是单行线的话这个vector是空的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoadList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RoadList</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">RoadList</span>(string roadfile) &#123; <span class="built_in">initRoadList</span>(roadfile); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initRoadList</span><span class="params">(string roadfile)</span></span>;</span><br><span class="line">Road &amp; <span class="keyword">operator</span>[](<span class="type">long</span> i) &#123; <span class="keyword">return</span> roadlist[i]; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Road&amp; road)</span> </span>&#123; roadlist[road.id] = road; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">long</span> id)</span> </span>&#123; roadlist.<span class="built_in">erase</span>(id); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> map&lt;<span class="type">long</span>, Road&gt;&amp; <span class="title">getList</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> roadlist; &#125;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">long</span>, Road&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> roadlist.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">map&lt;<span class="type">long</span>, Road&gt;::<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> roadlist.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">long</span>, Road&gt; roadlist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>cross.hpp实现了Cross与CrossList两个类, 用于封装路口信息</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cross</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cross</span>() &#123;&#125;</span><br><span class="line"><span class="comment">//Cross(long id, long road0, long road1, long road2, long road3) : id(id)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//road_id[road0] = 0; road_id[road1] = 1;</span></span><br><span class="line"><span class="comment">//road_id[road2] = 2; road_id[road3] = 3;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">Cross</span>(<span class="type">long</span>* crossinfo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (crossinfo)</span><br><span class="line">&#123;</span><br><span class="line">id = crossinfo[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 注意这里没路的 -1 也会放进去 把序号作为键 路id为值</span></span><br><span class="line">road_id[<span class="number">0</span>] = crossinfo[<span class="number">1</span>]; road_id[<span class="number">1</span>] = crossinfo[<span class="number">2</span>];</span><br><span class="line">road_id[<span class="number">2</span>] = crossinfo[<span class="number">3</span>]; road_id[<span class="number">3</span>] = crossinfo[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Cross &amp;cross);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由路序号得到路id</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">getRoadIdx</span><span class="params">(<span class="type">int</span> roadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : road_id)</span><br><span class="line"><span class="keyword">if</span> (i.second == roadid)</span><br><span class="line"><span class="keyword">return</span> i.first;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> id; <span class="comment">// 路口id</span></span><br><span class="line">map&lt;<span class="type">long</span>, <span class="type">int</span>&gt; road_id; <span class="comment">// 四个连接道路的id 没路的为-1 用map可以实现路id升序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int road_num; // 连接道路数目</span></span><br><span class="line"><span class="type">bool</span> isBlock; <span class="comment">// 是否堵塞</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CrossList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CrossList</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">CrossList</span>(string crossfile) &#123; <span class="built_in">initCrossList</span>(crossfile); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initCrossList</span><span class="params">(string crossfile)</span></span>;</span><br><span class="line">Cross &amp; <span class="keyword">operator</span>[](<span class="type">long</span> i) &#123; <span class="keyword">return</span> crosslist[i]; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Cross&amp; cross)</span> </span>&#123; crosslist[cross.id] = cross; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">long</span> id)</span> </span>&#123; crosslist.<span class="built_in">erase</span>(id); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> map&lt;<span class="type">long</span>, Cross&gt;&amp; <span class="title">getList</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> crosslist; &#125;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">long</span>, Cross&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> crosslist.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">map&lt;<span class="type">long</span>, Cross&gt;::<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> crosslist.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">long</span>, Cross&gt; crosslist; <span class="comment">// 由于之后cross要按id从小到大遍历 所以用有序map</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>RoadGraph.hpp实现RoadGraph类, 负责整合道路与路口构建图网络, 并且实现路径规划算法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoadGraph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RoadGraph</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">RoadGraph</span>(CrossList&amp; crosslist, RoadList&amp; roadlist) &#123; <span class="built_in">initGraph</span>(crosslist, roadlist); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化路线图 neighborsOf 与 distBetween 便于之后搜索路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initGraph</span><span class="params">(CrossList&amp; crosslist, RoadList&amp; roadlist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findFastestRoute</span><span class="params">(CrossList&amp; crosslist, RoadList&amp; roadlist, Car&amp; car)</span></span>;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">long</span>, list&lt;<span class="type">long</span>&gt; &gt; neighborsOf; <span class="comment">// 一个节点的相邻节点</span></span><br><span class="line">unordered_map&lt;<span class="type">long</span>, unordered_map&lt;<span class="type">long</span>, <span class="type">double</span>&gt; &gt; distBetween; <span class="comment">// 所有相邻节点的距离</span></span><br><span class="line">unordered_map&lt;<span class="type">long</span>, unordered_map&lt;<span class="type">long</span>, <span class="type">long</span>&gt; &gt; roadBetween; <span class="comment">// 所有相邻节点之间路的id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra_search</span><span class="params">(CrossList&amp; crosslist, RoadList&amp; roadlist, Car&amp; car)</span></span>; <span class="comment">// dijkstra路径搜索方法</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Scheduler.hpp实现了一个调度器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scheduler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Scheduler</span>(string cartxt, string roadtxt, string crosstxt): <span class="built_in">time</span>(<span class="number">0</span>), <span class="built_in">isDone</span>(<span class="literal">false</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">initScheduler</span>(cartxt, roadtxt, crosstxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> time; <span class="comment">// 调度时间</span></span><br><span class="line"><span class="type">bool</span> isDone; <span class="comment">//是否调度完成</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">step</span><span class="params">()</span></span>; <span class="comment">// 走一个时间片段</span></span><br><span class="line"></span><br><span class="line">CarList carwaitgo; <span class="comment">// 等待上路的车</span></span><br><span class="line">CarList carsetoff; <span class="comment">// 在路上的车</span></span><br><span class="line">RoadList roadlist;</span><br><span class="line">CrossList crosslist;</span><br><span class="line">RoadGraph roadgraph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initScheduler</span><span class="params">(string cartxt, string roadtxt, string crosstxt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduleCarwaitgo</span><span class="params">()</span></span>; <span class="comment">// 调度等待上路的车</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduleInit</span><span class="params">()</span></span>; <span class="comment">// 每次调度前准备</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduleRoad</span><span class="params">()</span></span>; <span class="comment">// 调度每一条道路</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduleLane</span><span class="params">(Road&amp; road, Lane&amp; lane)</span></span>; <span class="comment">// 调度路一个方向上的所有车道</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">scheduleCross</span><span class="params">()</span></span>; <span class="comment">// 调度所有路口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">scheduleCrossRoad</span><span class="params">(Cross&amp; cross)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enterRoad</span><span class="params">(Car&amp; car, Lane&amp; lane, <span class="type">int</span> lane_num, <span class="type">int</span> speed)</span></span>; <span class="comment">// 车进入道路</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leaveRoad</span><span class="params">(Car&amp; car, Lane&amp; lane)</span></span>; <span class="comment">// 车离开道路</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">getfirstCar</span><span class="params">(Road&amp; road, Cross&amp; to)</span></span>; <span class="comment">// 返回一个方向的车道中最先调度的车</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tryEnterRoad</span><span class="params">(Cross&amp; cross, Road&amp; road, Car&amp; car)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">answer</span><span class="params">(Car&amp; car)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showstatus</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag1; <span class="comment">// 记录遍历 所有cross 的一个循环中 是否发生了调度 如果调度再进行一次这个循环</span></span><br><span class="line"><span class="type">bool</span> flag2; <span class="comment">// 记录遍历 一个cross所有路 的循环中 是否发生了调度</span></span><br><span class="line"><span class="type">bool</span> flag3; <span class="comment">// 记录遍历一个cross所有路的循环中 是否发生了调度 如果调度再进行一次这个循环 直到没有调度</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> carnum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> donenum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> carwaitgonum = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> carsetoffnum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>main</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Scheduler <span class="title">scheduler</span><span class="params">(<span class="string">&quot;car.txt&quot;</span>, <span class="string">&quot;road.txt&quot;</span>, <span class="string">&quot;cross.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!scheduler.isDone)</span><br><span class="line">scheduler.<span class="built_in">step</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><ul><li>由于没有成功在赛方的服务器上跑过, 所以到底效果如何有没有其他问题都尚不明确, 虽然线下测试结果勉强还行, 也没碰到死锁的情况. 当然为了鲁棒性加个死锁判定还是有必要的.</li><li>由于比赛期间一直有其他事, 所以前后参赛了不到5天的时间. 后来看获奖者感言, 原来大家都一样, 都是在搬砖期间抽空做的, 白天搬砖, 晚上调程序…</li><li>全程玩得还是挺开心的, 嗯, 希望下次能做一个合格的炮灰(认真脸).</li></ul><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> CodeCraft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从《星游记》出发聊聊所见所想</title>
      <link href="/xingyouji/"/>
      <url>/xingyouji/</url>
      
        <content type="html"><![CDATA[<p>怎么想起聊聊<a href="https://movie.douban.com/subject/6952623/">《星游记》</a>呢, 大概源于最近偶然看到的几个新闻吧. 一是米哈游开发的新游<a href="https://www.taptap.com/app/168332?utm_source=baidu&amp;utm_medium=sem&amp;utm_campaign=%E5%8E%9F%E7%A5%9E">《原神》</a>放出的pv由于过于像《塞尔达传说:旷野之息》被指抄袭引起网上热议; 二是<a href="https://movie.douban.com/subject/26709258/">《罗小黑战记》</a>的首部电影将在2019年7月上映. 由这两件事情我立马想起了星游记, 我觉得我想说些什么所以写了下来, 不过只是作为一个普通的吃瓜群众谈谈所见所想罢了.</p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=730250&auto=0&height=66"></iframe><p>为什么会由原神想到了星游记? 因为星游记从开播起, 也一直以来就没有真正走出被指抄袭海贼王的阴影, 只要有其出现的地方就少不了这些争论. 星游记与海贼设定相似的确是无可争议的事实(导演刘北就是海贼的粉丝), 我个人其实无意参与这些争论, 是借鉴学习也好, 抄袭也罢, 这些还是交给法律与律师去界定吧. 只是, 我个人觉得作品本身的素质以及能否带给观众某种共鸣更重要一些(自然前提是合法的), 而不是它被贴上的各种标签. 说回这两件事它们其实还是有本质的不同, 原神pv明眼人一眼就能看出模仿的是塞尔达(各种剪辑分析的朋友可以歇一歇了), 就如网上所说很可能就是米哈游的营销手段, 这样的做法确实算不上光彩, 至于合法性, 偌大的公司一定有它的考量. 尽管如此, 刚看到原神pv时我依然抱有某种期待, 虽然是模仿但能达到什么样的精致程度? 又融入了制作者什么样的新想法? 此前任天堂公开的塞尔达制作的理念被原神消化了多少?(从目前流出来的内容来看定位依然是米哈游一贯的偏宅向)</p><p>为什么会由罗小黑战记想到了星游记? 因为他们都曾是我心目中最优秀的国产动画, 虽然出生迥异, 但某种程度上说也算殊途同归. 说到国产动画, 又是一个大而专的话题, 阅历有限只能谈谈个人的所见所想. 两部作品都是在2011年差不多的时间上线. 星游记的制作并不缺钱, 由北京卡酷, 优扬传媒出资, 电动画负责制作, 电动画创始人刘北(爱的战士)任导演与编剧, 动画在电视台播出. 原计划制作两季52集, 但电动画这边由于种种原因制作完26集第一季后停止了项目. 沉寂6年后, 全擎娱乐公司从卡酷优扬手里买下星游记版权(电动画只负责制作没有版权, 故没有话语权), 重新设立工作室重启了星游记项目, 但是以制作网络电影的形式放送. 而罗小黑的制作是坎坷的, 与当时的大多数缺钱的动画工作室一样, 一开始的定位就是5分钟长的网络动画, 即便如此, 更新的周期仍然很长而且不固定, 但是一直没有停止创作, 人气也不断积累. 然后在今年暑假, 罗小黑的电影也宣布上映了. 以上是我了解到的大概情况, 可能我了解得并不全面. 至于电动画为什么单方面停止了制作, 当时有个对刘北的采访说得很清楚(<a href="http://www.woko.cc/thread-21098-1-1.html">采访</a>), 简而言之就是说国内市场不成熟, 在探索回收方式上存在困难, 也就是没有商业市场. </p><p>.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/xyj2.jpg" style="zoom:60%" class alt="星游记" /></p><p>.</p><p>单从结果上说, 虽然星游记以这种方式重启了, 但我个人觉得电影各方面没有达到tv版应有的高度, 特别是制作组为了体现主角们的成长而更换画风, 事实上我觉得原作画风非常有特点已经非常令人满意了, 为了体现成长还是应该在剧情台词上下功夫. 另外在人设上也进行了改动, 也许是新制作组想脱离原作表现自己的想法吧, 因此从一开始就不是什么经典延续, 而是类似同人的二次创作. 我也非常理解这一点, 毕竟换了制作组, 也许制作上也还不够成熟. 其实很多粉丝期待的只是在原作的基础上给麦当的故事画上一个还算圆满的句号, 目前能期待做到这一点的还是刘北, 虽然刘北本人还没有放弃, 但希望是渺茫的. 罗小黑这边我比较乐观, 看pv还是原来的味道, 而且对于罗小黑这样单靠可爱卖萌就能吸粉的动画制作却也相当精良还是很难得. 我总感觉罗小黑战记所背负的压力和包袱(粉丝的期待)没有像星游记那么重, 这跟动画的定位也有关系.</p><p>.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/xyj1.jpg" style="zoom:40%" class alt="星游记" /></p><p>.</p><p>再回来聊聊星游记本身. 最近一些媒体对于作品的评价越来越谨慎, 如机核对游戏评论的<a href="https://www.gcores.com/radios/110358">讨论</a>很有意思. 媒体对作品的评论或许负有责任, 但个人评论则不需要考虑对他人的影响这一因素, 是非常主观的个人感受. 总体上, 我对星游记是喜欢的 , 那时我甚至惊讶于国产动画可以做得这么”精致”, 不是单元剧而是长篇, 不是什么生硬的3D建模, 不是只有几分钟的网络动画(当时这种形式很流行), 依然保持着较高的制作水准, 画风, 故事与人设都不错, 全剧从头到尾一直带给我惊喜. 硬要说不足的话大概有两点, 一是配乐相比之下有点逊色, 只有op与ed还算让人印象深刻, 二是放到现在来看清晰度不高, 作画略显简陋. 除此之外用今天的眼光来看依然丝毫不逊色, 当时我甚至觉得放在日本动画中也是远超及格线的存在(从讲故事的角度). 究其原因依然绕不过海贼王, 星游记的故事中同样有着海贼王中让人感动的那些要素, 梦想, 信念, 勇气与爱等等, 但最重要的是星游记做出了自己独特的味道, 这些故事很好地塑造了个性鲜明的角色. 而且我个人也觉得星游记达到了能对人产生影响的高度, 在网络上看到有因为星游记而看到国产希望毅然投入到动画产业中去的人(然而现实是残酷的), 对于他们来说, 星游记或许有更加特别的意义. </p><p>我一直想写一写那些影响过我的事物, 那些我经历中相见恨晚的作品, 属于我独一无二感受的作品, 没想到是用星游记开了头, 最后还是用我当时看时最喜欢的一幕最为结束吧…</p><blockquote><p>不管怎么为别人努力, 不变强的话, 不能打倒别人的话, 最后就只能被打倒跪在地上. 我们没必要为这种世界牺牲, 对吧? 因为我而跪下去的你, 我会替你站起来, 绝对不会让任何人再嘲笑你的名字. 记住了, 我的名字, 就! 是! 米! 龙!!!</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=28267531&auto=0&height=66"></iframe><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>終わり</p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
          <category> 动画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anli </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《自新世界》</title>
      <link href="/zixinshijie/"/>
      <url>/zixinshijie/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/shinsekaiyori.jpg"  class alt="自新世界" /></p><p>由于每天坐公交来去实验室差不多要两小时, 所以在路上补完了<a href="https://book.douban.com/subject/1922216/">《全球通史》</a>, <a href="https://book.douban.com/subject/3646172/">《恶意》</a>, 前几周又补完了贵志祐介的<a href="https://book.douban.com/subject/25752955/">《自新世界》</a>, 实际上只花了不到一周的时间就看完了, 小说后半段情节非常紧凑, 高潮迭起, 几乎是一口气读完的, 真是久违了, 这种故事情节所展现出来的压迫感, 总觉得在早些时候也经历过, 一回想, 卧槽, 不就是<a href="https://book.douban.com/subject/26690465/">《恶之教典》</a>吗, 同样是贵志祐介的作品, 同样剧情让人窒息, 不过我看的不是原著, 而是漫画. 虽然已经过去了几个礼拜, 细节什么的也已经记不清了, 不过非常值得聊一聊观感的.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=399367460&auto=0&height=66"></iframe><p>说起来, 这并不是我第一次接触《自新世界》, 没错, 第一次是其改编的<a href="https://movie.douban.com/subject/10527275/">动画</a>, 记得是12年的十月番. 遗憾的是因为种种原因没有追完, 当时给我的印象是画风, 世界观很独特, 恐怖和悬疑的氛围营造得很好, 隐约感觉后面会有神展开.</p><p>说回小说, 小说的设定真的很有意思, 大致是说人类社会由于爆发战争文明随之衰落, 回到了村落聚居的社会模式, 人类在那时开发了一种被称之为”咒力”的潜能, 其实简单理解就是超能力, 基本上可以凭借想象力做任何事, 理论上没有极限, 但实现的效果是根据想象到的细节多少决定的. 由于这种能力过于强大, 为了限制这种能力的滥用而建立了一套特殊的社会制度, 比如其中有教育委员会会严格监视孩子们的精神状况, 咒力的开发情况等, 另外还有利用心理暗示等手段实现的同类相残时触发的”愧死机制”. </p><p>此外贵志祐介还精心设计了好几种变异的生物, 其中有智力与人类相仿的化鼠, 益兽蓑白与传说中遇到就会被诅咒的拟蓑白(其实是傲娇萝卜子什么的我才不会乱说呢), 巨大的螃蟹什么的. 这其中与人关系最紧密的是化鼠, 由于人类有强大的咒力, 总体上化鼠作为人类奴隶差不多的存在, 化鼠把人类尊为神明, 在人类面前卑躬屈膝, 而人类也会命令化鼠做一些脏活. 化鼠的社会体系也是分不同族群, 人类为了便于区分管理, 会给予归顺的化鼠族群各种名号, 不同族群也有着不同的社会制度, 有化鼠女王统治的君主制, 以及废除女王设立议事机构的共和制. 这些细节的设定非常用心和巧妙.</p><p>主角是五人团(早季, 觉, 瞬, 真理亚, 守), 叙事视角是其中的早季, 采用倒叙. 故事主要讲述了他们成长经历, 冒险, 以及揭示这个社会和世界的真相. </p><p>介绍完毕下面随便吐槽一下吧, 以下内容依然包含剧透. . . </p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>自新世界的故事主要分为两个部分, 前一部分是主角一行年少时在学校以及毕业修行的所见所闻, 看完后面部分就会发现前面其实有好多伏笔, 其中最吸引人的疑问就是这个世界的真相以及化鼠的来源. 这一部分主要还是在完善小说的世界观(社会制度, 自然环境, 以及化鼠), 同时展现早季一行人的出格与特殊, 然后发生了人类社会弱点之一的”业魔”事件(可怜的瞬从此只能活在早季思念里了). 我个人也是很喜欢”业魔”设定, “咒力”是靠意识驱动的, 但是潜意识活动会在人不知觉的情况下使用”咒力”, 而所谓”业魔”就是在本人无知觉的情况下”咒力”大量外泄, 外泄的”咒力”会改变周围物体的构成从而引起变异或者破坏(增强版核泄漏). 瞬最后舍身救早季那段也很精彩, 可惜小说中并没有说清楚原因(能力太超出常人?遗传病?).</p><p>第二部分是小说的高潮, 果不其然, 化鼠背叛了他们的”神明”人类, 对人类展开了屠杀. 首先单看这个事件, 我的感受也像早季在最后的感受一样, 内心无比复杂. 化鼠作为人类的奴隶(或许连奴隶都算不上), 整个种族命运被人类随意玩弄于股掌(虽然也称不上人类暴政), 只能隐忍苟活. 然后一只叫斯奎拉的化鼠登上化鼠的历史舞台, 作为一个革命者改造了化鼠的社会制度, 提高化鼠科技水平(拟蓑白), 最后为了化鼠种族未来的自由向人类发出挑战. 斯奎拉很聪明, 不仅巧言善辩, 而且知道人类社会的弱点, 精心准备了一个屠杀计划, 并且计划惊人地顺利, 要不是早季与奇狼丸联手解决了人类天敌”恶鬼”, 斯奎拉将人类驱逐殆尽地梦想就实现了.</p><p>从某种意义上说斯奎拉也是小说角色塑造最成功的一个, 他有自己坚持的信念, 为了自己的种族愿意献出一切(敌对鼠窝的奇狼丸也同样), 尽管手段有些不光彩甚至残忍, 但不可否认他确实是最接近实现化鼠梦想的一个. 在本作的暗线中提到, 化鼠其实就是被有”咒力”的人类种群所改造的人类, 以便一劳永逸地解决两个人类种群之间的矛盾. 当斯奎拉最后在人类法庭上喊出”我们是人类!”, 怎么也没办法对这个角色产生恨意. 也许是出于敬意, 早季最后违反规定偷偷让斯奎拉安然死去.</p><p>话说必须要吐槽下小说里的人类战斗力也太弱了吧, 和化鼠开战后单方面被虐, 虽然你可以说斯奎拉的计划有多周密, 变种化鼠(奇行种)有多出奇不意, 但其实真正能对人类有威胁的就只有化鼠拉拢的”恶鬼”吧. 由于”恶鬼”以为自己是化鼠, 所以其”愧死机制”同类对象是化鼠, 这使得”恶鬼”能肆意使用咒力虐杀人类, 而其他人则由于”愧死机制”拿”恶鬼”没办法. 但是, “恶鬼”也只是一个孩子呀, 愧死机制虽然对咒力使用者造成痛苦但不至于完全不能用啊, 当传说认真起来可以把地球分成两半的镝木肆星先生(没错, 镝木大人的定语就是辣么长)前面刚用实力安慰众人不用担心, 下一秒就被”恶鬼”轻松虐杀, 反正我是接受不能. 但是最后早季反过来利用”愧死机制”制服”恶鬼”确实也很精彩(真理亚与守的孩子真是个悲剧, 小说中也没有道出她的过去). 失去”恶鬼”的化鼠又一下子被人类扭转了局势.</p><p>另外本文开头的曲子是我看自新世界时的BGM, 迷幻的曲风与小说世界观真实与虚幻并存非常应景, 另外女声也有一种经历了种种悲欢离合略显寂寞的感觉与早季的经历也很契合, 当然最关键的是歌词我很喜欢, 摘出来作为一个结束吧.</p><blockquote><p>明日で終わりかもしれないね. </p><p>今日はまだ 子どものままでいよう. </p><p>何もない僕らが 笑うことを</p><p>許すならば</p><p>あなたとゆめをみたい</p><p>明日は来ないかもしれないね. </p><p>何に笑い 何を歌える？</p><p>明日もまた、</p><p>あなたと笑っていた</p></blockquote><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p><p>終わり</p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
          <category> 小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SIFT特征提取算法理解与实现</title>
      <link href="/sift/"/>
      <url>/sift/</url>
      
        <content type="html"><![CDATA[<p>我又回来了, 总算熬到放假了. . . 按照国际惯例先凑字数扯点近况.</p><span id="more"></span><p>没想到我托更的原因竟然不是懒, 而是事多. 最近几个礼拜真是累的够呛, 没想到研一课还挺多, 还都得做报告, 台下强制提问, 这感觉就有点过分了. 所以大家基本一份报告”吃遍天下”. 我还有几个报告在年后(1年3学期制), 所以有预感这个寒假也. . . </p><p>但总算是获得了一个喘息的机会, 然后平时娱乐也就打打麻将什么的, 也算正式入日麻坑了. 日麻这个事最开始的认识也是拜<a href="http://www.kylen314.com/">Vespa菊苣</a>所赐, 后来看<a href="https://book.douban.com/subject/3127875/">《赌博堕天录》</a>中社长和开司玩的麻将游戏—地雷游戏, 为了看懂了解了下日麻规则. 毕业闲下来的时候随便打打日麻, 只在天极牌和雀姬上玩过一段时间. 到了这学期, 需要频繁地在延长与宝山来回跑, 在路上就靠打牌打发时间了. 话说最近雀魂又莫名开始火起来了, 台游雀姬联合B站看准时机看来也要插一脚. 不过雀魂做得确实不错, 页游的形式很灵活方便.</p><p>另一个由于之前关注的几个漫画出了动画, 特别是《约定的梦幻岛》(在上一期漫画推荐中也有提到), 所以冲了个大会员来看, 顺便bilibili漫画与网易版权合作, 也能继续看漫画版了. 看来作者也要开始收笔完结了, 最近一话诺曼出场了/(ㄒoㄒ)/~~</p><p>另外之前七牛云终究还是崩了, 网站图片全挂(<a href="http://busuanzi.ibruce.info/">不蒜子</a>也被阴了一把), 于是干脆把图片也挂到Github上了, 虽然速度堪忧, 先勉强用用. 然后本站音乐外链也全换成了网易云, 虾米的外链太慢, 官方似乎也有意阉割外链功能.</p><hr><p>说回正题, 这个学期一直忙着上课(听报告╮(╯-╰)╭)和项目, 其实留给自己折腾的时间很少. 其中有一门CVPR的课, 一个课程项目是图像特征提取, 所以就去了解了下<a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform">SIFT</a>. 其作者Lowe的论文对于算法具体实现叙述很少, 虽然CSDN上相关文章一大堆, 但真正搞懂且说明白的人也不多. 我在理解与实现中帮助比较大的是这两位博主<a href="http://aandds.com/blog/img-feature-detector.html#org9cc6832">cig01</a>和<a href="https://blog.csdn.net/zhaocj">zhaocj</a>, 博主zhaocj写了一篇33页的文章, 详尽讲解了SIFT原理与openCV的SIFT实现, 我在最后才看到这篇文章, 此前自己已经理解过openCV的源码, 但那篇文章还是在一些细节上给了我启发, 鉴于资源网上不太好找, 就分享个<a href="https://pan.baidu.com/s/1LytpQ81cp6nsv9zAuNiSXA">网盘</a>(m981)吧, 另外这是我做的<a href="https://pan.baidu.com/s/10b1o5Y_1H9tDyVKB4oxOsA">ppt</a>.</p><p>按理说已经有很多人写过SIFT, 就没我等渣渣什么事了, 但我确实在这上花了比较多的时间, 理解原理, 然后用Matlab与C++实现了SIFT, 过程中碰到的问题及处理细节还是印象深刻的. 所以这篇博文我主要还是会重点讨论其他博主所忽视的实现上的细节问题, 算作一个补充. 目测可能会比较长. . . </p><hr><h1 id="SIFT的理解"><a href="#SIFT的理解" class="headerlink" title="SIFT的理解"></a>SIFT的理解</h1><h2 id="关于SIFT"><a href="#关于SIFT" class="headerlink" title="关于SIFT"></a>关于SIFT</h2><p>SIFT即Scale Invariant Feature Transform, 由英国哥伦比亚大学计算机系教授Lowe在1999年首次提出, 并在04年完善后发表了成果<a href="http://www.cs.ubc.ca/~lowe/papers/ijcv04.pdf">《Distinctive Image Features from Scale-Invariant Keypoints》</a>. </p><p>SIFT简单来说就是一种稳定、高效的图像关键点检测与描述子生成方法, 如同其名字中所描述的, SIFT特征具有对旋转、尺度缩放、光照变化的不变性, 同时对3D视角变化、仿射变换、加性噪声也保持一定程度的稳定性. 在SIFT之前的一些方法(各种角点检测(Corner detection)方法, 如Moravec角点检测, Harris角点检测等)是不具有尺度不变旋转不变的. 在SIFT之后的06年, Bay等在SIFT基础上改进, 提升其检测效率, 提出了SURF(Speeded Up Robust Features, 加速鲁棒性特征)算法. 09年G.Yu和 J.M. Morel在SIFT基础上提出<a href="http://www.cmap.polytechnique.fr/~yu/research/ASIFT/demo.html#SIFT%20and%20ASIFT%20---%20online%20demo%20:%20try%20if%20your%20images%20match!">Affine-SIFT (ASIFT)</a>以此改善SIFT特征的仿射不变性能. 应该来说, SIFT作为一种经典的关键点检测算法, 在计算机视觉领域动不动就是深度学习模型的当下仍然有着存在感, 或许SIFT本身所包含的尺度不变的思想仍有借鉴意义. 之前看到有基于深度学习的关键点检测方法LIFT出来, 从实验结果来看SIFT的性能依然不错.</p><p>另外Lowe为SIFT申请了专利, 在07年的时候提出了基于SIFT的图像拼接方法AutoStitch(Automatic Panoramic Image Stitching using Invariant Features), 这又是图像拼接领域的里程碑式的方法.</p><p>具体到SIFT主要的两部分即关键点检测与关键点描述. </p><h2 id="关键点检测"><a href="#关键点检测" class="headerlink" title="关键点检测"></a>关键点检测</h2><p>这一部分的目的就是检测关键点. 在SIFT中关键点来源于DoG图像的极值点, 然后经过筛选过程去除不稳定的极值点后剩下的就作为关键点了.</p><h3 id="建立图像金字塔"><a href="#建立图像金字塔" class="headerlink" title="建立图像金字塔"></a>建立图像金字塔</h3><p>图像金字塔是图像多分辨率分析或者说不同尺度空间分析的工具, 在SIFT中使用了图像金子塔, 这是其尺度不变性的一个重要来源. SIFT与其他关键点检测算法的不同之处就在于引入了尺度空间(Scale space), 在图像的行列坐标外, 还多了一个尺度空间的坐标$\sigma​$, 这个坐标来源于对图像做了方差为$\sigma​$的高斯滤波或$\sigma​$的图像尺度缩放.</p><p>为实现多尺度, 在SIFT中需要构建两个金字塔, <strong>高斯模糊金字塔与DoG金字塔</strong>. 这里是先构成高斯模糊金字塔, 在以此构建DoG金子塔的关系, 我们需要的极值就是在DoG金子塔中寻找.</p><p>那怎么构建高斯模糊金子塔呢? 为与论文叙述统一, 将金子塔的每一层称为octave, 而一层中的一张张图像称作layer, 构建金字塔的具体做法是对<strong>初始图像</strong>做不同尺度$\sigma$的高斯模糊生成第一个octave(底层), 下一个octave的第一张图像由上一个octave最后一张图像降采样产生(长宽减半, 具体方法的话在openCV源码中使用了最近邻), 接着对<strong>这第一张图像</strong>同样做不同尺度高斯模糊产生当前octave其余图像, 而下一octave重复进行以上操作. 至于DoG金子塔建立则更简单了, 其每个octave的图像即对高斯模糊金字塔对应octave内图像相邻图像两两做差得到(注意图像做差操作会使像素值变负, 在实现时转换为合适类型). 这样我们知道如果DoG金子塔一octave内有$s$张图像, 则高斯模糊金字塔octave有$s+1$张.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/sift_dog.png" style="zoom:40%" class alt="构建高斯模糊金子塔与DoG金子塔" /></p><p>接下来我们就面临几个具体问题, 比如金子塔octave取多少? 金子塔octave内图像数$s$又取多少? 高斯模糊金字塔第一个octave的第一个图像的尺度空间坐标$\sigma_0$取多少呢?</p><p>对于octave可以取比较好的实验值, 事实上实验结果来看, 极值点主要出现在前几个octave中, 过大的octave没有意义. 在具体的实现中, 我有看到是用下面公式计算得到的</p><script type="math/tex; mode=display">Octave = log_2(min(w_0, h_0)) - log_2(min(w, h))+1</script><p>$w_0​$与$h_0​$为原图像宽高, $w​$与$h​$为塔顶图像宽高. 如对于一幅大小为16×16的图像, 当塔顶图像设定为4×4时, 金字塔层数octave = 3. 可以对其验证, 如前所述, 每一个octave的图像尺寸是前一个octave图像尺寸的一半, 于是16-&gt;8-&gt;4, 可见确实是三层的图像金字塔.</p><p>至于$s$的取值同样是实验值, Lowe的实验结果说明取3为优. 如前所述, $s$为DoG金子塔octave内的图像数目, 我们假设一octave图像在尺度空间上由$\sigma$均匀变化到$2\sigma$, 这样相邻两张图像尺度比值为一定值$k$</p><script type="math/tex; mode=display">k=2^{\frac{1}{s}}</script><p>如此一来, 实现了<strong>DoG图像在尺度空间坐标的连续性</strong>, 即当前octave最后一张DoG图像与下一个octave的第一张DoG图像的尺度比值也是$k$.</p><p>至于$\sigma_0$同样也是实验值, 在Lowe的实验中取1.6为优. 当$\sigma_0$与$k$都确定后, 金字塔中的每一张图像在尺度空间的坐标就都确定了.</p><p>另外为了获取更多的极值点, 通常会先对原图像做插值(论文中为双线性插值), 将图像的尺寸扩大一倍再作为初始图像进行后续处理.</p><h4 id="番外-关于LoG与DoG"><a href="#番外-关于LoG与DoG" class="headerlink" title="番外 关于LoG与DoG"></a>番外 关于LoG与DoG</h4><p>这一部分简单聊聊DoG. 在SIFT中关键点检出使用的是DoG(Difference of Gaussian), DoG被证明是LoG(Laplacian of Gaussian)的良好近似. 这部分在《数字图像处理 第三版》P.459关于图像边缘检测算子中有涉及到.</p><p>LoG是Marr和Hildreth在1980年提出的边缘检测算子, 其本质上是二阶导数的近似(边缘检测算子可用二阶导数), 另一方面LoG算子可以自由调整大小, 在任何图像尺度上都能取得比较好的检测效果. LoG形式上可对二维高斯函数的二阶导数进行采样得到. </p><script type="math/tex; mode=display">L(x,y,\sigma) = G(x,y,\sigma)\ast I(x,y)</script><script type="math/tex; mode=display">G(x,y, \sigma) = \frac{1}{2\pi\sigma^2}\exp\left(-\frac{(x^2+y^2)}{2\sigma^2}\right)</script><p>但LoG的缺点是为了求得零交叉点(Laplace算子通过对图像求取二阶导数的零交叉点(zero-cross)来进行边缘检测)需要经过比较麻烦的像素比较操作. 于是Marr和Hildreth在当时提出用DoG(高斯差分)近似LoG的运算. DoG函数定义如下</p><script type="math/tex; mode=display">D(x,y,\sigma) = L(x,y,k\sigma) - L(x,y,\sigma)</script><p>故在构建DoG金子塔时是对不同尺度高斯模糊后的图像做差来产生DoG图像.</p><h4 id="番外-高斯函数卷积性质"><a href="#番外-高斯函数卷积性质" class="headerlink" title="番外 高斯函数卷积性质"></a>番外 高斯函数卷积性质</h4><p>在构建高斯模糊金子塔时有一个细节, 比如一octave假设各图像尺度空间坐标为$\sigma_0, k\sigma_0$, 这意味着此octave中的图像是对<strong>初始图像</strong>分别做方差为$\sigma_0,k\sigma_0$的高斯模糊得到的, 在这种情况下, 我们是视初始图像的空间尺度坐标为0, 但尺度空间的建立不能从尺度为0开始(尺度坐标是成比例增长, 起始不能为0, 另一种解释是在尺度空间理论中视尺度坐标为0时图像是无限精细不可获得), 故在Lowe的论文中假设我们获得的初始图像是已经经过了方差为0.5的高斯模糊处理.</p><p>那么此时我们的问题变成如何从尺度为$\sigma_0$的图像得到尺度为$\sigma_1$与尺度为$\sigma_2$的图像, 用式子来描述就是</p><script type="math/tex; mode=display">I(x,y,\sigma_0)=I(x,y)*G(x,y,\sigma_0) \\I(x,y,k\sigma_0)=I(x,y)*G(x,y,k\sigma_0)</script><p>利用高斯函数的卷积性质</p><script type="math/tex; mode=display">G(x,y,k\sigma_0)=G(x,y,\sigma_0)*G(x,y,\sqrt{(k\sigma)^2-\sigma^2})</script><p>我们有</p><script type="math/tex; mode=display">I(x,y,k\sigma_0)=I(x,y,\sigma_0)*G(x,y,\sqrt{(k\sigma_0)^2-\sigma_0^2})</script><p>顺便一说, 这个性质可以使用傅里叶的卷积性质来证, 具体可参考<a href="http://www.tina-vision.net/docs/memos/2003-003.pdf">《Products and Convolutions of Gaussian Probability Density Functions》</a>, 证明过程也比较简洁这里就不重复写了.</p><h3 id="寻找局部极值点"><a href="#寻找局部极值点" class="headerlink" title="寻找局部极值点"></a>寻找局部极值点</h3><p>构造完DoG金字塔后, 就可以寻找极值点了. 具体来说, 把同一octave经过不同尺度高斯滤波后的图像按尺度大小堆成一叠(如下图), 若当前像素值(×)比邻近的26个位置(包括相邻上下两张图像)都大, 则作为一个局部极大值, 同样可以找到局部最小值.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/sift_detection_maximum.png" style="zoom:40%" class alt="极值点检测" /></p><p>这里比较求局部极值点引出了另一个细节问题, 即一个octave中的第一张图像与最后一张图像中的像素无法进行3×3的比较得到极值, 如果是按之前说的高斯模糊金字塔每octave生成$(s+1)$张图像, 做差值后将生成$s$张DoG图像, 那么极值的寻找实际只在$(s-2)$个尺度上进行.</p><p>为了在每层中检测$s$个尺度的极值点, 简单粗暴的做法是再补上两张高斯模糊后的图像, 也就是高斯模糊金字塔一个octave生成$(s+3)$张图像, 然后在$s+1$张DoG图像的第2张到倒数第2张之间的图像像素中去寻找极值点. 如下图</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/add2.png" style="zoom:40%" class alt="增加模糊图像" /></p><p>同时为了保证之前DoG图像尺度坐标变化的连续性, 在降采样建立高斯模糊金字塔时, 每一个octave的第一张图像由前一个octave的<strong>倒数第三张</strong>图像降采样得到(原来是使用最后一张).</p><h4 id="番外-寻找极值点的实现细节"><a href="#番外-寻找极值点的实现细节" class="headerlink" title="番外 寻找极值点的实现细节"></a>番外 寻找极值点的实现细节</h4><p>在openCV的源码中, 判断极值点的第一步是看其是否高于一个阈值, 像素点过小的点会直接忽略. 在进行像素值比较时使用的是大于等于与小于等于, 这样能够检测到更多的极值点.</p><h3 id="局部极值点筛选"><a href="#局部极值点筛选" class="headerlink" title="局部极值点筛选"></a>局部极值点筛选</h3><p>这一步的主要目的是对之前得到的极值点进行测试, 看其是否足够稳定. 主要进行如下两步, 极值点精确定位与消除边缘效应.</p><h4 id="极值点精确定位"><a href="#极值点精确定位" class="headerlink" title="极值点精确定位"></a>极值点精确定位</h4><p>由于之前所找的极值是在离散空间中进行的, 所以找到的极值未必与真实极值位置相同. 论文提出可以通过对尺度空间DoG函数进行曲线拟合寻找极值点来减小这种误差. 利用已知的离散空间点插值得到的连续空间极值点的方法叫做子像素插值(Sub-pixel Interpolation).</p><p>这里有一个一元函数的例子说明求精确极值原理, 参考<a href="https://www.cnblogs.com/pakfahome/p/3598983.html">博文</a>.</p><p>方法中用到了泰勒(Taylor)展开, 一元函数形式在$x_{0}$的泰勒展开公式如下</p><script type="math/tex; mode=display">f(x) \approx f(x_0)+(x-x_0)f'(x_0)+\frac{1}{2!}(x-x_0)^2f''(x_0)</script><p>而对于二元函数, $f(x, y)$在$(x_{0}, y_{0})$处泰勒展开式为</p><script type="math/tex; mode=display">f(x,y)\approx f(x_0,y_0)+[(x-x_0)f'_x(x_0,y_0)+(y-y_0)f'_y(x_0,y_0)] \\+\frac1{2!}\left[(x-x_0)^2f''_{xx}(x_0,y_0)+(x-x_0)(y-y_0)f''_{xy}(x_0,y_0) \\+(x-x_0)(y-y_0)f''_{yx}(x_0,y_0)+(y-y_0)^2f''_{yy}(x_0,y_0)\right]\\</script><p>上式可写成向量形式, 注意$dx=x-x_0$, $dy=y-y_0$</p><script type="math/tex; mode=display">f(x, y)\approx f(x_0, y_0)+[dx\ \ dy]\left[ f_x(x_0,y_0) \atop f_y(x_0,y_0)\right] \\+\frac{1}{2!}[dx\ \ dy]\left[ f_{xx}(x_0,y_0)\ \ f_{xy}(x_0,y_0) \atop f_{yx}(x_0,y_0)\ \  f_{yy}(x_0,y_0)\right]\left[ dx \atop dy\right]</script><p>若令$\boldsymbol{x}=\left[x \atop y\right]$, 且$\boldsymbol{x}_0=\left[x_0 \atop y_0\right]=\boldsymbol{0}$, 有</p><script type="math/tex; mode=display">f(\boldsymbol{x})\approx f(\boldsymbol{x}_0)+\left.\frac{\partial f^{T}}{\partial\boldsymbol{x}}\right|_{\boldsymbol{x}=\boldsymbol{x}_0}\boldsymbol{x}+\frac{1}{2!}\boldsymbol{x}^{T}\left.\frac{\partial^{2} f}{\partial\boldsymbol{x}^2}\right|_{\boldsymbol{x}=\boldsymbol{x}_0}\boldsymbol{x}</script><p>同样这里是对$D(x,y,\sigma)$进行泰勒展开, 如果写成向量形式则$\boldsymbol{x}$是三维列向量, 同样这里$\boldsymbol{x}_0=\boldsymbol{0}$</p><script type="math/tex; mode=display">D(\boldsymbol{x})\approx D(\boldsymbol{x}_0)+\left.\frac{\partial D^{T}}{\partial\boldsymbol{x}}\right|_{\boldsymbol{x}=\boldsymbol{x}_0}\boldsymbol{x}+\frac{1}{2!}\boldsymbol{x}^{T}\left.\frac{\partial^{2} D}{\partial\boldsymbol{x}^2}\right|_{\boldsymbol{x}=\boldsymbol{x}_0}\boldsymbol{x}</script><script type="math/tex; mode=display">\frac {\partial D}{\partial \boldsymbol{x}} = \begin{bmatrix} \frac {\partial D}{\partial x} \\ \frac {\partial D}{\partial y} \\ \frac {\partial D}{\partial \sigma}\end{bmatrix} =\begin{bmatrix} \frac {D(x+1,y,\sigma) - D(x-1,y,\sigma)}{2} \\ \frac {D(x,y+1,\sigma)-D(x,y-1,\sigma)}{2} \\ \frac {D(x,y,\sigma+1) - D(x,y,\sigma-1)}{2} \end{bmatrix}</script><script type="math/tex; mode=display">\frac{\partial^2 D}{\partial \boldsymbol{x}^2} = \begin{bmatrix} D_{xx} & D_{xy} & D_{x\sigma} \\D_{yx} & D_{yy} & D_{y\sigma} \\D_{\sigma x} & D_{\sigma y} & D_{\sigma\sigma} \end{bmatrix}</script><p>其中</p><script type="math/tex; mode=display">D_{xx}=\frac { \frac{D(x+1,y,s)-D(x,y,s)}{1} - \frac{D(x,y,s)-D(x-1,y,s)}{1} }{1}</script><script type="math/tex; mode=display">D_{xy} = \frac { \frac{D(x+1,y+1,s)-D(x-1,y+1,s)}{2} - \frac{D(x+1,y-1,s)-D(x-1,y-1,s)}{2} }{2}</script><p>为求极值, 两边对$\boldsymbol{x}$求导, 并令其为0, 这部分需要用到<strong>数量函数对向量变量求导</strong>的知识(可参考博文<a href="https://www.cnblogs.com/hellcat/p/7216399.html">矩阵求导</a>与<a href="https://en.wikipedia.org/wiki/Matrix_calculus">Matrix calculus</a>)</p><script type="math/tex; mode=display">\begin{align}\frac{\partial D}{\partial\boldsymbol{x}}&=\left.\frac{\partial D^T}{\partial\boldsymbol{x}}\right|_{\boldsymbol{x}=\boldsymbol{x}_0}+\frac{1}{2}\left(\left.\frac{\partial^2 D}{\partial\boldsymbol{x}^2}\right|_{\boldsymbol{x}=\boldsymbol{x}_0}+\left.\frac{\partial^2 D^T}{\partial\boldsymbol{x}^2}\right|_{\boldsymbol{x}=\boldsymbol{x}_0}\right)\boldsymbol{x} \\&=\left.\frac{\partial D^T}{\partial\boldsymbol{x}}\right|_{\boldsymbol{x}=\boldsymbol{x}_0}+\left.\frac{\partial^2 D}{\partial\boldsymbol{x}^2}\right|_{\boldsymbol{x}=\boldsymbol{x}_0}\boldsymbol{x}\\&=\boldsymbol{0}\end{align}</script><p>可解出精确极值点$\boldsymbol{x}$</p><script type="math/tex; mode=display">\hat{\boldsymbol{x}}=-\left.\frac{\partial^2 D^{-1}}{\partial\boldsymbol{x}^2}\frac{\partial D}{\partial\boldsymbol{x}}\right|_{\boldsymbol{x}=\boldsymbol{x}_0}</script><p>于是可求出精确极值$D(\hat{\boldsymbol{x}})$. </p><script type="math/tex; mode=display">D(\hat{\boldsymbol{x}})\approx D(\boldsymbol{x}_0)+\frac{1}{2}\left.\frac{\partial D^{T}}{\partial\boldsymbol{x}}\right|_{\boldsymbol{x}=\boldsymbol{x}_0}\hat{\boldsymbol{x}}</script><p>这里再说明一下, 事实上这里的$\boldsymbol{x}$准确说应该是极值点$\boldsymbol{x}$与$\boldsymbol{x}_0$的差值, 即极值点的偏移量$\boldsymbol{x}-\boldsymbol{x}_0$, 但由于这里假设了$\boldsymbol{x}_0=\boldsymbol{0}​$所以才得到上述结果. </p><p>接下来就是根据计算出的精确极值筛选之前找到的极值点了, 主要基于两点: 一是之前找到的极值点偏离精确极值点的程度, 二是找到精确极值点极值的幅度大小.</p><p>对于第一点, 只要精确极值点在任意方向$(x, y,\sigma)$偏离找到的极值点某个阈值则剔除该极值点, 通常这个阈值在论文中取0.5; 对于第二点, 只要$|D(\hat{\boldsymbol{x}})|$小于某个阈值则剔除该极值点, 响应值过小易受噪声干扰, 视为不稳定点, 通常这个阈值在论文中取0.03(图像灰度归一化为[0,1]). 下面是经过这一步筛选前后的效果</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/check1.png" style="zoom:40%" class alt="精确定位筛选前后对比" /></p><h4 id="消除边缘效应"><a href="#消除边缘效应" class="headerlink" title="消除边缘效应"></a>消除边缘效应</h4><p>利用DoG得到的极值点还有另一个问题, 之前说LoG是对二阶导数的近似, 而DoG又是LoG的近似, DoG的处理会使得边缘像素点的响应很大(边缘效应), 接下来就是要尽可能地去除边缘关键点, 而保留下其他信息较大的点如角点. </p><p>为了找到和去除那些边缘响应过大的像素点, 需要利用那些像素点在DoG响应曲面(准确说是空间离散点集)上的特性. 比如曲面在该像素点处两主曲率(Principal curvature)的差值会很大(大的主曲率会很大, 小的主曲率会很小), 而对于角点的关键点两主曲率差值较小(大的主曲率与小的主曲率都会很大). </p><p>由于<strong>两主曲率与极值点处的Hessian矩阵特征值成比例</strong>(微分几何结论, 关于主曲率相关知识可参考<a href="http://www.cad.zju.edu.cn/home/vagwiki/index.php/Vag_guide_9">这个</a>), 同时我们将考察两主曲率的差值转化为考察比值, 这样可以利用矩阵特征值性质去求而避免了直接去求Hessian矩阵特征值. </p><p>Hessian矩阵定义: </p><script type="math/tex; mode=display">H(D(\boldsymbol{x}))\overset{def}{=}\frac{\partial^{2} D(\boldsymbol{x})}{\partial\boldsymbol{x}\partial\boldsymbol{x}^T}=\begin{bmatrix} D_{xx} & D_{xy} \\ D_{xy} & D_{yy} \end{bmatrix}</script><p>设Hessian矩阵的两特征值为$\alpha, \beta$, 且$\alpha&gt;\beta$, 令$\alpha=\gamma\beta$有</p><script type="math/tex; mode=display">\begin{aligned} \text{tr} (H) &= D_{xx} + D_{yy} = \alpha + \beta \\\det (H) &= D_{xx}D_{yy} - (D_{xy})^2 = \alpha \beta \end{aligned}</script><script type="math/tex; mode=display">\frac{\text{tr}(H)^2}{\det(H)} = \frac{(\alpha + \beta)^2}{\alpha \beta} = \frac{(\gamma \beta + \beta)^2 }{\gamma  \beta^2} = \frac{(\gamma+1)^2}{\gamma} = \gamma+\frac{1}{\gamma}+2</script><p>上式当两特征值相同时即$\gamma=1$时最小, 当两特征值差越大, 上式值也越大. 所以可以用$\gamma$再设置一个阈值, 间接地排除两主曲率相差悬殊的关键点(即边缘响应较大的关键点), $\gamma$这个阈值在Lowe论文中设置为了10.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/check2.png" style="zoom:40%" class alt="消除边缘效应前后对比" /></p><h4 id="番外-在极值点筛选过程实现上的细节"><a href="#番外-在极值点筛选过程实现上的细节" class="headerlink" title="番外 在极值点筛选过程实现上的细节"></a>番外 在极值点筛选过程实现上的细节</h4><p>这一步总得来说细节比较少, 首先需要注意的是一阶, 二阶, 二阶混合离散导数的计算, 特别注意这些导数的分母, 另外在进行阈值判断时需要注意是否需要将像素值归一到[0,1].</p><p>在openCV的实现源码中, 求精确极值时并不是偏移量超过阈值就之间去除, 而是会有5次调整机会, 即原坐标加上偏移后再按如上步骤计算偏移看是否这次满足阈值. 实现在一些阈值上也有些许改动.</p><h2 id="关键点描述"><a href="#关键点描述" class="headerlink" title="关键点描述"></a>关键点描述</h2><p>经过筛选考验的极值点就作为关键点保留下来了, 接着我们需要对每个关键点生成一个描述信息或称为描述子(Descriptor). SIFT作为一种局部特征, 即在计算描述子时需要用到关键点周围邻域的像素信息. 但在此之前需要给每个关键点分配一个主方向.</p><h3 id="关键点主方向"><a href="#关键点主方向" class="headerlink" title="关键点主方向"></a>关键点主方向</h3><p>给关键点分配主方向也是SIFT区别于其他特征的地方, 是SIFT特征拥有旋转不变性的原因之一. 关键点的主方向确定了在计算特征描述时使用的是关键点邻域内的哪些像素. 具体做法如下,</p><p>对于某一个关键点所在尺度$\sigma​$的高斯滤波后的图像可表达为</p><script type="math/tex; mode=display">L(x,y, \sigma) = G(x,y, \sigma) \ast I(x,y)</script><p>计算以关键点为中心, 以$3 \times \sqrt{2} \sigma​$(为了圆域包含内接正方形)为半径的区域(圆域)内的所有图像像素点的<strong>梯度幅角和幅值</strong>, 图像某点处梯度定义为</p><script type="math/tex; mode=display">grad\ L(x,y, \sigma)=\begin{bmatrix} \frac{\partial L}{\partial x}  \\ \frac{\partial L}{\partial y} \end{bmatrix}</script><p>梯度幅角与幅值计算公式如下</p><script type="math/tex; mode=display">\begin{aligned} m(x,y) & = \sqrt{(L(x+1,y) - L(x-1,y))^2 + (L(x, y+1) - L(x, y-1))^2} \\\theta(x,y) &= \arctan \left(\frac{L(x, y+1) - L(x, y-1)}{L(x+1,y) - L(x-1,y)} \right) \end{aligned}</script><p>完成关键点邻域内梯度幅角与幅值计算后, 将幅角的360°每10°为一个区间划分作为横轴, 共36个区间, 纵轴为在对应幅角区间内的像素点幅值累加, 可做出方向统计直方图.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/orientationhistogram1.png" style="zoom:40%" class alt="方向统计直方图" /></p><p>为改善特征仿射不变性的性能, 一般将累加的像素点幅值用高斯函数加权, 高斯加权函数的$\sigma​$取为关键点尺度的1.5倍. 经过高斯加权即让靠近关键点的像素幅值具有更大的权重(以此改善仿射不变性).</p><p>先对得到的直方图进行平滑(如加权滑动平均), 然后将直方图的峰值对应的幅角即作为该关键点的主方向(dominant orientation). 此时得到的主方向为一个10°区间的范围, 需要进行插值拟合(如抛物线拟合), 从离散值直方图得到较精确的关键点主方向.</p><p>如果像上图这样, 有另一个峰值超过最高峰值的80%, 那么这个方向应该作为一个参考的辅方向保留. <strong>在实际操作中, 就直接把关键点再复制一份(拥有与原关键点相同的尺度与位置), 新关键点的主方向取这个参考的辅方向.</strong> 一个关键点是可能有多个辅方向的.</p><h3 id="特征向量生成"><a href="#特征向量生成" class="headerlink" title="特征向量生成"></a>特征向量生成</h3><p>一个关键点点所包含的信息由特征描述子(Feature Descriptor)数值描述. 在SIFT中, 特征描述子是从关键点与其主方向确定的区域提取得到的一个128维特征向量. </p><p>为了确定最后提取特征向量需要的像素, 首先要确定提取特征向量的像素区域大小. 将以关键点为中心的邻域划分成 $4\times 4$个子区域, 每个子区域的尺寸为3σ(3$\sigma$原则)个像素, $\sigma$即关键点所在图像尺度空间坐标.</p><h4 id="确定特征提取像素区域"><a href="#确定特征提取像素区域" class="headerlink" title="确定特征提取像素区域"></a>确定特征提取像素区域</h4><p>确定了<strong>提取特征的像素区域</strong>(方域)大小后, 还要确定提取特征区域以关键点为中心的旋转角度. 为便于说明, 在提取特征向量的区域建立坐标轴, x轴正向朝右, y轴正向朝下, 而坐标原点位于关键点处. 在此坐标轴下, 比如计算特征向量像素区域(这是一个方域)的最左上角位置的坐标为$(x, y)$(<strong>注意这是以关键点为原点的相对坐标</strong>). 接着将计算特征向量像素区域顺时针旋转至该关键点的主方向(如图), 旋转后之前最左上角的像素坐标变为$(x’, y’)$. 这个过程可由坐标变换公式描述为</p><script type="math/tex; mode=display">\left[ \begin{matrix} x’\\ y’\end{matrix} \right] = \left[ \begin{matrix} cos\theta & -sin\theta \\ sin\theta & cos\theta \end{matrix} \right] \left[ \begin{matrix} x\\ y \end{matrix} \right]</script><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/rotateaxis.png" style="zoom:40%" class alt="旋转区域" /></p><p>用上式就可以通过遍历旋转前区域内像素坐标值, 经上式转化后, 即遍历的是区域旋转后的像素位置, 这样避免了直接去求旋转后区域内的像素坐标.</p><h4 id="计算特征向量"><a href="#计算特征向量" class="headerlink" title="计算特征向量"></a>计算特征向量</h4><p>特征向量的计算依旧需要用到统计梯度直方图. 具体来说, 统计$4\times4$个子区间内像素(16个像素)的梯度(幅值与幅角), 与之前相同, <strong>将幅角从360°每45°为一个区间划分</strong>作为横轴, 共8个区间, 纵轴为在对应幅角区间内的像素点幅值累加, 以此作出统计直方图. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/orientationhistogram2.png" style="zoom:40%" class alt="方向直方图" /></p><p>这样每个子区域都包含8个柱状图的信息, 所以对于一个关键点可提取$4\times 4\times8$共128维的特征向量.</p><p>这里有比较多的细节问题, 首先注意计算主方向时的邻域范围与计算特征向量时是不同的, 至于具体怎么取取决于实现. </p><p>另外一个比较难理解的地方是直方图的插值问题. 此处我们有三个坐标, 即除图像行列外还有一个梯度幅角的坐标, 故使用三线性插值来处理. 这意味当一个像素点落在某个子区域时, 我们其实并不是直接将该像素点的梯度幅值加到所属子区域的方向直方图中, 而是通过某种方式得到权值, 通过权值贡献到离该像素点幅值最近的4个子区域的直方图, 这里<strong>计算权值的方式就是利用了三线性插值的性质</strong>. 不仅是贡献到4个子区域有权值, 而且离像素梯度幅角最近的两个角度区间也需要计算权值. 直观上来说的话, 类似于我们得到了立方体内一点的值, 将其值贡献到其8个顶点上去.</p><h5 id="番外-关于三线性插值"><a href="#番外-关于三线性插值" class="headerlink" title="番外 关于三线性插值"></a>番外 关于三线性插值</h5><p>一般意义上的<a href="https://en.wikipedia.org/wiki/Trilinear_interpolation">三线性插值(Trilinear interpolation)</a>指的是已知空间8个点的值, 去得到以8个点为顶点的长方体内任意一点的值, 本质上是连续进行7次线性插值得到内点的值.</p><p>在这里, 更像是三线性插值的逆用(或者有更专业的说法?), 已知空间一点的值得到包含该点立方体8个顶点的值. 利用三线性插值的性质, 可以求出分配到各顶点的权值.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/trilinear.png" style="zoom:40%" class alt="三线性插值性质" /></p><p>如上图所示, 像素点作为内点, 其对邻近四子区域幅度权值为以内点到顶点连线为体对角线的长方体体积占8顶点构成长方体体积之比.</p><h4 id="特征向量的优化"><a href="#特征向量的优化" class="headerlink" title="特征向量的优化"></a>特征向量的优化</h4><p>为了改善特征受光照条件的影响, 需要对特征向量做优化. 对于线性光照改变, 由于SIFT使用的是DoG, 故特征对于对比度变化天生具有鲁棒性, 对于改善光照强度影响这里的处理是对特征向量进行归一化处理. 而对于非线性的光照改变, 只能通过抑制过大的特征向量的分量来改善, 使特征向量各分量差距不过于悬殊.</p><h1 id="SIFT的实现"><a href="#SIFT的实现" class="headerlink" title="SIFT的实现"></a>SIFT的实现</h1><p>我一开始是用Matlab初步实现了SIFT算法, 完成调试后又用C++进行重写, 尽可能地保留程序的易读性, 在部分具体实现中参考了openCV中对SIFT的优化改进方法, 包括阈值的设定, 一些特定变量的使用(如利用Mat进行矩阵运算). 但总得来说, 效率上依然不如openCV, 或许还有改进空间. 代码放在<a href="https://github.com/Granvallen/SIFT">GitHub</a>, 在openCV3.4环境下正常运行.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p>Lowe1999年论文<a href="http://www.cs.ubc.ca/~lowe/papers/iccv99.pdf">《Object Recognition from Local Scale-Invariant Features》</a></p></li><li><p>Lowe2004年完善SIFT后的论文<a href="http://www.cs.ubc.ca/~lowe/papers/ijcv04.pdf">《Distinctive Image Features from Scale-Invariant Keypoints》</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform">SIFT wiki</a></p></li><li><p><a href="https://chtseng.wordpress.com/2017/05/06/%E5%9C%96%E5%83%8F%E7%89%B9%E5%BE%B5%E6%AF%94%E5%B0%8D%E4%B8%80-%E5%8F%96%E5%BE%97%E5%BD%B1%E5%83%8F%E7%9A%84%E7%89%B9%E5%BE%B5%E9%BB%9E/">图像特征比对(一)-取得影像的关键点</a> 关键点检测一些概念的理解</p></li><li><a href="http://aandds.com/blog/img-feature-detector.html#org9cc6832">Local Invariant Feature Detectors</a><br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Matlab </tag>
            
            <tag> SIFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在研究生生活之前</title>
      <link href="/nichijou180918/"/>
      <url>/nichijou180918/</url>
      
        <content type="html"><![CDATA[<p>额, 坦白说已经开学两个多星期了, 用这个标题真的没问题吗? 算了不管了.</p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=468490581&auto=0&height=66"></iframe><p>总之, 研究生生活开始了. 作为一个渣渣, 我在开学后才确定导师(之前联系老师邮件基本不回), 上大这边的情况好像是大家都不太愿意去光纤组, 虽然光纤组很强老师又多, 在开学典礼上, 院长(光纤组组长)也强调了这个问题. 相反某些热门方向的老师不论资辈学生竞争激烈. 我个人是希望能做图像处理偏软件方向的, 好在天无绝人之路, 收到消息一个相关方向的老师还缺一个名额, 于是发了邮件, 过去聊了聊, 老师很爽快当场就定下了, 所以机遇这种事情吧, 就看自己有没有做好抓住机遇准备. 话说我在和老师聊的过程中陆续还有几个同学找导师过来, 当时我和老师已经谈妥并签下了双向协议, 老师只好当场一一回绝, 弄得很是尴尬. 总之各种机缘巧合, 终于能安下心来继续求学了.</p><p>我们这届被安排在延长, 自然各种不方便, 去食堂吃个饭加走路来回估计要三四十分钟, 去宝山的实验室公交车程要四五十分钟. 虽说也有校车, 但供不应求啊, 即使早到20分钟等车, 也面临着可能校车坐满先走白等的风险, 没有任何通知信息, 靠谱程度实在不如公交…记得一本校舍友的老师曾这么和他们这么说(那时通院的实验室还没有搬去宝山)</p><blockquote><p>以后等实验室搬到宝山你们就不用去延长这么麻烦了</p></blockquote><p>结果就是实验室搬到了宝山, 而我们被安排搬去延长住了…不过平心而论, 延长的住宿条件还是不错, 除了1到3层洗不上热水澡以及不怎么连得上的校园网. </p><p>实验室环境也还是不错的, 最近研三师姐们都忙着笔试面试找工作. 然后就是承担了一个偏工程的项目, 说白了就是用网页展现一个数据库的内容, 所以正在学习用Python写后端, 另外可能有机会玩一玩Xbox的Kinect.</p><p>暑假的时候摸出了<a href="https://github.com/Granvallen/bilibili-api">bilibili-api</a>和<a href="https://github.com/Granvallen/blockwar">Blockwar</a>这两个项目, 有空的话聊聊这段折腾的过程.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Nichijou </category>
          
          <category> 杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈线性回归</title>
      <link href="/linearregression/"/>
      <url>/linearregression/</url>
      
        <content type="html"><![CDATA[<p>之前学着用过线性回归的一些东西, 这里稍微整理下, 虽然是比较基础的内容, 希望能理出一个比较清晰的方法思路来, 如果能对到其他人理解这个问题有帮助那再好不过了:)</p><span id="more"></span><p>其实内容不多, 这里首先谈谈问题的背景引入回归这个概念, 以及他要解决的问题, 然后是今天的主角—<strong>线性回归</strong>方法, 从简单的一元函数开始说明, 再推广到实际应用上更一般的多元线性回归. <strong>最小二乘法</strong>是最常用来解决线性问题的方法之一, 说穿了其实是一种参数估计方法, 是估计线性方程中的未知权向量$\boldsymbol{\beta}$的一种方法, 我们还会给出最小二乘法的矩阵运算形式, 这将便于我们编程来实现算法.</p><p>理论方面的内容主要参考了陈希孺教授的<a href="https://book.douban.com/subject/2201479/">《概率论与数理统计》</a>, 这是一本值得安利的教材, 难能可贵的是这书不是公式和定义堆砌而成的”工具书”, 作者更想传授的是一种统计学特有的思考方式. 同时也有参考其他讨论这个问题的资料, 比如也引入了一些统计学习语境下的观点与术语, 顺便统一了一下符号的表示方法.</p><h1 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h1><p>回归分析这是统计学应用的一个分支, 下面是从wiki百科上摘下来的解释:</p><blockquote><p>回归分析(Regression Analysis)是一种统计学上分析数据的方法, 目的在于了解两个或多个变量间是否相关、相关方向与强度, 并建立数学模型以便观察特定变量来预测研究者感兴趣的变量. 更具体的来说, 回归分析可以帮助人们了解在只有一个自变量变化时因变量的变化量. 一般来说, 通过回归分析我们可以由给出的自变量估计因变量的条件期望. </p></blockquote><p>回归可以理解为对于有相关性的变量, 通过建立数学模型(函数)去对变量之间的关系进行刻画的过程. 比如人的年龄与身高可能与体重存在某种相关性, 抽象出一个数学模型, 记$x^{(1)}$为一个的年龄, $x^{(2)}$为这个人的身高(之所以不用$x_{1}$与$x_{2}$是为了避免与之后的样本的右下标号弄混), 而$y$是体重, 这三个变量之间的相关性可能存在一个函数关系即:</p><script type="math/tex; mode=display">y=f(x^{(1)},x^{(2)})+e</script><p>$e$是一种随机误差, 我们通常假设$e$是服从于均值为0, 方差为$\sigma^{2}$的正态分布.</p><p>回归分析的一个主要应用就是预测, 在这个例子里, 假如我们得到了这个$f$, 那么对于任何一个人, 只要报出他的年龄与身高就可以根据这个函数求出体重. 当然以上说的只是一种理想化, 事实上由于存在随机性与噪声, 我们永远也无法真正得到$y$, 再者与体重相关的变量因素可能不单单只有年龄与身高这么简单, 所以这种相关性的刻画是近似的, 而不是严格的. 我们只能估计得到$f$计算其函数值, 而希望$f$的值尽可能与$y$近似.</p><p>但是这个思路仍是有用的, 只是需要合理的处理变量与把误差尽可能限制在能够接受的范围内. 解决问题的关键往往不在消除误差, 而是使误差可控. 从上面的例子再抽象到一般, 假设我们认为有$p$个变量与$y$有关, 则可以表达为:</p><script type="math/tex; mode=display">y=f(x^{(1)},x^{(2)},\dots,x^{(p)})+e</script><p>其中$f$被称为”回归函数”, 统计回归的目的就是去估计这个函数. 由于回归常用于预测问题, 故这里的$x^{(1)},x^{(2)},\dots,x^{(p)}$也被称为<strong>预测因子或预测量</strong>(predictors), 这是统计学中术语, 在应用中也称为<strong>特征</strong>(features), 这在模式识别(PR, Pattern Recognition)问题中更为常用. </p><p>为了去估计$f$, 样本是必要的, 样本(sample)是采样得到的一组组数据, 或者说是观测值(observation) 每一个样本都包含了$p$个变量与$y$的值, 样本中蕴藏着这个模型(或者说函数$f$)的信息. 从统计机器学习的角度看回归是一种监督学习(supervised learning), 从样本信息中”学习”得到我们需要的模型.</p><p>以上我们一直在说模型, 函数, 那么我们对于$f$究竟有多少了解? 根据不同了解情况, 可以简单地把回归分成两类, 若对$f$没有任何的了解, 无法给出$f$数学形式的任何<strong>假定</strong>(assumption), 这种情况称”无参数回归”, 不做讨论; 另一种则更常用, 即先假定了$f$的数学形式, 只是这个函数或者说模型中存在一些尚未确定的参数, 这些参数影响着$f$的性态, 此时求解回归问题的更具体地说, 即是通过样本或者说观测值, 去估计这些未知参数, 即熟悉的参数估计问题(点估计或区间估计), 这也称为”参数回归”. 下面要说到的线性回归即是<strong>假定$f$为线性函数</strong>所进行的参数回归, 之所以重视这种情况, 是因为这是应用上最广泛, 理论发展最完善的特例之一.</p><p>既然是参数估计问题就离不开采样. 假设有$N$个样本, 记为${(\boldsymbol{x}_{1},y_{1}),(\boldsymbol{x}_{2},y_{2}),\dots,(\boldsymbol{x}_{N},y_{N})}$:</p><script type="math/tex; mode=display"> \boldsymbol{x_{i}}= \begin{bmatrix}  x_{i}^{(1)} \\  x_{i}^{(2)} \\  \vdots \\  x_{i}^{(p)} \\  \end{bmatrix}_{p\times1}</script><script type="math/tex; mode=display">y_{i}=f(\boldsymbol{x_{i}})+e_{i}\qquad i=1,2,\dots,N</script><p>可以用矩阵简洁地表达为:</p><script type="math/tex; mode=display">\boldsymbol{y}=f(\boldsymbol{X})+\boldsymbol{e}</script><p>其中:</p><script type="math/tex; mode=display">\boldsymbol{y}=\begin{bmatrix} y_{1} \\ y_{2} \\ \vdots \\ y_{N} \\ \end{bmatrix}_{N\times1}</script><script type="math/tex; mode=display">\boldsymbol{X}=\begin{bmatrix} \boldsymbol{x}_{1}^{T} \\ \boldsymbol{x}_{2}^{T} \\ \vdots \\ \boldsymbol{x}_{N}^{T} \\  \end{bmatrix}_{N\times p}</script><script type="math/tex; mode=display"> \boldsymbol{e}= \begin{bmatrix}  e_{1} \\  e_{2} \\  \vdots \\  e_{N} \\  \end{bmatrix}_{N\times1}</script><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p>就像之前说的, 线性回归是<strong>假定$f$为线性方程</strong>所进行的参数回归. 所谓”线性方程”, 是指$f$有如下形式:</p><script type="math/tex; mode=display">f(x^{(1)},x^{(2)},\dots,x^{(p)})=b_{0}+b_{1}x^{(1)}+b_{2}x^{(2)}+\dots+b_{p}x^{(p)}</script><p>然后采样$N$次, 对于第$i$次采样得到</p><script type="math/tex; mode=display">y_{i}=b_{0}+b_{1}x_{i}^{(1)}+b_{2}x_{i}^{(2)}+\dots+b_{p}x_{i}^{(p)}+e_{i}\qquad i=1,2,\dots,N</script><p>这里有一个问题需要先说明, 我们通常需要对采样得到的数据进行”中心化”, 具体操作为把上式改写为:</p><script type="math/tex; mode=display">y_{i}=\beta_{0}+\beta_{1}z_{i}^{(1)}+\beta_{2}z_{i}^{(2)}+\dots+\beta_{p}z_{i}^{(p)}+e_{i}\qquad i=1,2,\dots,N</script><p>可以求得:</p><script type="math/tex; mode=display">z^{(k)}_{i}=x_{i}^{(k)}-\bar{x}^{(k)}\qquad i=1,2,\dots,N;k=1,2,\dots,p</script><script type="math/tex; mode=display">\bar{x}^{(k)}=\frac{1}{N}\sum^{N}_{i=1}x^{(k)}_{i}\qquad k=1,2,\dots,p</script><script type="math/tex; mode=display">\beta_{k}=b_{k}\qquad k=1,2,\dots,p</script><script type="math/tex; mode=display">\beta_{0}=b_{0}+b_{1}\bar{x}^{(1)}+\dots+b_{p}\bar{x}^{(p)}</script><p>“中心化”后需要估计的参数由$b_{k}$转变为$\beta_{k}$, 这样处理地好处是相比估计得到的$\hat{b}_{k}$, 各$\hat{\beta}_{k}$之间是互不相关的. 这体现了”中心化”处理的优势.</p><p>另外我们注意到, “中心化”后:</p><script type="math/tex; mode=display">\sum^{N}_{i=1}z^{(k)}_{i}=\sum^{N}_{i=1}\left(x_{i}^{(k)}-\bar{x}^{(k)}\right)=\sum^{N}_{i=1}x_{i}^{(k)}-N\bar{x}^{(k)}=0</script><p>“中心化”或者说是模型的”中心化”, 实际上可以理解为是对样本的预处理过程, 我们一般假定这个预处理过程是事先完成的, $z^{(k)}_{i}$仍然用$x^{(k)}_{i}$来表示(但是知道此时的样本已经经过”中心化”处理了). 于是我们的方程描述成:</p><script type="math/tex; mode=display">y_{i}=\beta_{0}+\beta_{1}x_{i}^{(1)}+\beta_{2}x_{i}^{(2)}+\dots+\beta_{p}x_{i}^{(p)}+e_{i}\qquad i=1,2,\dots,N</script><p>同时有:</p><script type="math/tex; mode=display">\sum^{N}_{i=1}x^{(k)}_{i}=0\qquad k=1,2,\dots,p</script><p>可以看到$x^{(k)}_{i}$通过$\beta_{k}$进行线性加权. $\beta_{k}$即是每一个对应预测因子的权重. $\beta_{0}$这一项是孤立的常数项, 有时称这项为线性方程的截距(intercept). 下面依然试图用矩阵来简化线性方程的描述.</p><p>为了表示方便一般把上式写成两向量内积(inner product)的形式:</p><script type="math/tex; mode=display">y=\beta_{0}+\boldsymbol{x}^{T}\boldsymbol{\beta}+e</script><p>这里$\boldsymbol{\beta}$与$\boldsymbol{x}$都是列向量:</p><script type="math/tex; mode=display">\boldsymbol{\beta}=\begin{bmatrix} \beta_{1} \\ \beta_{2} \\ \vdots \\ \beta_{p} \\ \end{bmatrix}_{p\times1}</script><script type="math/tex; mode=display"> \boldsymbol{x}= \begin{bmatrix}  x^{(1)} \\  x^{(2)} \\  \vdots \\  x^{(p)} \\  \end{bmatrix}_{p\times1}</script><p>为了运算的便利, 有时也把$\boldsymbol{x}$扩一维, 添加$x^{(0)}=1$, 这样再把$\beta_{0}$加入$\boldsymbol{\beta}$, 就得到形式更为简洁的:</p><script type="math/tex; mode=display">y=\boldsymbol{x}^{T}\boldsymbol{\beta}+e</script><p>这里$\boldsymbol{x}$与$\boldsymbol{\beta}$列向量都是$p+1$维的, 称此线性回归问题为p元的的线性回归问题, 因为有p个预测因子. 向量$\boldsymbol{\beta}$也称之为<strong>权向量</strong>, 权向量的取值空间称为权空间(weight space)</p><p>然后$N$次采样后:</p><script type="math/tex; mode=display">\boldsymbol{y}=\boldsymbol{X}\boldsymbol{\beta}+\boldsymbol{e}</script><script type="math/tex; mode=display">\boldsymbol{X}=\begin{bmatrix} \boldsymbol{x}_{1}^{T} \\ \boldsymbol{x}_{2}^{T} \\ \vdots \\ \boldsymbol{x}_{N}^{T} \\  \end{bmatrix}_{N\times (p\times 1)}</script><h2 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h2><p>所有的准备都已完毕, 下面来解这个问题, 即如何估计得到权向量.</p><p>对于一元与二元线性回归我们有非常直观的解释, 下面讨论一元线性回归, 其模型假设为:</p><script type="math/tex; mode=display">y=\beta_{0}+\beta_{1}x+e</script><p>对于$N$次采样我们画出图来:</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/linearregression1.PNG"  style="zoom:40%" alt="" align=center /></p><p>图中的点即样本, 我们需要找到一种方法, 在某个标准下, 找到能比较准确描述输入输出关系的那条线, 比如图中的红线.</p><p>这条红线便是预测线, 他由如下线性方程描述:</p><script type="math/tex; mode=display">\hat{y}=\hat{\beta}_{0}+\hat{\beta}_{1}x</script><p>$\hat{\beta}_{0}$与$\hat{\beta}_{1}$是对$\beta_{0}$与$\beta_{1}$的估计, 如何获得这个估计?我们需要选择一个策略, 即一个衡量模型好坏的标准. 一个直观的办法就是看模型预测出的的$\hat{y}$在那些样本点上与采样值$y$的差距, 我们取:</p><script type="math/tex; mode=display">L(\hat{\beta}_{0}, \hat{\beta}_{1})=\sum^{N}_{i=1}(y_{i}-\hat{y}_{i})^{2}</script><p>上式直观的解释是: <strong>我们所寻找的预测线(模型), 应该使所有样本点到预测线竖直距离和最小</strong>. 这就是<strong>最小二乘法</strong>(Least Squares)在一元情况下遵循的策略. 同时也知道了, 最小二乘法属于一种点估计.</p><p>在统计学习中上式也被称为损失函数(loss function), 更确切地说是一种平方损失函数(quadratic loss function). 损失函数值越小(通过调节参数$\hat{\beta}_{0},\hat{\beta}_{1}$大小)模型越好.</p><p>在统计学中, 曾定义<strong>残差平方和</strong>(RSS,residual sum of squares), 其计算公式与$L(\hat{\beta}_{0}, \hat{\beta}_{1})$相同, 所以也可以认为最小二乘法是求得RSS最小的权向量估计. </p><p>利用多元函数求极值的方法, 我们很容易就可以求得这个问题的解析解.</p><script type="math/tex; mode=display">L(\hat{\beta}_{0}, \hat{\beta}_{1})=\sum^{N}_{i=1}(y_{i}-\hat{y}_{i})^{2}=\sum^{N}_{i=1}(y_{i}-\hat{\beta}_{0}- \hat{\beta}_{1}x_{i})^{2}</script><p>上式分别对$\hat{\beta}_{0}, \hat{\beta}_{1}$求偏导, 并令其为0. 得:</p><script type="math/tex; mode=display">\dfrac{\partial L}{\partial \hat{\beta}_{0}}=-2\sum^{N}_{i=1}[y_{i}-\hat{\beta}_{0}- \hat{\beta}_{1}x_{i}]=0</script><script type="math/tex; mode=display">\dfrac{\partial L}{\partial \hat{\beta}_{1}}=-2\sum^{N}_{i=1}x_{i}[y_{i}-\hat{\beta}_{0}- \hat{\beta}_{1}x_{i}]=0</script><p>由于经过”中心化”, 之前说过有结论:</p><script type="math/tex; mode=display">\sum^{N}_{i=1}x^{(k)}_{i}=0\qquad k=1,2,\dots,p</script><p>于是可解出$\hat{\beta}_{0},\hat{\beta}_{1}$:</p><script type="math/tex; mode=display">\hat{\beta}_{0}=\bar{y}=\frac{1}{N}\sum^{N}_{i=1}y_{i}</script><script type="math/tex; mode=display">\hat{\beta}_{1}=\frac{\sum\limits^{N}_{i=1}x_{i}y_{i}}{\sum\limits^{N}_{i=1}x^{2}_{i}}</script><p>$\hat{\beta}_{0},\hat{\beta}_{1}$本身有一些比较好的性质, 比如可以证明他们是$\beta_{0},\beta_{1}$的无偏估计, 并且他们是不相关的. 当假设随机误差$e$服从正态分布时, 他们还是独立的, 并且是$\beta_{0},\beta_{1}$的最小方差无偏估计, 证明可参考《概率论与数理统计》P.267~269内容.</p><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p>当$p=2$时即二元线性回归, 我们仍然可以直观地想象模型:</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/linearregression3.PNG"  style="zoom:40%" alt="" align=center /></p><p>此时对于每个样本点有两个特征$\boldsymbol{x}_{i}=(x^{(1)}_{i},x^{(2)}_{i})$, 故模型是一个空间平面去拟合(fit)样本. 此时最小二乘法求解的原则是样本点到平面竖直距离和最小.</p><p>$p&gt;2$的多元线性回归就没有这么直观了, 但我们依然可以知道模型是使用超平面(hyperplane)去拟合样本.</p><p>为了能直接推导出最后实用的矩阵运算方法, 我们对$\boldsymbol{x}_{i}$升1维处理, 正如之前说过的, 令$x^{(0)}_{i}=1$, 于是:</p><script type="math/tex; mode=display">y_{i}=\hat{\beta}_{0}x^{(0)}_{i}+\hat{\beta}_{1}x_{i}^{(1)}+\hat{\beta}_{2}x_{i}^{(2)}+\dots+\hat{\beta}_{p}x_{i}^{(p)}\qquad i=1,2,\dots,N</script><p>推导权向量的估计与一元时类似, 损失函数为:</p><script type="math/tex; mode=display">L(\hat{\beta}_{0},\hat{\beta}_{1},\dots,\hat{\beta}_{p})=\sum^{N}_{i=1}(y_{i}-\hat{y_{i}})^{2}=\sum^{N}_{i=1}(y_{i}-\hat{\beta}_{0}x^{(0)}_{i}-\hat{\beta}_{1}x_{i}^{(1)}-\hat{\beta}_{2}x_{i}^{(2)}-\dots-\hat{\beta}_{p}x_{i}^{(p)})^{2}</script><p>对各权向量求导令其为0:</p><script type="math/tex; mode=display">\dfrac{\partial L}{\partial \hat{\beta}_{0}}=0,\quad \dfrac{\partial L}{\partial \hat{\beta}_{1}}=0,\quad \dfrac{\partial L}{\partial \hat{\beta}_{2}}=0,\quad\dots,\quad \dfrac{\partial L}{\partial \hat{\beta}_{p}}=0</script><p>由于样本经过”中心化”处理, 依然有:</p><script type="math/tex; mode=display">\sum^{N}_{i=1}x^{(k)}_{i}=0\qquad k=1,2,\dots,p</script><p>对于$\hat{\beta}_{0}$的偏导, 可以整理为:</p><script type="math/tex; mode=display">\dfrac{\partial L}{\partial \hat{\beta}_{0}}  = -2\sum^{N}_{i=1}\left( y_{i}-\hat{\beta}_{0}x^{(0)}_{i}-\hat{\beta}_{1}x^{(1)}_{i}-\dots-\hat{\beta}_{p}x^{(p)}_{i}\right)=0</script><script type="math/tex; mode=display">\sum^{N}_{i=1}x^{(0)}_{i}y_{i}=\hat{\beta}_{0}\sum^{N}_{i=1}x^{(0)}_{i}x^{(0)}_{i}+\hat{\beta}_{1}\sum^{N}_{i=1}x^{(0)}_{i}x^{(1)}_{i}+\dots+\hat{\beta}_{p}\sum^{N}_{i=1}x^{(0)}_{i}x^{(p)}_{i}</script><p>把剩余方程相同处理列在一起:</p><script type="math/tex; mode=display">\begin{cases} \hat{\beta}_{0}\sum^{N}_{i=1}x^{(0)}_{i}x^{(0)}_{i}+\hat{\beta}_{1}\sum^{N}_{i=1}x^{(0)}_{i}x^{(1)}_{i}+\dots+\hat{\beta}_{p}\sum^{N}_{i=1}x^{(0)}_{i}x^{(p)}_{i}=\sum^{N}_{i=1}x^{(0)}_{i}y_{i} \\ \hat{\beta}_{0}\sum^{N}_{i=1}x^{(1)}_{i}x^{(0)}_{i}+\hat{\beta}_{1}\sum^{N}_{i=1}x^{(1)}_{i}x^{(1)}_{i}+\dots+\hat{\beta}_{p}\sum^{N}_{i=1}x^{(1)}_{i}x^{(p)}_{i}=\sum^{N}_{i=1}x^{(1)}_{i}y_{i} \\ \vdots \\ \hat{\beta}_{0}\sum^{N}_{i=1}x^{(p)}_{i}x^{(0)}_{i}+\hat{\beta}_{1}\sum^{N}_{i=1}x^{(p)}_{i}x^{(1)}_{i}+\dots+\hat{\beta}_{p}\sum^{N}_{i=1}x^{(p)}_{i}x^{(p)}_{i}=\sum^{N}_{i=1}x^{(p)}_{i}y_{i}\end{cases}</script><p>下面用矩阵对上式进行形式上的简化, 令:</p><script type="math/tex; mode=display">\boldsymbol{X}=\begin{bmatrix} x^{(0)}_{1} & x^{(1)}_{1} & \ldots & x^{(p)}_{1} \\x^{(0)}_{2} & x^{(1)}_{2} & \ldots & x^{(p)}_{2} \\ \vdots & \vdots\ & \ddots & \vdots \\ x^{(0)}_{N} & x^{(1)}_{N} & \ldots & x^{(p)}_{N} \\ \end{bmatrix}=\begin{bmatrix} \boldsymbol{x}_{1}^{T} \\ \boldsymbol{x}_{2}^{T} \\ \vdots \\ \boldsymbol{x}_{N}^{T} \\ \end{bmatrix}_{N\times (p+1)}</script><script type="math/tex; mode=display">\boldsymbol{y}=\begin{bmatrix} y_{1} \\ y_{2} \\ \vdots \\ y_{N} \\ \end{bmatrix}_{N\times1}</script><script type="math/tex; mode=display">\boldsymbol{\hat{\beta}}=\begin{bmatrix} \beta_{0} \\ \beta_{1} \\ \beta_{2} \\ \vdots \\ \beta_{p} \\ \end{bmatrix}_{(p+1)\times1}</script><p>于是上式可简化为:</p><script type="math/tex; mode=display">\boldsymbol{X}^{T}\boldsymbol{X}\boldsymbol{\hat{\beta}}=\boldsymbol{X}^{T}\boldsymbol{y}</script><p>当$\boldsymbol{X}^{T}\boldsymbol{X}$可逆, 有:</p><script type="math/tex; mode=display">\boldsymbol{\hat{\beta}}=(\boldsymbol{X}^{T}\boldsymbol{X})^{-1}\boldsymbol{X}^{T}\boldsymbol{y}</script><h2 id="最小二乘法矩阵表示的简单推导"><a href="#最小二乘法矩阵表示的简单推导" class="headerlink" title="最小二乘法矩阵表示的简单推导"></a>最小二乘法矩阵表示的简单推导</h2><p>利用矩阵代数中的向量的数量函数对向量的导数的概念, 上述推导过程会更加简洁. 直接从损失函数出发:</p><script type="math/tex; mode=display">L(\hat{\boldsymbol{\beta}})=\sum^{N}_{i=1}(y_{i}-\boldsymbol{x}_{i}^{T}\hat{\boldsymbol{\beta}})^{2}=\begin{bmatrix} y_{1}-\boldsymbol{x}_{1}^{T}\boldsymbol{\hat{\beta}} \\ y_{2}-\boldsymbol{x}_{2}^{T}\boldsymbol{\hat{\beta}} \\ \vdots \\ y_{N}-\boldsymbol{x}_{N}^{T}\boldsymbol{\hat{\beta}} \\ \end{bmatrix}^{T}\begin{bmatrix}y_{1}-\boldsymbol{x}_{1}^{T}\boldsymbol{\hat{\beta}} \\ y_{2}-\boldsymbol{x}_{2}^{T}\boldsymbol{\hat{\beta}} \\ \vdots \\ y_{N}-\boldsymbol{x}_{N}^{T}\boldsymbol{\hat{\beta}} \\ \end{bmatrix}=(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\hat{\beta}})^{T}(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\hat{\beta}})</script><script type="math/tex; mode=display">\mathrm{d}L=-(\boldsymbol{X}\mathrm{d}\boldsymbol{\hat{\beta}})^{T}(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\hat{\beta}})-(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\hat{\beta}})^{T}\boldsymbol{X}\mathrm{d}\boldsymbol{\hat{\beta}}</script><p>再利用迹技巧(trace trick), 可以得到:</p><script type="math/tex; mode=display">\mathrm{d}L=-2(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\hat{\beta}})^{T}\boldsymbol{X}\mathrm{d}\boldsymbol{\hat{\beta}}</script><p>故:</p><script type="math/tex; mode=display">\frac{\mathrm{d}L}{\mathrm{d}\boldsymbol{\hat{\beta}}}=-2(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\hat{\beta}})^{T}\boldsymbol{X}=-2\boldsymbol{X}^{T}(\boldsymbol{y}-\boldsymbol{X}\boldsymbol{\hat{\beta}})=0</script><script type="math/tex; mode=display">\boldsymbol{X}^{T}\boldsymbol{y}-\boldsymbol{X}^{T}\boldsymbol{X}\boldsymbol{\hat{\beta}}=0</script><p>同样解得:</p><script type="math/tex; mode=display">\boldsymbol{\hat{\beta}}=(\boldsymbol{X}^{T}\boldsymbol{X})^{-1}\boldsymbol{X}^{T}\boldsymbol{y}</script><p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> 统计学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Matlab处理Excel</title>
      <link href="/matlabexcel/"/>
      <url>/matlabexcel/</url>
      
        <content type="html"><![CDATA[<p>虽然最近比较多用Matlab做事, 但还没怎么正式地写过几篇讲讲Matlab. 嗯, 我是不是还忘了什么. . . （Mathematica QAQ）. </p><p>记起来之前写过一个Matlab与Excel交互处理表格的脚本, 于是又摸出了这篇博文. 事情是这样的, 作为一个苦逼的学习委员（基层干部）平时干得最多的事情当然是——打杂, 帮老师收个作业, 带个口信, 收收费什么的, 不过这些其中要说我比较讨厌的就是每次考试后的算绩点（好吧, 我承认我excel比较苦手）, 不知道其他学校怎么样, 我们是学委担此重任. 话说计算机的同学们, 你们都能拉出表格了不顺便算个GPA?其实我写了才知道最恶心的其实是处理表格的格式, 算绩点一句话就够了. . . </p><p>本文的脚本应该没有什么其他人能用得上, 因为各种格式都是按照表格和要求设计的, 不过其中的一些处理表格的方法还是值得做个笔记的. 受闪轨启发, 我把这个计划称为——学委解放战线</p><span id="more"></span><p>老师的要求也不复杂, 可以总结为两点: </p><ul><li>1.算出每个同学绩点与排名, 并且填入到姓名后新建的两列内, 并计算班级平均绩点. （挂科按60算）</li><li>2.筛选出低于60分不及格的成绩, 并用黄色填充. </li></ul><p>表格样本的原格式如下（我随便找的, 不算滥用职权吧）: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/sheet1.PNG"  style="zoom:40%" alt="" align=center /></p><p>姓名我用序号代替了. </p><p>要用matlab来处理做到这些, 则需要解决: </p><ul><li>1.表格里的信息都是文本格式, 需要把数据与字符进行区分. </li><li>2.有些课程是等级评分, 分优、良、及格等, 需要转换为对应百分制分值再计算. </li><li>3.表格中包含了某些修读双学位或重修的额外课程, 如电气X班的表里还有修读金融学的同学, 而该班其他同学并不修这些金融学课程, 原则上计算绩点时, 这些课程是不算在内的. </li><li>4.有些缓考的同学某课成绩标注的是’-‘, 需要区分出来, 并不计入绩点计算. </li><li>5.matlab对表格的格式控制, 包括插入数据列、改变表格背景色等. </li><li>6.matlab矩阵元素序号到excel表格序号的转换. </li><li>7.先计算绩点, 然后计算排名. </li></ul><p>主要思路是把处理表格格式和处理数据分开来做, 处理表格格式用<strong>actxserver(‘excel.application’)</strong>创建excel应用类来做, 操作方法与C#处理excel相同, 具体使用方法可以参考<a href="http://blog.csdn.net/north_easter/article/details/6861992">这里</a>或<a href="https://msdn.microsoft.com/en-us/vba/excel-vba/articles/application-object-excel">这里</a>；表格的数据用<strong>xlsread</strong>读入处理. </p><p>另外做了一些强化, 包括: </p><ul><li>1.打印处理表格的基本信息和没有计入绩点计算的课程的修读人数情况, 便于查错. </li><li>2.增设了几个可调变量, 包括判定为重修与双学位课程的修读人数阈值等. </li><li>3.程序自动扫描当前文件夹下所有excel文档, 批量处理, 处理后文档输出到新建的Output文件夹. </li></ul><p>下面是code</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% forfreedom.m</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forfreedom</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%% 初始化 自定义参数设定</span></span><br><span class="line">    clc</span><br><span class="line">    clear</span><br><span class="line">    close all</span><br><span class="line">    <span class="comment">%======================== 一般只需要在画线区域修改 ============================</span></span><br><span class="line">    stu_ppt = <span class="number">0.2</span>; <span class="comment">% 当选课人数少于总人数的 stu_ppt * 100%, 认为该课为重修或双学位课程, 默认 20%</span></span><br><span class="line">    score_mdf = <span class="number">60</span>; <span class="comment">% 挂科的按 score_mdf 来算绩点, 默认以 60分来算</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">%======================== 一般只需要在画线区域修改 ============================</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;开始工作咯, 计时, 滴~&#x27;</span>);</span><br><span class="line">    tic</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%% 读取excel文档</span></span><br><span class="line">    e = actxserver(<span class="string">&#x27;excel.application&#x27;</span>); <span class="comment">% 建立excel数据类</span></span><br><span class="line">    path = pwd;</span><br><span class="line">    xlsfiles = dir(fullfile(path, <span class="string">&#x27;*.xls&#x27;</span>));</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;这个目录下有&#x27;</span> num2str(<span class="built_in">size</span>(xlsfiles, <span class="number">1</span>)) <span class="string">&#x27;张表格&#x27;</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : <span class="built_in">size</span>(xlsfiles)</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;正在处理第&#x27;</span> num2str(<span class="built_in">j</span>) <span class="string">&#x27;张表格&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;!&#x27;</span>]);</span><br><span class="line">        xls_file_name = xlsfiles(<span class="built_in">j</span>).name;</span><br><span class="line">        WorkBook = e.Workbooks.Open([path <span class="string">&#x27;/&#x27;</span> xls_file_name]);</span><br><span class="line"></span><br><span class="line">        sheets = e.ActiveWorkBook.Sheets;</span><br><span class="line">        sheet1 = sheets.Item(<span class="number">1</span>); <span class="comment">% 获得sheet1</span></span><br><span class="line">    <span class="comment">%     e.Visible = 1;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 读入excel的数据</span></span><br><span class="line">        [~, xls] = xlsread([path <span class="string">&#x27;/&#x27;</span> xls_file_name], <span class="number">1</span>);</span><br><span class="line">        [xls_n, xls_p] = <span class="built_in">size</span>(xls);</span><br><span class="line"></span><br><span class="line">        <span class="comment">%% 预处理 1.数据分割, 参数计算    2.去除成绩中的字符     3.去除重修、双学位科目数据           </span></span><br><span class="line">        <span class="comment">% 数据分割 参数计算</span></span><br><span class="line">        xls_title = xls&#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        stu_num = xls_n - <span class="number">5</span>; <span class="comment">% 学生人数</span></span><br><span class="line">        stu_nam = xls(<span class="number">6</span> : <span class="keyword">end</span>, <span class="number">4</span>); <span class="comment">%学生姓名</span></span><br><span class="line">        course_nam = xls(<span class="number">3</span>, <span class="number">5</span> : <span class="keyword">end</span> - <span class="number">3</span>); <span class="comment">% 课程名</span></span><br><span class="line">        course_cred = str2num(cell2mat(xls(<span class="number">4</span>, <span class="number">5</span> : <span class="keyword">end</span> - <span class="number">3</span>))); <span class="comment">%课程学分</span></span><br><span class="line">        score_matrix = xls(<span class="number">6</span> : <span class="keyword">end</span>, <span class="number">5</span> : <span class="keyword">end</span> - <span class="number">3</span>); <span class="comment">% 分数矩阵</span></span><br><span class="line">        [score_matrix_n, score_matrix_p] = <span class="built_in">size</span>(score_matrix);</span><br><span class="line">        appendx = xls(<span class="number">6</span> : <span class="keyword">end</span>, <span class="keyword">end</span> - <span class="number">2</span> : <span class="keyword">end</span>); <span class="comment">%最后三列</span></span><br><span class="line"></span><br><span class="line">        toc</span><br><span class="line">        fprintf(<span class="string">&#x27;表格基本信息: \n表格标题: %s\n班级人数: %d\n总课程数: %d\n&#x27;</span>, ...</span><br><span class="line">            xls_title, stu_num, <span class="built_in">length</span>(course_nam));</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 分数矩阵处理</span></span><br><span class="line">        <span class="comment">% 非法字符处理</span></span><br><span class="line">        [score_matrix&#123;strncmp(&#123;<span class="string">&#x27;优&#x27;</span>&#125;, score_matrix, <span class="number">1</span>)&#125;] = deal(<span class="string">&#x27;95.0&#x27;</span>); <span class="comment">% 处理 优 良 及格 不及格</span></span><br><span class="line">        [score_matrix&#123;strncmp(&#123;<span class="string">&#x27;良&#x27;</span>&#125;, score_matrix, <span class="number">1</span>)&#125;] = deal(<span class="string">&#x27;85&#x27;</span>); </span><br><span class="line">        [score_matrix&#123;strncmp(&#123;<span class="string">&#x27;及格&#x27;</span>&#125;, score_matrix, <span class="number">1</span>)&#125;] = deal(<span class="string">&#x27;65.0&#x27;</span>); </span><br><span class="line">        [score_matrix&#123;strncmp(&#123;<span class="string">&#x27;不及格&#x27;</span>&#125;, score_matrix, <span class="number">1</span>)&#125;] = deal(<span class="string">&#x27;50&#x27;</span>); </span><br><span class="line">        [score_matrix&#123;strncmp(&#123;<span class="string">&#x27;-&#x27;</span>&#125;, score_matrix, <span class="number">1</span>)&#125;] = deal(<span class="string">&#x27;-1&#x27;</span>); <span class="comment">% 处理 &#x27;-&#x27;   </span></span><br><span class="line">        <span class="comment">% 元胞数组 转 数值矩阵</span></span><br><span class="line">        score_matrix_num = <span class="built_in">cellfun</span>(@str2num, score_matrix); <span class="comment">% 计算绩点用</span></span><br><span class="line">        score_matrix_mark = score_matrix_num; <span class="comment">%标注不及格成绩用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 去除重修、双学位课程 规则: 有成绩的人数占班级总人数比例低于 stu_ppt * 100%</span></span><br><span class="line">        threshold = <span class="built_in">ceil</span>(stu_num * stu_ppt); <span class="comment">% 选课人数低于threshold认为要忽略课程</span></span><br><span class="line">        course_stu_num = sum(score_matrix_num ~= <span class="number">-1</span>); <span class="comment">% 选课人数</span></span><br><span class="line">        course_delete_mask = course_stu_num &lt;= threshold;<span class="comment">% 找到要删除的课程</span></span><br><span class="line">        course_delete_nam = course_nam(:, course_delete_mask); <span class="comment">% 要删除课程的名字</span></span><br><span class="line">        course_delete_stu_num = course_stu_num(course_delete_mask);</span><br><span class="line"></span><br><span class="line">        toc</span><br><span class="line">        <span class="keyword">if</span> (~<span class="built_in">isempty</span>(course_delete_mask))</span><br><span class="line">            fprintf(<span class="string">&#x27;忽略课程信息: \n有%d门课的成绩没有纳入计算绩点, 这些课可能是重修或双学位课程\n这些课程是:\n&#x27;</span>, ...</span><br><span class="line">                sum(course_delete_mask));</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : sum(course_delete_mask)</span><br><span class="line">                fprintf(<span class="string">&#x27;%-30s选课人数: %d\n&#x27;</span>, course_delete_nam&#123;<span class="built_in">i</span>&#125;, course_delete_stu_num(<span class="built_in">i</span>));</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        score_matrix_num(:, course_delete_mask) = []; <span class="comment">% 删除课程分数数据</span></span><br><span class="line">        course_cred(:, course_delete_mask) = []; <span class="comment">% 删除学分数据</span></span><br><span class="line">        course_nam(:, course_delete_mask) = []; <span class="comment">% 删除课程名字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">%% 计算绩点</span></span><br><span class="line">        score_mdf_mask = score_matrix_num &lt; <span class="number">60</span> &amp; score_matrix_num &gt;= <span class="number">0</span>; <span class="comment">% 选出挂科的成绩</span></span><br><span class="line">        score_matrix_num(score_mdf_mask) = score_mdf; <span class="comment">% 考试没过成绩修改</span></span><br><span class="line">        score_matrix_num(score_matrix_num &lt; <span class="number">0</span>) = <span class="number">50</span>; <span class="comment">% 没出成绩, 可能缺考, 先算50</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 计算 GPA</span></span><br><span class="line">        GPA = <span class="built_in">round</span>((score_matrix_num - <span class="number">50</span>) * course_cred&#x27; ./ (sum(course_cred) * <span class="number">10</span>), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">%% 修改表结构 + 填入绩点 + 填入排名</span></span><br><span class="line">        sheet1.Range([<span class="string">&#x27;F1:F&#x27;</span> num2str(xls_n)]).Insert; <span class="comment">% 绩点</span></span><br><span class="line">        sheet1.Range([<span class="string">&#x27;F1:F&#x27;</span> num2str(xls_n)]).Insert; <span class="comment">% 排名</span></span><br><span class="line">        sheet1.Range(<span class="string">&#x27;F5&#x27;</span>).Value = <span class="string">&#x27;绩点&#x27;</span>;</span><br><span class="line">        sheet1.Range(<span class="string">&#x27;G5&#x27;</span>).Value = <span class="string">&#x27;排名&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        sheet1.Range([<span class="string">&#x27;F6:F&#x27;</span> num2str(<span class="number">6</span> + stu_num - <span class="number">1</span>)]).Value = GPA;</span><br><span class="line">        sheet1.Range([<span class="string">&#x27;F6:G&#x27;</span> num2str(<span class="number">6</span> + stu_num)]).HorizontalAlignment = <span class="number">-4108</span>; <span class="comment">%居中</span></span><br><span class="line">        sheet1.Range([<span class="string">&#x27;F&#x27;</span> num2str(<span class="number">6</span> + stu_num)]).Value = <span class="built_in">round</span>(<span class="built_in">mean</span>(GPA), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        [~, r] = <span class="built_in">sort</span>(GPA, <span class="string">&#x27;descend&#x27;</span>);</span><br><span class="line">        [~, r] = <span class="built_in">sort</span>(r);</span><br><span class="line">        sheet1.Range([<span class="string">&#x27;G6:G&#x27;</span> num2str(<span class="number">6</span> + stu_num - <span class="number">1</span>)]).Value = r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">%% 将未及格的课程标为黄色</span></span><br><span class="line">        score_matrix_mark_mask = score_matrix_mark &lt; <span class="number">60</span> &amp; score_matrix_mark &gt;=<span class="number">0</span>;</span><br><span class="line">        [n, p] = <span class="built_in">find</span>(score_matrix_mark_mask == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : sum(score_matrix_mark_mask(:))</span><br><span class="line">            sheet1.Range(mark_score_excel_coor(n(<span class="built_in">i</span>) + <span class="number">5</span>, p(<span class="built_in">i</span>)+ <span class="number">7</span>)).Interior.ColorIndex = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">%% 保存excel</span></span><br><span class="line">        <span class="keyword">if</span> ~exist(<span class="string">&#x27;Output&#x27;</span>, <span class="string">&#x27;dir&#x27;</span>) </span><br><span class="line">            mkdir(<span class="string">&#x27;Output&#x27;</span>)</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        WorkBook.SaveAs([path <span class="string">&#x27;/Output/&#x27;</span> xls_file_name]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    e.Quit;</span><br><span class="line">    e.delete;</span><br><span class="line">    toc</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;呼~处理完毕*^-^*&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 坐标转换</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">excel_coor</span> = <span class="title">mark_score_excel_coor</span><span class="params">(n, p)</span></span></span><br><span class="line"></span><br><span class="line">     excel_coor = [ex(p) num2str(n)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">excel_coor_p</span> = <span class="title">ex</span><span class="params">(p)</span></span></span><br><span class="line">    <span class="keyword">if</span> p &gt; <span class="number">26</span></span><br><span class="line">        s = ex(<span class="built_in">fix</span>((p<span class="number">-1</span>) / <span class="number">26</span>));</span><br><span class="line">        excel_coor_p = [s char(<span class="number">65</span> + <span class="built_in">mod</span>(p<span class="number">-1</span>, <span class="number">26</span>))];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        excel_coor_p = char(<span class="number">65</span> + p - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>处理结果显示如下: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/sheet2.PNG"  style="zoom:40%" alt="" align=center /></p><p>输出表格如下: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/sheet3.PNG"  style="zoom:40%" alt="" align=center /></p><p>其中可能值得一说的是matlab矩阵索引坐标转换为excel表格索引的处理, 比如matlab中矩阵坐标(1, 2), 对应excel坐标是(1, B). 查了一圈好像没什么人碰到这个问题就自己写了. 其实主要要解决的是列坐标的转换问题. excel的列坐标序号是, 从A到Z, 然后是AA到AZ, 之后BA…, 我想你看出来了, 这本质上就是26进制的计数系统, 我用了一个递归算法实现了他. </p><p>刚写完, 然而…今年不用算绩点了. . .<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不务正业 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于采样的总结</title>
      <link href="/sampling/"/>
      <url>/sampling/</url>
      
        <content type="html"><![CDATA[<p>最近又在复习信号处理的东西, 对于一些内容有了更深入的理解, 于是做一个关于采样的总结. 众所周知, 自然界大多数信号是模拟信号, 采样是数字系统处理的第一步, 主要由各种传感器配合A/D来实现. 在<a href="https://granvallen.github.io/fft/">FFT为什么那么快</a>一文中提到了“重采样”的概念, 在那里一笔带过了, 本文也算是一个补充. </p><span id="more"></span><p>既然是内容的梳理必然会牵涉到很多细节, 其中包括数学公式的推导, 这些在奥本海姆教授的两本著作<a href="https://book.douban.com/subject/21359219/">《信号与系统》</a>和<a href="https://book.douban.com/subject/26307919/">《离散时间信号处理》</a>都有详细推导过程. 本文的主要内容可以在《信号与系统》的第七章与《离散时间信号处理》的第四章中找到参考, 以下简写为《信-奥》与《离-奥》, 区别于参考郑君里教授的同名著作, 将简写作《信-郑》. 由于这部分采样内容在两本书中分布广泛、符号定义存在差异以及公式推导方式不一, 因此做一个总结是有必要的. 本文的一些内容会基于自己的理解, 可能错误在所难免, 不过书写是为了更好地理解. </p><p>在阅读这两本书的过程中, 令我十分敬佩的是作者清晰的写作思路. 如果把阅读一本书比作一次冒险旅行, 那么在旅途中作者不断地提醒你: 你现在身处何处？曾走过了哪些景点？经历了哪些岔路？我们这段路地主要景点是什么？我们旅行最终目的地又在何方？具体到某一知识点就是: 这个问题是怎么引入的？为什么要研究这个问题？这个问题在整个知识框架下是什么样的地位？搞清楚了这些再讲: 问题如何解决？解决方法怎么来的？为什么这么解决, 有什么好处？这个问题的解决会引入什么新问题？作者不厌其繁地讲这些也许会被一些人贴上“死于话多”的标签, 但我想对于初学者来说这总是好的, 国外的教材大抵有这样的特点. </p><p>扯远了, 这里也先给出本文的思路. 先梳理采样基础的内容, 包括对连续时间信号的采样和对离散时间信号（序列）的采样过程, 主要注意采样过程数学模型的建立. 接着由对离散时间信号的采样引出离散时间信号处理的两个操作—-抽取与内插, 再引出这两个操作的应用, 即实现重采样. </p><hr><h1 id="连续时间信号采样"><a href="#连续时间信号采样" class="headerlink" title="连续时间信号采样"></a>连续时间信号采样</h1><p>采样过程主要关注采样过程的数学表述以及采样过程在时域与频域的变化, 这部分内容可参考《信-郑》P.156或《信-奥》P.109. </p><p>讨论连续时间采样时, 我们总是采用“理想采样过程”的叙述, 即是说采用周期冲激串来简化模拟采样过程, 这意味着将忽略单次采样的时间, 或者认为ADC的转化过程是瞬间完成的, 这在数学上是一种简化. </p><p>周期为T的采样周期冲激串表达式为: </p><script type="math/tex; mode=display">P(t)=\sum^{\infty}_{n=-\infty}\delta(t-nT)</script><p>$x_{c}(t)$为被采样信号, $x_{s}(t)$为采样后信号, 整个采样过程由被采样信号与采样冲激串相乘来模拟, 即: </p><script type="math/tex; mode=display">x_{s}(t)=x_{c}(t)P(t)=\sum^{\infty}_{n=-\infty}x_{c}(t)\delta(t-nT)=\sum^{\infty}_{n=-\infty}x_{c}(nT)\delta(t-nT)</script><p>以上即是理想采样过程的时域表达, 频域的分析有两种推导方法, 一种是借由傅里叶级数, 把冲激串傅里叶级数展开, 然后对$x_{c}(t)P(t)$做傅里叶变换；另一种是先利用周期函数傅里叶变换求冲激串的傅里叶变换, 然后借助傅里叶变换的相乘性质去求. 这里用第一种方法说明. </p><p>将$P(t)$用复指数形式傅里叶级数展开: </p><script type="math/tex; mode=display">P(t)=\sum^{\infty}_{n=-\infty}\delta(t-nT)=\sum^{\infty}_{n=-\infty}a_{n}e^{jn\Omega_{s}t}</script><p>其中$a_{n}$为傅里叶级数系数, 而: </p><script type="math/tex; mode=display">\Omega_{s}=\frac{2\pi}{T}=2\pi f_{s}</script><p>$\Omega_{s}$是连续时间的采样角频率, 连续时间的角频率用大写的$\Omega$表示, 而离散时间归一化后的角频率用小写$\omega$表示. </p><p>下面计算系数$a_{n}$:</p><script type="math/tex; mode=display">\begin{align}a_{n} &= \frac{1}{T}\int^{T/2}_{-T/2}P(t)e^{-jn\Omega_{s}t}\mathrm{d}t \\ &= \frac{1}{T}\int^{T/2}_{-T/2}\left[\sum^{\infty}_{n=-\infty}\delta(t-nT)\right]e^{-jn\Omega_{s}t}\mathrm{d}t \\ &= \frac{1}{T}\int^{T/2}_{-T/2}\delta(t)e^{-j\cdot 0 \cdot \Omega_{s}t}\mathrm{d}t \\ &= \frac{1}{T}\end{align}</script><p>于是计算$x_{s}(t)$的傅里叶变换: </p><script type="math/tex; mode=display">\begin{align*}X_{s}(j\Omega) = \mathscr{F}\left[x_{s}(t)\right] &= \mathscr{F}\left[x_{c}(t)\cdot P(t)\right] \\&= \int^{+\infty}_{-\infty}x_{c}(t)P(t)e^{-j\Omega t}\mathrm{d}t \\&= \int^{+\infty}_{-\infty}x_{c}(t) \left[\sum^{\infty}_{n=-\infty}\frac{1}{T}e^{jn\Omega_{s}t}\right]e^{-j\Omega t}\mathrm{d}t \\&= \frac{1}{T}\sum^{\infty}_{n=-\infty}\int^{+\infty}_{-\infty}x_{c}(t)e^{-j(\Omega-n\Omega_{s})t}\mathrm{d}t \\&= \frac{1}{T}\sum^{\infty}_{n=-\infty}X_{c}(j(\Omega-n\Omega_{s}))\end{align*}</script><p>可见采样之后频域变化是把$x_{c}(t)$的频域图像以$\Omega_{s}$进行周期延拓, 并且在幅度上乘因子$\frac{1}{T}$. </p><p>最后的说明, 在连续时间信号采样的数学表达中最后产生的是一个序列$x[n]$, 与$x_{c}(t)$有关系: </p><script type="math/tex; mode=display">x[n]=x_{c}(nT)</script><p>实际上$x[n]$是$x_{s}(t)$把冲激替换为冲激能量的大小数值, 并在时间上做归一化处理得到的. 这部分的更详细的说明可参考《离-奥》P.109~110</p><p>也就是说整个采样过程应该是这样的: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/sampling.PNG" style="zoom:30%" alt="采样过程" align=center /></p><hr><h1 id="离散时间信号采样"><a href="#离散时间信号采样" class="headerlink" title="离散时间信号采样"></a>离散时间信号采样</h1><p>即对序列的采样过程, 参考《信-奥》的7.4节与《离-奥》P.127内容. </p><p>离散时间信号的采样过程的框图应该是这样的:<br><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/sampling2.PNG" style="zoom:30%" alt="离散时间采样过程" align=center /></p><p>和连续时间采样一样, $x[n]$是待采样的序列, $P[n]$是用于采样的周期脉冲序列, $[n]$是一个周期脉冲序列, 周期为N（对应于连续时间的周期冲激串）, 而$x_{p}$是采样得到的序列, 有: </p><script type="math/tex; mode=display">x_{p}[n]=x[n]\cdot P[n]=\sum^{\infty}_{k=-\infty}x[kN]\delta[n-kN]</script><p>另外在时域上n为N的整数倍的点上$x[n]$与$x_{p}[n]$值相同: </p><script type="math/tex; mode=display">x_{p}[nN]=x[nN]</script><p>下面给出频域的分析, 由DTFT的相乘性质: </p><script type="math/tex; mode=display">X_{p}(e^{j\omega})=\frac{1}{2\pi}\int_{2\pi}P(e^{j\theta})X(e^{j(\omega-\theta)})\mathrm{d}\theta</script><p>时域乘积频域做周期卷积, 这一性质可参考《信-奥》P.247, DTFT的相乘性质. </p><p>我们已知周期脉冲序列$P[n]$的DTFT:</p><script type="math/tex; mode=display">P(e^{j\omega})=\frac{2\pi}{N}\sum^{\infty}_{k=-\infty}\delta(\omega-k\omega_{s}) \quad \quad\quad\omega_{s}=\frac{2\pi}{N}</script><p>上面的公式属于<strong>周期序列的DTFT</strong>, 所以引入了冲激函数, 这部分可参考《信-奥》P.236与《离-奥》P.443. 于是: </p><script type="math/tex; mode=display">\begin{align*}X_{p}(e^{j\omega}) &= \frac{1}{2\pi}\int_{2\pi}P(e^{j\theta})X(e^{j(\omega-\theta)})\mathrm{d}\theta \\&= \frac{1}{2\pi}\int_{2\pi} \left[ \frac{2\pi}{N}\sum^{\infty}_{k=-\infty}\delta(\theta-k\omega_{s})\right]X(e^{j(\omega-\theta)})\mathrm{d}\theta \\&= \frac{1}{N}\sum^{\infty}_{k=-\infty}X(e^{j(\omega-k\omega_{s})})\int_{2\pi}\delta(\theta-k\frac{2\pi}{N})\mathrm{d}\theta\end{align*}</script><p>这式子稍微有点难理解, 这里是无穷项求和, 每一项中k是确定的, 且都包含后面的积分项, 这个积分项先选定$2\pi$长的积分区间, 只有当$k\frac{2\pi}{N}$落在这个积分区间内时积分值为1, 否则积分值为0. 对于$2\pi$长的积分区间最多有N个k值下积分值不为0, 至于是哪N个k值关系不大, 因为$X(e^{j(\omega-k\omega_{s})})$对k来说是以N为周期的, 于是只需取N个连续k值即可, 比如从0到N-1, 即: </p><script type="math/tex; mode=display">X_{p}(e^{j\omega})=\frac{1}{N}\sum^{N-1}_{k=0}X(e^{j(\omega-k\omega_{s})}) \quad \quad\quad\omega_{s}=\frac{2\pi}{N}</script><p>如果把连续时间采样频域表达式拿过来做个对比: </p><script type="math/tex; mode=display">X_{s}(j\Omega)=\frac{1}{T}\sum^{\infty}_{k=-\infty}X_{c}(j(\Omega-k\Omega_{s}))\quad \quad\quad\Omega_{s}=\frac{2\pi}{T}</script><p>就会发现两式形式差别不大, 采样过程在频域都是对原信号频谱做周期搬移. 而且离散采样得到的就是序列, 不用像连续时间采样那样需要最后转换为离散序列. </p><hr><h1 id="离散时间信号抽取与内插"><a href="#离散时间信号抽取与内插" class="headerlink" title="离散时间信号抽取与内插"></a>离散时间信号抽取与内插</h1><p>在前一小节中得到的序列$x_{p}[n]$可以这样描述: <strong>在n为N的整数倍的点上的值与$x[n]$相同, 其他n值点都是0</strong>, 为了节省存储空间, 需要对$x_{p}[n]$进行压缩, 这里所进行的操作就是“抽取”, 而其逆过程则称为“内插”. </p><p>同样要弄清楚做这两种处理时域与频域的变化及混叠情况, 这部分参考《信-奥》P.353与《离-奥》P.127. </p><p>设对$x_{p}[n]$抽取后得到的序列为$x_{b}[n]$, 于是在时域上有$x_{b}[n]=x_{p}[nN]$（$x_{b}[n]$直接由$x_{p}[n]$N整数倍的点组成）, 又因为之前有$x_{p}[nN]=x[nN]$, 故: </p><script type="math/tex; mode=display">x_{b}[n]=x[nN]=x_{p}[nN]</script><p>然后寻找$x_{b}[n]$、$x_{p}[n]$与$x[n]$频域(DTFT)之间的关系, 推导过程可参考《信-奥》P.353~354. </p><p>首先$x_{b}[n]$的DTFT为: </p><script type="math/tex; mode=display">X_{b}(e^{j\omega})=\sum^{\infty}_{k=-\infty}x_{b}[k]e^{-j\omega k}</script><p>再利用$x_{b}[n]$与$x_{p}[n]$的关系: </p><script type="math/tex; mode=display">X_{b}(e^{j\omega})=\sum^{\infty}_{k=-\infty}x_{p}[kN]e^{-j\omega k}</script><p>做变量替换$n=kN$有$k=\frac{n}{N}$, 于是: </p><script type="math/tex; mode=display">X_{b}(e^{j\omega})=\sum_{n=N \text{的整数倍}}x_{p}[n]e^{-j\omega \frac{n}{N}}</script><p>因为n不为N的整数倍时$x_{p}[n]=0$,故可写为: </p><script type="math/tex; mode=display">X_{b}(e^{j\omega})=\sum^{\infty}_{n=-\infty}x_{p}[n]e^{-j\omega \frac{n}{N}}</script><p>把右边$\frac{n}{N}$看作整体, 右边即对$x_{p}[n]$的DTFT, 即: </p><script type="math/tex; mode=display">X_{p}(e^{j\frac{\omega}{N}})=\sum^{\infty}_{n=-\infty}x_{p}[n]e^{-j\omega \frac{n}{N}}</script><p>联立得到: </p><script type="math/tex; mode=display">X_{b}(e^{j\omega})=X_{p}(e^{j\frac{\omega}{N}})</script><p>之前由对序列采样, 我们已经得到了$x_{p}[n]$与$x[n]$的关系, 如下: </p><script type="math/tex; mode=display">X_{p}(e^{j\omega})=\frac{1}{N}\sum^{N-1}_{k=0}X(e^{j(\omega-k\omega_{s})}) \quad \quad\quad\omega_{s}=\frac{2\pi}{N}</script><p>至此就得到了这三个序列的频域联系, 可见抽取将导致频域扩展. 如果再把上面两式联立得到: </p><script type="math/tex; mode=display">X_{b}(e^{j\omega})=\frac{1}{N}\sum^{N-1}_{k=0}X(e^{j(\frac{\omega}{N}-k\omega_{s})}) \quad \quad\quad\omega_{s}=\frac{2\pi}{N}</script><p>上式后面会看到实际上就是采样率以N倍减小时得到的序列与原采样率下得到序列的频域关系. </p><p>下面是抽取在频域变化的例子:<br><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/sampling4.PNG" style="zoom:50%" alt="抽取频域变化" align=center /></p><p>下面是内插的说明, 内插是抽取的逆过程, 可以猜想频域变化为收缩. 参考《离-奥》P.131. </p><p>这里依旧设原序列为$x[n]$, 内插后序列为$x_{e}[n]$, 假设两者时域关系为: </p><script type="math/tex; mode=display">x_{e}[n]= \begin{cases} x[\frac{n}{L}] & n=0,\pm L,\pm 2L,\dots\\ 0 & \text{others}.\\ \end{cases}</script><p>上式即以L为间隔的内插, 实际上就是在序列$x[n]$每两个值之间插入$(L-1)$个零值. 上式的一种等效写法为: </p><script type="math/tex; mode=display">x_{e}[n]=\sum^{\infty}_{k=-\infty}x[k]\delta[n-kL]</script><p>这个式子可以这样理解: $x_{e}[n]$由无穷项相加构成, 只有当$n=kL$时, 那一项才不为0, 而是$x[\frac{n}{L}]$, 与之前的公式描述相同. </p><p>对$x_{e}[n]$做DTFT: </p><script type="math/tex; mode=display">\begin{align*}X_{e}(e^{j\omega})&= \sum^{\infty}_{n=-\infty} \left( \sum^{\infty}_{k=-\infty}x[k]\delta[n-kL]\right)e^{-j\omega n} \\&= \sum^{\infty}_{k=-\infty}x[k] \left(\sum^{\infty}_{n=-\infty} \delta[n-kL]e^{-j\omega n} \right)\\&= \sum^{\infty}_{k=-\infty}x[k] e^{-j\omega Lk} \\&= X(e^{-j\omega L}) \end{align*}</script><p>由此便得到了$x_{e}[n]$与$x[n]$在频域的关系式.<br>上式推导过程中用到了: </p><script type="math/tex; mode=display">\sum^{\infty}_{n=-\infty} \delta[n-kL]e^{-j\omega n}=e^{-j\omega Lk}</script><p>以上讨论了抽取与内插过程, 最后实现抽取的系统称为压缩器, 而实现内插的系统称为扩展器. </p><hr><h1 id="利用离散时间信号处理实现重采样"><a href="#利用离散时间信号处理实现重采样" class="headerlink" title="利用离散时间信号处理实现重采样"></a>利用离散时间信号处理实现重采样</h1><p>这个问题可以看作是之前讨论的抽取与内插的应用, 说的是运用这两种技术实现对原连续时间信号的采样率, 称之为重采样. 需要注意的是<strong>改变的是对连续时间信号采样率</strong>. 这其中涉及用抽取实现的减采样与用内插实现的增采样两部分. </p><p>之前讨论过对连续信号$x_{c}(t)$以<strong>周期T</strong>采样最终将得到序列$x[n]$, 他们之间的关系为: </p><script type="math/tex; mode=display">x[n]=x_{c}(nT)</script><p>所谓“改变采样率”就是说换成<strong>周期为$T_{1}$</strong>去采样, 这样势必会得到一个新的采样序列记为$x_{1}[n]$, 有: </p><script type="math/tex; mode=display">x_{1}[n]=x_{c}(nT_{1})</script><p>现在的问题是$x_{c}[n]$是未知的, $x[n]$已知, 而去求另一个采样率下对$x_{c}(t)$采样得到的序列$x_{1}[n]$, 解决问题的办法通常有两种, 一是先由$x[n]$重构出$x_{c}(t)$, 再调整以周期$T_{1}$重新进行采样得到$x_{1}[n]$, 另一种方法则通过$x[n]$与$x_{1}[n]$的关系, 用离散时间信号处理的方式求得$x_{1}[n]$, 这是这里得重点. </p><p>下面先讨论减采样. 我们的目的还是推导出原采样率下得到的序列与降低采样率后采样得到的序列频域上的关系. </p><p>在降低采样率的情况下, 讨论重新设定采样率为原采样率$\frac{1}{M}$的这种情况. 比如新采样周期$T_{d}$是原周期T的M倍: </p><script type="math/tex; mode=display">T_{d}=MT</script><p>重采样得到的序列记作$x_{d}[n]$, 有: </p><script type="math/tex; mode=display">x_{d}[n]=x_{c}(nT_{d})=x_{c}(nMT)</script><p>利用$x[n]=x_{c}(nT)$, 于是找到两采样序列之间的关系: </p><script type="math/tex; mode=display">x_{d}[n]=x[nM]</script><p>这个时域关系之前刚讨论过, $x_{d}[n]$就是$x[n]$以M抽取得到的, 两者频域关系的表达式在抽取那里已经给出, 这里以M抽取, 故: </p><script type="math/tex; mode=display">X_{d}(e^{j\omega})=\frac{1}{M}\sum^{M-1}_{k=0}X(e^{j(\frac{\omega}{M}-k\frac{2\pi}{M})})</script><p>此式完整的推导过程可参考《离-奥》P.128. </p><hr><h2 id="一个补充"><a href="#一个补充" class="headerlink" title="一个补充"></a>一个补充</h2><p>这里有一个之前一直没想通的地方, 就是之前讨论是这样一个过程:<br><strong>$x[n]$是以周期为T对$x_{c}(t)$采样得到的, 然后是序列的采样过程, 假设采样周期为$N_{1}$, 得到$X_{p}[n]$. 最后对$x_{p}[n]$以比如$N_{2}$抽取, 得$x_{b}[n]$</strong>, 故这些序列在在频域得关系为: </p><script type="math/tex; mode=display">X_{p}(e^{j\frac{\omega}{N_{1}}})=\sum^{\infty}_{n=-\infty}x_{p}[n]e^{-j\omega \frac{n}{N_{1}}}</script><script type="math/tex; mode=display">X_{b}(e^{j\omega})=X_{p}(e^{j\frac{\omega}{N_{2}}})</script><p>联立得: </p><script type="math/tex; mode=display">X_{b}(e^{j\omega})=\frac{1}{N_{1}}\sum^{N_{1}-1}_{k=0}X(e^{j(\frac{\omega}{N_{2}}-k\frac{2\pi}{N_{1}})})</script><p>这与前面$X_{d}(e^{j\omega})$对比, 会发现如果有$N_{1}=N_{2}=M$时, 两者完全相等. 这个等式成立是合理的, 事实上在推导的时候也是默认成立的, 不然就失去了意义. </p><p>另一点要注意的是对$x[n]$以N抽取与对$x_{p}[n]$以N抽取得到的序列相同, 都是$x_{b}[n]$, 因为抽取操作只关心n为N整数倍的那些点. </p><p>以上所有讨论的序列关系如下图: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/sampling5.PNG" style="zoom:30%" alt="序列关系" align=center /></p><hr><p>接下来是减采样系统的构成: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/sampling6.PNG" style="zoom:30%" alt="减采样系统" align=center /></p><p>可见系统除了一个实现抽取操作的压缩器外还有个抗混叠滤波器, 这个滤波器的主要作用是把$x[n]$的频域截断到$\frac{\pi}{M}$, 因为进行以M为周期的抽取等效于对频域扩展M倍, 要不发生混叠, 压缩器输入信号带宽最大就是$\frac{\pi}{M}$. </p><p>同样对于增采样过程, 若以L倍增加采样率, 实际上可以通过对$x[n]$以L内插得到采样序列$x_{e}[n]$. 之前得到他们在频域上: </p><script type="math/tex; mode=display">X_{e}(e^{j\omega})=X(e^{j\omega L})</script><p>而增采样系统一般为:<br><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/sampling7.PNG" style="zoom:23%" alt="减采样系统" align=center /></p><p>可以看到除了一个实现内插的扩展器外还有一个低通滤波器, 这个低通滤波器是必须的. </p><p>一方面, 增益为L进行幅度调整, 对于以周期为T进行采样得到的序列$x[n]$, 在频域幅度是被采样信号的$\frac{1}{T}$, 故若将将采样周期改变为$\frac{T}{L}$, 应把幅度也调整为$\frac{L}{T}$, 而之前减采样过程的频域表达式中本身就会乘以因子$\frac{1}{M}$, 将$\frac{1}{T}$调整为$\frac{1}{MT}$, 因此不需要滤波器再对幅度进行调整. </p><p>另一方面经过$\frac{\pi}{L}$的低通滤波器后, 能滤除频谱多余部分, 使剩下来的部分以$2\pi$为周期. </p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文首先回顾了连续时间信号的采样过程与数学表达, 然后将采样的概念引到序列处理, 讨论了序列采样过程. 由于离散时间信号存取与处理特点, 引出序列的抽取与插值操作, 最后讨论利用抽取与插值实现改变采样率这一应用. </p><p>这里所讨论的采样都是时域的采样, 实际上在采样这块另一个重要的内容是对傅里叶变换的采样（频域的采样）, 特别在离散时间信号处理中对DTFT、DFT的采样, 这些内容对于理解另一类按频率抽取的FFT算法是必要的.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> 信号处理 </category>
          
          <category> DSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFT </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用LaTeX绘图</title>
      <link href="/latextikz/"/>
      <url>/latextikz/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/fft_16.PNG"  style="zoom:60%" alt="" align=center /></p><p>之前有朋友问我如何使用$\LaTeX$绘图. </p><span id="more"></span><p>之前我写文章通常是使用绘图工具先保存为图片格式, 然后再插入文章的. 了解了下发现Latex可以使用TikZ宏包来进行绘制, 功能很强大, 函数图像、统计图、各类流程图都不在话下, 甚至是复杂信号流图如FFT的蝶形图也能简单地画出来, 这里放个绘制实例供参考. </p><p>TikZ一般与PGF宏包一起使用, 两者是上层封装与底层实现的关系. 学习的途径无疑是查阅参考文档与模仿例子, 在<a href="http://pgf.sourceforge.net/">这里</a>可以下载到TikZ与PGF完整参考文档, 而在<a href="http://www.texample.net/tikz/examples/">这里</a>能看到丰富的应用, 另外在一些问答社区如<a href="https://tex.stackexchange.com/search?q=tikz">这里</a>可以找到一些实用的使用技巧. </p><p>TikZ的参考文档虽然有1000多页, 但对于简单应用, 参看前面几个应用的Tutorial就够了. 但如果你是个完美主义者或是有强迫症, 那么这又会是一个天坑！TikZ是一个复杂的“所思即所得”的绘制系统, 相对于同样强大的Visio来说. </p><p>下面是一个如何绘制流程图的例子. 完成后大概是这个样子:<br><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/fftt.png"  style="zoom:50%" alt="" align=center /></p><p>首先需要加载TikZ宏包以及绘图需要用到的库.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%------------------------------------- TIKZ --------------------</span><br><span class="line">\usepackage&#123;tikz&#125;%画图</span><br><span class="line">    \usetikzlibrary&#123;graphs,arrows,shapes,chains,quotes&#125;</span><br><span class="line">%------------------------------------- TIKZ END-----------------</span><br></pre></td></tr></table></figure></p><p>然后实际的绘图是在<strong>tikzpicture</strong>环境中进行的, 就像figure环境一样. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;tikzpicture&#125;[环境及元素设定]</span><br><span class="line">...</span><br><span class="line">绘图语句</span><br><span class="line">...</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br></pre></td></tr></table></figure><p>绘制流程图的过程大概是这样的: 首先你需要先设定一些元素及基本的环境, 比如矩形框、菱形框、各类符号等等；然后是在图中定位他们, 定位的方法有很多, 由于我们要化的图像比较规则, 这里使用<strong>\matrix</strong>的定位方法；最后是连接与标注, 同样有很多方法, 怎么方便怎么来就行了. </p><p>元素及环境的设定写在[]中实现起来大概是这样: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;tikzpicture&#125;[</span><br><span class="line">    %inner sep=2mm, %边框到形状内字符距离</span><br><span class="line">    &gt; = stealth, %箭头样式</span><br><span class="line">    -&gt; /.style=&#123;thick ,black&#125;,</span><br><span class="line">    -- /.style=&#123;thick ,black&#125;,</span><br><span class="line">    line width=1pt,%连接线宽</span><br><span class="line">    every edge quotes/.style=&#123;font=\tiny,auto&#125;, %标注样式</span><br><span class="line">    every node/.style=&#123;font=\tiny&#125;,</span><br><span class="line">    point/.style=&#123;inner sep=0pt&#125;, %point样式</span><br><span class="line">    terminal/.style=&#123;circle,draw,thin,inner sep=0pt&#125;, %terminal样式</span><br><span class="line">    rect/.style=&#123;rectangle,draw,thick,inner sep=0pt,minimum size=6mm,font=\itshape&#125;, %rect样式</span><br><span class="line">    plus/.style=&#123;circle,draw,thick,inner sep=-1pt&#125;, %plus样式</span><br><span class="line">    hv path/.style=&#123;to path=&#123;-| (\tikztotarget)&#125;&#125;, %直角折线样式</span><br><span class="line">    vh path/.style=&#123;to path=&#123;|- (\tikztotarget)&#125;&#125;</span><br><span class="line">]</span><br><span class="line">...</span><br><span class="line">元素定位语句</span><br><span class="line">连接与标注语句</span><br><span class="line">...</span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在“元素定位语句”处使用<strong>\matrix</strong>进行排布元素, 使用matrix的语法和\begin{aligned}类似: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">%流程图骨架</span><br><span class="line">%       t1    p2    r1    r2    pl1    t2</span><br><span class="line">   %             r3                r4</span><br><span class="line">   %             p4    r5    r6    p5</span><br><span class="line"></span><br><span class="line">   \matrix[row sep=5mm,column sep=10mm]&#123;</span><br><span class="line">       \node (t1) [terminal] &#123;&#125;; &amp; </span><br><span class="line">       \node (p2) [point] &#123;&#125;; &amp; </span><br><span class="line">       \node (r1) [rect] &#123;$\downarrow 2$&#125;; &amp; &amp;</span><br><span class="line">       \node (r2) [rect] &#123;$\uparrow 2$&#125;; &amp; </span><br><span class="line">       \node (pl1) [plus] &#123;$+$&#125;; &amp;</span><br><span class="line">       \node (t2) [terminal] &#123;&#125;; &amp; \\</span><br><span class="line">       %------------------------------------------</span><br><span class="line">       &amp; \node (r3) [rect] &#123;左移1&#125;; &amp; &amp; &amp; &amp; \node (r4) [rect] &#123;右移1&#125;; \\</span><br><span class="line">       %------------------------------------------</span><br><span class="line">       &amp; \node (p4) [point] &#123;&#125;; &amp;</span><br><span class="line">         \node (r5) [rect] &#123;$\downarrow 2$&#125;; &amp; &amp;</span><br><span class="line">         \node (r6) [rect] &#123;$\uparrow 2$&#125;; &amp; </span><br><span class="line">         \node (p5) [point] &#123;&#125;; &amp; \\</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   连接与标注语句</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时看起来应该是这个效果:<br><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/tikz.PNG"  style="zoom:50%" alt="" align=center /></p><p>其中的\node是非常常用的命令, 可以用于放置元素与标签. ()中为node别名（在其他地方可以使用别名调用相应元素）；[]中为node属性, 可以设定之前定义的各种元素样式；{}中为node内部的字符串, 比如某个被定义为矩形框的node中的字符串, 支持使用Latex的数学公式的插入. 更详细的说明参考文档. </p><p>流程图中的连接与标注往往是同时进行的. 标注分为两种, 一种是在连接线上, 另一种是需要定位到某个固定的点. 连接这里使用<strong>\graph</strong>命令, 这里需要两条通路, 顺便可以在<strong>quotes</strong>库的帮助下完成线上标注. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\graph[use existing nodes]&#123;</span><br><span class="line">    t1  -&gt; </span><br><span class="line">    r1 -&gt;[&quot;$g[n]=x[2n]$&quot;,&quot;$G(e^&#123;j\omega&#125;)$&quot;&#x27;] </span><br><span class="line">    r2 -&gt; </span><br><span class="line">    pl1 -&gt; t2;</span><br><span class="line"></span><br><span class="line">    t1 -&gt;[hv path] </span><br><span class="line">    r3 -&gt;[vh path] </span><br><span class="line">    r5 -&gt;[&quot;$h[n]=x[2n+1]$&quot;,&quot;$H(e^&#123;j\omega&#125;)$&quot;&#x27;] </span><br><span class="line">    r6 -&gt;[hv path]</span><br><span class="line">    r4 -&gt;[&quot;$x[x-1]$&quot; right] pl1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>特殊点的标注使用<code>\node</code>: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\node [above] at (t1) &#123;$x[n]$&#125;;</span><br><span class="line">\node [above] at (t2) &#123;$x[n]$&#125;;</span><br><span class="line">\node [below] at (p4) &#123;$x[n+1]$&#125;;</span><br><span class="line">\node [below] at (p5) &#123;$0\leqslant n\leqslant N-1$&#125;;</span><br></pre></td></tr></table></figure><p>呼, 这样就完成了. </p><p>在TizK的帮助下能轻松绘出FFT的蝶形流图, 我从这个<a href="http://www.texample.net/tikz/examples/radix2fft/">例子</a>中得到了帮助. 下面是完整16点FFT蝶形图的实现code. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usetikzlibrary&#123;arrows,graphs,decorations.markings&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\pagestyle&#123;empty&#125;</span><br><span class="line"></span><br><span class="line">% 辅助计数器</span><br><span class="line">\newcounter&#123;x&#125;</span><br><span class="line">\newcounter&#123;y&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;tikzpicture&#125;[</span><br><span class="line">    yscale=.5, </span><br><span class="line">    xscale=1.5, </span><br><span class="line">    %node distance=1cm, </span><br><span class="line">    auto,</span><br><span class="line">    &gt; = stealth,</span><br><span class="line">    -&gt; /.style=&#123;thick, black&#125;,</span><br><span class="line">    -- /.style=&#123;thick, black&#125;,</span><br><span class="line">    -&gt;-/.style=&#123;decoration=&#123;</span><br><span class="line">  markings,</span><br><span class="line">  mark=at position #1 with &#123;\arrow&#123;&gt;&#125;&#125;&#125;,</span><br><span class="line">  postaction=&#123;decorate&#125;&#125;,</span><br><span class="line">  n/.style=&#123;</span><br><span class="line">  circle, </span><br><span class="line">  draw, </span><br><span class="line">  minimum size=2pt, </span><br><span class="line">  inner sep=0pt, </span><br><span class="line">  outer sep=0pt&#125;,</span><br><span class="line">    ]</span><br><span class="line">    % The strategy is to create nodes with names: N-column-row -&gt; N-列-行</span><br><span class="line"></span><br><span class="line">    %----------------------- 输入输出 -------------------------------------------------------</span><br><span class="line">    % 输入结点命名规则 N-0-0 ... N-0-15</span><br><span class="line">    % 输出结点命名规则 N-8-0 ... N-8-15</span><br><span class="line">    % Draw inputs</span><br><span class="line">    \foreach \y in &#123;0,...,15&#125;</span><br><span class="line">        \node[n,pin=&#123;[pin edge=&#123;&lt;-&#125;]left:$x[\y]$&#125;] </span><br><span class="line">            (N-0-\y) at (0,-\y) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    % Draw outputs \y计数  idx显示</span><br><span class="line">    \foreach \y / \idx in &#123;0/0,1/8,2/4,3/12,4/2,5/10,6,7/14,</span><br><span class="line">                           8/1,9,10/5,11/13,12/3,13/11,14/7,15&#125;</span><br><span class="line">        \node[n, pin=&#123;[pin edge=&#123;-&gt;&#125;]right:$X[\idx]$&#125;] (N-8-\y) at (6,-\y) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">   %-------------------------- 画连接点 ---------------------------------------------------</span><br><span class="line">   %     0      1   2 3   4 5   6   7     8</span><br><span class="line">   %     in     o - o o - o o - o - o     out</span><br><span class="line"></span><br><span class="line">   % 7个中间连接点</span><br><span class="line">    \foreach \y in &#123;0,...,15&#125;</span><br><span class="line">        \foreach \x / \c in &#123;1/1, 1.5/2, 2.5/3, 3/4, 4/5, 4.5/6, 5.5/7&#125;</span><br><span class="line">            \node[n] (N-\c-\y) at (\x,-\y) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    %----------------------- 画连接线 -----------------------------------------------------</span><br><span class="line">    % 水平线连接</span><br><span class="line"></span><br><span class="line">    \foreach \y in &#123;0,...,15&#125;%行</span><br><span class="line">        \foreach \x in &#123;0,2,4,6&#125;%列</span><br><span class="line">        &#123;</span><br><span class="line">            \setcounter&#123;x&#125;&#123;\x&#125;\stepcounter&#123;x&#125;</span><br><span class="line">            \path (N-\x-\y) edge[-&gt;-=.87] (N-\arabic&#123;x&#125;-\y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    \foreach \y in &#123;0,...,15&#125;%行</span><br><span class="line">        \foreach \x in &#123;1,3,5,7&#125;%列</span><br><span class="line">        &#123;</span><br><span class="line">            \setcounter&#123;x&#125;&#123;\x&#125;\stepcounter&#123;x&#125;</span><br><span class="line">            \path (N-\x-\y) edge[-&gt;-=.5] (N-\arabic&#123;x&#125;-\y);</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">    % 斜线连接</span><br><span class="line">    \foreach \sourcey / \desty in &#123;0/8,1/9,2/10,3/11,</span><br><span class="line">                                   4/12,5/13,6/14,7/15,</span><br><span class="line">                                   8/0,9/1,10/2,11/3,</span><br><span class="line">                                   12/4,13/5,14/6,15/7&#125;</span><br><span class="line">       \path (N-0-\sourcey) edge[-&gt;-=.04] (N-1-\desty);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    \foreach \sourcey / \desty in &#123;0/4,1/5,2/6,3/7,</span><br><span class="line">                                   4/0,5/1,6/2,7/3,</span><br><span class="line">                                   8/12,9/13,10/14,11/15,</span><br><span class="line">                                   12/8,13/9,14/10,15/11&#125;</span><br><span class="line">        \path (N-2-\sourcey) edge[-&gt;-=.97] (N-3-\desty);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    \foreach \sourcey / \desty in &#123;0/2,1/3,2/0,3/1,</span><br><span class="line">                                   4/6,5/7,6/4,7/5,</span><br><span class="line">                                   8/10,9/11,10/8,11/9,</span><br><span class="line">                                   12/14,13/15,14/12,15/13&#125;</span><br><span class="line">        \path (N-4-\sourcey) edge[-&gt;-=.95] (N-5-\desty);</span><br><span class="line"></span><br><span class="line">    \foreach \sourcey / \desty in &#123;0/1,1/0,2/3,3/2,</span><br><span class="line">                                   4/5,5/4,6/7,7/6,</span><br><span class="line">                                   8/9,9/8,10/11,11/10,</span><br><span class="line">                                   12/13,13/12,14/15,15/14&#125;</span><br><span class="line">        \path (N-6-\sourcey) edge[-&gt;-=.3] (N-7-\desty);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    %----------------------- 标注旋转因子 -----------------------------------------------</span><br><span class="line"></span><br><span class="line">    % W_16</span><br><span class="line">    \setcounter&#123;y&#125;&#123;8&#125;</span><br><span class="line">    \foreach \i in &#123;0,...,7&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        \path (N-1-\arabic&#123;y&#125;) edge[-&gt;-=.5] node &#123;\tiny $W^&#123;\i&#125;_&#123;16&#125;$&#125; (N-2-\arabic&#123;y&#125;);</span><br><span class="line">        \node[below] at (N-1-\arabic&#123;y&#125;.south) &#123;\tiny -1&#125;;</span><br><span class="line">        \stepcounter&#123;y&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    % W_8</span><br><span class="line">    \setcounter&#123;y&#125;&#123;4&#125;</span><br><span class="line">    \foreach \j in &#123;1,2&#125;</span><br><span class="line">    &#123;</span><br><span class="line">    \foreach \i in &#123;0,2,4,6&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        \path (N-3-\arabic&#123;y&#125;) edge[-&gt;-=.5] node &#123;\tiny $W^&#123;\i&#125;_&#123;16&#125;$&#125; (N-4-\arabic&#123;y&#125;);</span><br><span class="line">        \node[below] at (N-3-\arabic&#123;y&#125;.south) &#123;\tiny -1&#125;;</span><br><span class="line">        \stepcounter&#123;y&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    \addtocounter&#123;y&#125;&#123;4&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    % W_4</span><br><span class="line">    \setcounter&#123;y&#125;&#123;2&#125;</span><br><span class="line">    \foreach \j in &#123;1,...,4&#125;</span><br><span class="line">    &#123;</span><br><span class="line">    \foreach \i in &#123;0,4&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        \path (N-5-\arabic&#123;y&#125;) edge[-&gt;-=.5] node &#123;\tiny $W^&#123;\i&#125;_&#123;16&#125;$&#125; (N-6-\arabic&#123;y&#125;);</span><br><span class="line">        \node[below] at (N-5-\arabic&#123;y&#125;.south) &#123;\tiny -1&#125;;</span><br><span class="line">        \stepcounter&#123;y&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    \addtocounter&#123;y&#125;&#123;2&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    % W_2</span><br><span class="line">    \setcounter&#123;y&#125;&#123;1&#125;</span><br><span class="line">    \foreach \j in &#123;1,...,8&#125;</span><br><span class="line">    &#123;</span><br><span class="line">    \foreach \i in &#123;0&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        \path (N-7-\arabic&#123;y&#125;) edge[-&gt;-=.5] node &#123;\tiny $W^&#123;\i&#125;_&#123;16&#125;$&#125; (N-8-\arabic&#123;y&#125;);</span><br><span class="line">        \node[below] at (N-7-\arabic&#123;y&#125;.south) &#123;\tiny -1&#125;;</span><br><span class="line">        \stepcounter&#123;y&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    \addtocounter&#123;y&#125;&#123;1&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">\end&#123;tikzpicture&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
          <category> LaTeX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
            <tag> TikZ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《语法俱乐部》笔记 3.高级篇</title>
      <link href="/grammarclub3/"/>
      <url>/grammarclub3/</url>
      
        <content type="html"><![CDATA[<p>这次总算把高级篇的内容整理出来了, 顺带重新整理了下另外几篇的排版. </p><p>在这本书的高级部分主要讨论了之前中级篇中三种复句的简化方法, 以及常用的特殊句型, 比如倒装句的用法. </p><span id="more"></span><h1 id="从句简化通则"><a href="#从句简化通则" class="headerlink" title="从句简化通则"></a>从句简化通则</h1><p>省略主语与be动词, 只留补语. </p><p>可能面临的问题</p><ul><li>1.若省略从属从句的主语会造成主语不清时该如何处理？</li><li>2.剩下补语部分如果词类与原来从属从句词类不同时怎么办？</li><li>3.连接词是否应一并省略？</li></ul><h2 id="为何省略从句主语？"><a href="#为何省略从句主语？" class="headerlink" title="为何省略从句主语？"></a>为何省略从句主语？</h2><p>如果从句主语是空的字眼(one,everybody,people等), 或者从句主语在主句中重复出现, 从修辞的角度, 有违精简的原则. 如: </p><ul><li>It is common courtesy (that one should wear black while one attends a funeral(葬礼).)<br>→It is common courtesy to wear black while attending a funeral.</li></ul><p>这里one should wear black→[ought] to wear black,去掉主语should变成了不定式. </p><h2 id="为何省略be动词？"><a href="#为何省略be动词？" class="headerlink" title="为何省略be动词？"></a>为何省略be动词？</h2><p>在简单句的5种基本句型中, 有4种都是通过动词来描述主语在干什么. 如</p><ul><li>Birds fly.→S+V</li><li>Birds eat worms.→S+V+O</li><li>Birds give us song.→S+V+O+O</li><li>Birds make the morning beautiful.→S+V+O+C</li></ul><p>至于S+V+C由于系动词（尤其是be动词）不能描述具体特性, 反而要靠后来的补语来做全部的叙述, 告诉别人主语怎么样. 而be动词只扮演串联主语与补语的角色, 故世称之为系动词. 如</p><ul><li>Birds are lovely.</li></ul><p>试想如果Birds are lovely是一个从句, Birds与主句主语重复, 那么只需留下lovely即可. 而重复的主语与be动词则是多余的. </p><p>因此为何省略be动词呢？简单来说就是因为没有具体的含义, 省略不会影响表达. </p><h2 id="没有be动词的时候怎么办？"><a href="#没有be动词的时候怎么办？" class="headerlink" title="没有be动词的时候怎么办？"></a>没有be动词的时候怎么办？</h2><p>如果没有be动词, 分两种情况处理: </p><p><strong>1.有语气助动词时可以变成不定式</strong></p><p>这是因为所有语气助动词（情态动词）都可以改写成<strong>be+不定式</strong>,如</p><ul><li><p>You must go at once.<br>→You are to go at once.</p></li><li><p>The train will leave in 10 minutes.<br>→The train is to leave in 10 minutes.</p></li><li><p>He should do as I say.<br>→He is to do as I say.</p></li></ul><p>助动词改写为be加不定式, 表达的意思可能不如原来精准. 这算是为简洁所做的牺牲. </p><ul><li>He studied hard so that he could get a scholarship.<br>could geta→was [able] to get→省略was→to get a scholarship</li><li>→He studied hard to get a scholarship.</li></ul><p>修饰以趋于原意</p><p>→He studied hard so as to get a scholarship.<br>→He studied hard in order to get a scholarship.</p><p><strong>2.没有助动词时, 变为ving</strong><br>如</p><ul><li>John remembers that he saw the lady before.<br>he was seeing the lady before.</li></ul><p>→John remembers seeing the lady before.</p><hr><p>下面分不同复句讨论如何简化的细节. </p><h1 id="关系从句的简化"><a href="#关系从句的简化" class="headerlink" title="关系从句的简化"></a>关系从句的简化</h1><p>在前面讨论关系从句的时候也简单讨论过他的简化方法, 即如果关系词充当从句的宾语部分, 则可省略关系词. </p><ul><li>1.<strong>The man</strong> is here.</li><li>2.You asked about <strong>him</strong>.</li></ul><p>→The man whom you asked about is here.<br>简化<br>→The man you asked about is here.</p><p>关系词的省略只能算是一般性的省略, 从句中仍有主语、动词, 所以不算是真正的简化从句. 如果主从句相同, 那么省略主语与be动词就是典型的形容词简化. </p><p>以下就简化之后所留下的不同补语分别讨论. </p><h2 id="补语为过去分词-ven"><a href="#补语为过去分词-ven" class="headerlink" title="补语为过去分词(ven)"></a>补语为过去分词(ven)</h2><p>如果关系从句中是被动态, 就会简化成为过去分词的补语部分. </p><p>如</p><ul><li>1.Beer is most delicious.</li><li>2.It is chilled to 6℃.</li></ul><p>→Beer <strong>which is chilled to 6℃</strong> is most delicious.<br>简化<br>→Beer <strong>chilled to 6℃</strong> is most delicious.<br>分词属于形容词类, 词类无冲突. </p><p>又如</p><ul><li>Your brothor John, who was wounded in war, will soon be sent home.</li></ul><p>→Your brothor John, wounded in war, will soon be sent home.</p><hr><h2 id="补语为现在分词-ving"><a href="#补语为现在分词-ving" class="headerlink" title="补语为现在分词(ving)"></a>补语为现在分词(ving)</h2><p>如果关系从句中动词是be+ving的形式, 只要省略主语与be动词即可. 如</p><ul><li>The ship <strong>which is coming to shore</strong> is from Gaoxiong.</li></ul><p>→The ship <strong>coming to shore</strong> is from Gaoxiong.</p><hr><h2 id="补语为to-do"><a href="#补语为to-do" class="headerlink" title="补语为to do"></a>补语为to do</h2><p>如果关系从句的动词有语气助动词存在, 就会成为不定词补语留下来.<br>如</p><ul><li>John is the one who should go this time.<br>→who is to go</li><li>→John is the one to go this time.</li></ul><p>简化时注意的问题:<br><strong>1.不定式的主动、被动区分清楚. </strong><br><strong>2.不定式有无宾语判断. </strong><br>如</p><ul><li>1.This is exactly the thing to do.</li><li>2.This is exactly the time to do it.</li></ul><p>第一句可视为是:<br>This is exactly <strong>the thing</strong>.<br>We should do <strong>the thing</strong>.<br>这两句话的复句简化</p><p>第二句可视为是:<br>This is exactly <strong>the time</strong>.<br>We should do it <strong>at this time</strong>.<br>复句的简化</p><p><strong>3.不定式后有无介词的判断. </strong><br>如</p><ul><li>1.He will be the toughest <strong>guy</strong>.</li><li>2.You must deal with <strong>the guy</strong>.</li></ul><p>→He will be the toughest guy [whom] you must deal with.<br>→He will be the toughest guy to deal with.</p><p><strong>4.从句主语省略意思是否改变</strong><br>如</p><ul><li>I have a job that your brother can do.</li></ul><p>若省略从句主语, 则变成 I have a job to do. 改变了原意.<br>这时可以用合适的介词短语插入主语, 如: </p><ul><li>I have a job for your brother to do.</li></ul><h2 id="补语为一般形容词"><a href="#补语为一般形容词" class="headerlink" title="补语为一般形容词"></a>补语为一般形容词</h2><p>若关系从句的动词是be动词, 后面是单纯的形容词类做补语, 可以直接简化主语和be动词.<br>如: </p><ul><li>Hilary Clinton, <strong>who is pretty and intelligent</strong>, is a popular First Lady.<br>→Hilary Clinton, <strong>pretty and intelligent</strong>, is a popular First Lady.</li></ul><p>形容词一般只有两种位置: 名词短语中及补语位置, 如果两位置都不是, 那么多半是简化形容词从句的残留补语. </p><hr><h2 id="补语为名词"><a href="#补语为名词" class="headerlink" title="补语为名词"></a>补语为名词</h2><p>依旧只需省略主语与be动词, 让补语名词做同位语. 如: </p><ul><li>Bill Clinton, who is President of the U.S., is a Baby Boomer.<br>→Bill Clinton, President of the U.S., is a Baby Boomer.</li></ul><hr><h1 id="名词从句的简化"><a href="#名词从句的简化" class="headerlink" title="名词从句的简化"></a>名词从句的简化</h1><p>名词从句与之前所讲的关系从句十分类似, 能够省去从句主语与be动词, 连接词that也可以一并省略. 若名词从句由疑问句演变而来, 以疑问词充当连接词, 那么疑问词需要保留, 因为是有明确意义的字眼. </p><p>名词从句简化之后, 剩下来的补语常见有ving与to do（动名词与不定式）皆可作为名词使用, 故词类无冲突. 而如果是动词分词, 就需要在词类上进一步改造. </p><h2 id="补语是ving的情况"><a href="#补语是ving的情况" class="headerlink" title="补语是ving的情况"></a>补语是ving的情况</h2><p>处理与关系从句完全一样. 如: </p><ul><li><strong>That I drink good wine with friends</strong> is my greatest enjoyment.<br>→<strong>Drinking good wine with friends</strong> is my greatest enjoyment.</li></ul><p>换个宾语的例子: </p><ul><li>Many husbands enjoy <strong>that they do the cooking</strong>.<br>→Many husbands enjoy <strong>doing the cooking</strong>.</li></ul><p>换个介词后宾语的例子: </p><ul><li>1.He got used to something.</li><li>2.He worked late into the night.</li></ul><p>第2句是第1句something的内容, 但由于语法中说that引导的从句不能作为介词宾语, 但可以简化之后再合在一起. </p><p>→He got used to working late into the night.</p><hr><p>前面说的是一般情况, 有下面几种常见的特殊情况: </p><h3 id="主语不能省略时"><a href="#主语不能省略时" class="headerlink" title="主语不能省略时"></a>主语不能省略时</h3><p>这种情况一般是主从句主语不一致引起的. </p><p><strong>1.试着将整个句子改写成S+V+O+C的句型. 此时需要名词从句在宾语位置, 且主句动词能适用该句型</strong>. 如</p><ul><li>I imagined <strong>that a beautiful girl was singing to me</strong>.</li></ul><p>主从句主语不同, 不能直接省略, 但还是可以省略be动词与that. </p><p>→I imagined a beautiful girl singsing to me.</p><hr><p><strong>2.使用所有格来处理</strong></p><ul><li><strong>That he calls my girlfriend every day</strong> is too much for me.</li></ul><p>这里he同样不能省略, 按照一般的简化流程, calling my grilfriend every day成为主句主语, 没有he的位置了, 此时可以把he变为所有格, 就能放在calling之前. </p><ul><li>His calling my girlfriend every day is too much for me.</li></ul><p><strong>3.加介词来处理</strong><br>只适合一些比较特殊的句型. </p><ul><li><p>I’m worried <strong>that my son lies all the time</strong>.<br>→I’m worried about my son’s lying all the time.<br>或</p></li><li><p>→I’m worried about my son lying all the time.</p></li></ul><h3 id="被动态的处理"><a href="#被动态的处理" class="headerlink" title="被动态的处理"></a>被动态的处理</h3><p>被动态中省略从句主语与be动词, 剩下动词被动态如改为过去分词是形容词类, 这里需要名词类, 只好另想办法. </p><ul><li>That anyone is called a liar(说谎者) is the greatest insult.</li></ul><p>如果按照之前所说的省略明显不对. 这里需要借用前面的be变成being,起名词的作用, 这里be纯粹只有词类变化的功能. </p><p>→Being called a liar is the greatest insult.</p><p>有时这里需要把被动动词改成相应动名词. </p><hr><h2 id="补语是to-do的情况"><a href="#补语是to-do的情况" class="headerlink" title="补语是to do的情况"></a>补语是to do的情况</h2><p>名词从句的简化, 若从句中有语气助动词, 就会成为不定式. 如: </p><ul><li>The children expect that they can get presents for Christmas.</li></ul><p>简化时先把助动词改写为be to形式. 成为</p><ul><li>The children expert to get presents for Chrismas.</li></ul><p>不定式不一定是什么词类, 可当名词、形容词、副词, 故可不必考虑词类是否符合的问题. 唯一需要注意的是, 不定式不合适放在介词后, 这时需要改为ving形式. </p><hr><p>这里同样也会有一些特殊情况. </p><h3 id="从句主语不能省略"><a href="#从句主语不能省略" class="headerlink" title="从句主语不能省略"></a>从句主语不能省略</h3><p>同样考虑可否变成S+V+O+C句型. 如</p><ul><li>1.I want that you should go.</li><li>→I want that you are to go.</li><li>→I want you to go.</li></ul><p>另外, 在大多情况可以添加介词, 将不能省略的从句主语放在其后. (P.347)</p><h3 id="疑问句改造而来的从句简化"><a href="#疑问句改造而来的从句简化" class="headerlink" title="疑问句改造而来的从句简化"></a>疑问句改造而来的从句简化</h3><p>其他类似, 只是充当引导词的疑问词不能省略. 如</p><ul><li>1.What should I do?</li><li>2.I don’t know the puestion.</li><li>→I don’t know <strong>what should I do</strong>.</li><li>→I don’t konw <strong>what to do</strong>.</li></ul><p>如果是一般疑问句, 如</p><ul><li>1.Should I vote for Mary?</li><li>2.I can’t decide the puestion.</li></ul><p>1句中没有疑问词, 需用whether引导. </p><ul><li>→I can’t decide whether I should vote for Mary [or not].</li><li>→I can’t decide whether to vote for Mary.</li></ul><hr><h1 id="插播-to-do与ving的再次比较"><a href="#插播-to-do与ving的再次比较" class="headerlink" title="插播 to do与ving的再次比较"></a>插播 to do与ving的再次比较</h1><p>前面在讲动状词的时候提到过, to do与ving都可做名词, 因此会用混, 也讲了一些他们的区别, 这里从简化从句的角度再谈谈他们的区别. </p><ul><li>He forgot <strong>that he should see his dentist</strong> that day.</li></ul><p>根据上面所说, 应简化为: </p><ul><li>→He forgot to see his dentist that day.</li></ul><p>而若原句为: </p><ul><li>He forgot that he saw the man before.</li></ul><p>没有be动词加ing, 简化为: </p><ul><li>He forgot seeing the man before.</li></ul><p>如果判断出名词从句中有不确定语气, 或者能看出原来应有助动词, 那么就能就能简化成不定式. </p><h1 id="副词从句的简化"><a href="#副词从句的简化" class="headerlink" title="副词从句的简化"></a>副词从句的简化</h1><p>同样, 先在此重复一下重要的观念: 所有从句简化的原则都一样, 即为求精简, 把从句中重复的主语与be动词省略, 只留下补语. 省略主语是为了避免重复, 如果省略会造成句意模糊错误, 主语就要另行处理；省略be动词是因为它本身没有任何意义. </p><h2 id="简化为ving补语时"><a href="#简化为ving补语时" class="headerlink" title="简化为ving补语时"></a>简化为ving补语时</h2><p>若从句是一般语法书中介绍的进行时, 那么省略主语与be动词后只剩ving补语. 若没有be动词, 也没有语气助动词可供改写, 那只能老办法, 先将从句改成进行时, 再进行简化. 如: </p><ul><li>While he was lying on the couch, the boy fell asleep.</li><li>→While lying on the couch, the boy fell asleep.</li></ul><h3 id="连接词是否需要省略"><a href="#连接词是否需要省略" class="headerlink" title="连接词是否需要省略"></a>连接词是否需要省略</h3><p>连接词有时不光起语法的作用, 还起语义的作用. 副词从句中连接词是否保留取决于修辞上是否清楚. </p><p>一般来说, while(包括when)表示“当…时”与because(包括so、since)表示“因为”时, 省略后不妨碍句子的清楚性, 但还是需要一个个句子去判断, 上例中的while便可省略. </p><p>知道从句简化, 便知道“分词构句”及传统语法中分词构句的由来. (P.361)<br>再举个需要改写的例子: </p><ul><li>Because we have nothing to do here, we might as well go home.</li></ul><p>首先观察从句中to do here其实是简化形容词从句来的, 原来是that we can do here修饰nothing. </p><ul><li>→Having nothing to do here, we might as well go home.</li></ul><p>注意, 这种修改并不是以变成进行时为最终目的, 而是为了进行词类变化, 使主语与be动词能够省略. </p><h3 id="关于连接词的省略再讨论"><a href="#关于连接词的省略再讨论" class="headerlink" title="关于连接词的省略再讨论"></a>关于连接词的省略再讨论</h3><p>这次看看不能省略的情况: </p><ul><li>Although we have nothing to do here, we can’t leave early.<br>→Although have nothing to do here, we can’t leave early.</li></ul><p>从句与主句有明显的“相反”的逻辑, 这需要Although才能表现清楚, 因此不宜省略, 这里保留Although仅仅是逻辑关系表达的需要, 当然也可以用其他词代替Although表达的逻辑. 再如: </p><ul><li>He raised his hand, as if he was trying to hit her.</li><li>→He raised his hand, as if trying to hit her.</li></ul><p>不宜省略as if. </p><h3 id="being的运用"><a href="#being的运用" class="headerlink" title="being的运用"></a>being的运用</h3><p>在某些需要的场合下, be需要以being的形式留下来. 如: </p><ul><li>As I am a student, I can’t afford to get married.</li></ul><p>按照上面全省略的话, 只剩a student, 读者无法判断这是个简化的副词从句而产生误解, 一个方法是保留连接词. 另一个方法是借用be动词改成being. </p><ul><li>→Being a student, I can’t afford to get married.</li></ul><p>因为有了Being, 能明显判断a student是补语. </p><h3 id="兼做介词的连接词before、after、since"><a href="#兼做介词的连接词before、after、since" class="headerlink" title="兼做介词的连接词before、after、since"></a>兼做介词的连接词before、after、since</h3><ul><li>Before he was in school, he used to be a naughty child.</li></ul><p>按以前说的省略后只剩in school,与原意相差很大, 原因在于省略了表示时间关系的before, 但若留下before变成为before in school也有问题, before在简化后会看成是介词, 后面只能接名词类, 因此使用being来进行词类变化, 即: </p><ul><li>Before being in school, he used to be a naughty child.</li></ul><p>before、after、since都兼有连接词与介词, 简化时会被视为介词, 以此进行词类判断. </p><h3 id="时态问题"><a href="#时态问题" class="headerlink" title="时态问题"></a>时态问题</h3><ul><li>After he wrote the letter, he put it to mail.<br>→After writing the letter, he put it to mail.</li></ul><p>这样简化是可以的, 如果省去After,读者会认为两个动作是同时发生的, 因为没有连接词, 会假设时间副词从句连接词是when. 所以如果要省略After,需要在时态上进行处理. </p><ul><li>→Having written the letter, he put it to mail.</li></ul><p>用完成式与简单式的对比交代写信在前, 其实该简单句也是下面这句的简化. </p><ul><li>When he had written the letter, he put it to mail.</li></ul><p>从中也可以看出, 连接词若是不能表达先后的when, 那么只能靠动词时态来表达. </p><h3 id="深入讨论从句主语的去留"><a href="#深入讨论从句主语的去留" class="headerlink" title="深入讨论从句主语的去留"></a>深入讨论从句主语的去留</h3><p>再讨论之前, 先谈谈副词从句简化与传统语法中“独立主格”的关系. </p><ul><li>The child already sleeping soundly in bed, her mother came to kiss her goodnight.</li></ul><p>传统语法中把这种保留从句主语的简化副词从句称为“独立主格”结构. 把already sleeping soundly in bed视为形容词短语看待, 修饰the child. 从句主语the child是非主句主语的独立存在, 故传统语法为了解决这个语法现象, 创造“独立主格”的说法. </p><p>另一方面, 如果从副词从句简化的角度看, 把从句主语留下来, 是为了保证句子的原意. </p><p>那么哪些情况应该保留主语呢？</p><p><strong>1.保留主语, 连接词必须要能省略</strong><br>简化从句一般是省略主语、be动词和连接词（视情况定）. 如果只是省略了be动词, 达不到简化的效果, 反而像是个病句. </p><p><strong>2.保留主语, 后面必须配合分词补语（现在分词/过去分词）, 如此才能看出是省略be动词的简化从句. </strong></p><p>如上一例The child sleeping soundly说明了the child是主语, sleeping soundly是补语, 省略了be动词与连接词, 形成简化副词从句. </p><h2 id="简化为ven时"><a href="#简化为ven时" class="headerlink" title="简化为ven时"></a>简化为ven时</h2><p>副词从句中原本是被动时态, 那么在省略后会剩下ven. 如: </p><ul><li>After he was shot in the knee, he couldn’t fight.<br>→Shot in the knee, he couldn’t fight.</li></ul><h3 id="老问题-连接词是否能够省略"><a href="#老问题-连接词是否能够省略" class="headerlink" title="老问题 连接词是否能够省略"></a>老问题 连接词是否能够省略</h3><p>上栗中的After可以省略, 原因在于shot是过去分词, 本身就表示“已经中枪”、“中枪之后”的完成时的暗示, 因而可以不要After一词. </p><p>但如果是Although带有“相反”的暗示, 省去后的意思会与原来有较大差别, 则要保留. </p><h3 id="如何应用having-been"><a href="#如何应用having-been" class="headerlink" title="如何应用having been"></a>如何应用having been</h3><ul><li>Because they had been warned, they proceeded carefully.</li></ul><p>这里动词had been warned有两种处理: </p><p>1.为了完整保留完成时“已经”的意味, 将其变为haing been<br>→Having been warned, they proceeded carefully.</p><p>2.另一种是省略had been, 只留warned.<br>→Warned, they proceeded carefully</p><p>因为warned是过去分词, 有完成的暗示, 省略had been影响不大.<br>总结起来就是, having been后面是动词过去分词, 就能进一步省略having been. </p><h3 id="从句主语去留"><a href="#从句主语去留" class="headerlink" title="从句主语去留"></a>从句主语去留</h3><p>副词从句简化为ven, 如果从句主语与主句主语不同, 就要把从句主语留下来. </p><ul><li>When the coffin had been interred, the minister said a few comforting words.<br>→The coffin [having been] interred, the minister said a few comforting words.</li></ul><h2 id="简化为to-do时"><a href="#简化为to-do时" class="headerlink" title="简化为to do时"></a>简化为to do时</h2><ul><li>He studied hard in order that he could get a scholarship.<br>→He studied hard in order to get a scholarship.</li></ul><h2 id="简化为单纯的be动词时"><a href="#简化为单纯的be动词时" class="headerlink" title="简化为单纯的be动词时"></a>简化为单纯的be动词时</h2><p><strong>be动词后是介词短语</strong></p><ul><li>When you are under attark, you must take cover immediately.<br>→When under attack, you must take cover immediately.</li></ul><p><strong>be动词后是形容词</strong></p><ul><li>While it is small in size, the company is very competitive.<br>→While small in size, the company is very competitive.</li></ul><p><strong>be动词后是名词</strong></p><ul><li>Although he was a doctor by training, Asimov became a writer.<br>→Although a doctor, Asimov become a writer.</li></ul><p>稍微总结下, 副词从句的连接词不同于名词从句或形容词从句, 是具有特定语义的连接词, 简化时常选择留下来, 那么它是由副词从句简化而成这一点就十分明显. </p><h2 id="再谈连接词的简化"><a href="#再谈连接词的简化" class="headerlink" title="再谈连接词的简化"></a>再谈连接词的简化</h2><p>副词从句的连接词有表达某种逻辑关系的意义. 简化时有一种特别的做法, 就是把连接词改为意义相近的介词, 整个从句简化为名词后作为介词宾语. </p><ul><li>Whe she arrived at the party, she found all the people gone.</li></ul><p>与when连接词接近的介词有on和upon. 上面的句子可改写为</p><ul><li>→Upon arriving at the party, she found all people gone.</li><li>→Upon her arrival at the party, she found all people gone.</li></ul><p>或是</p><ul><li>When she completed the project, she was promoted.<br>→Upon completing the project, she was promoted.</li></ul><p>但是这里把动词complete改为名词completion就会有问题, 原因在于这个动词有宾语, 改成名词后, 宾语没地方放了. 也有解决办法, 那就是再加个介词of处理. </p><ul><li>→Upon completion of the project, she was promoted.</li></ul><h1 id="倒装句"><a href="#倒装句" class="headerlink" title="倒装句"></a>倒装句</h1><p>这部分内容在书的423页, 主要介绍了倒装句这种特殊结构使用的情况. </p><p>倒装句是一种把动词（或助动词）移到主语前面的句型. 从这个定义看, 一般的疑问句都可以算是倒装句. </p><p>撇开疑问句这种具有语法功能的倒装句不谈, 比较值得研究的是具有修辞功能的倒装句. 恰当地使用倒装句, 可以加强语气, 增强清楚性与简洁性, 以及更流畅地衔接前后地句子. </p><p>以下是几种使用倒装句的条件. </p><h2 id="比较级的倒装"><a href="#比较级的倒装" class="headerlink" title="比较级的倒装"></a>比较级的倒装</h2><ul><li>1.Girls like cats more than boys.</li></ul><p>上面这句话有歧义, 可以有两种意思. </p><ul><li>2.Girls like cats more than boys do.</li><li>3.Girls like cats more than they like boys.</li></ul><p>这是省略不当造成的歧义, 如果想表达2句的意思, 句尾的do不可省. 不然无法判断boys是宾语还是从句主语, 是喜欢猫的人, 还是被喜欢的对象. </p><ul><li>Grils like cats more than boys, who as a rule are a cruel lot, do.</li></ul><p>do放在最后不好, 因为boys与do之间被关系从句阻隔, 而导致表达不清楚, 故使用倒装把do挪到boys之前. </p><ul><li>Girls like cats more than do boys, who as a rule are a cruel lot.</li></ul><p>总结一下, 比较级用倒装需要: </p><p>1.从句助动词或do动词不宜省略<br>2.主语后有较长修饰语</p><h2 id="关系从句的倒装"><a href="#关系从句的倒装" class="headerlink" title="关系从句的倒装"></a>关系从句的倒装</h2><ul><li>1.The Presidentg is man.</li><li>2.A heavy responsibility, whether he likes it or not, falls on him.<br>→The President is a man on whom a heavy responsibility, whether he likes it or not, falls.(不好)</li></ul><p>介词短语on whom因为内含关系词, 要移到句首位置. 然而一经移动, 产生了和上一例相同的问题. 用倒装处理把动词移到主语前. </p><ul><li>→The President is a man on whom <strong>falls a heavy responsibility</strong>, whether he likes it or not.</li></ul><p>如此一来, 关系词whom与先行词a man在一起, 在介词on whom与修饰的对象falls在一起, 而动词falls又与它的主语a heavy responsibility在一起, 解决了所有问题. 这便是倒装句的作用. 要注意的是, 关系词必须先向句首移动, 造成顺序反常, 才有倒装的可能. </p><p>举个不能倒装的例子: </p><ul><li>The President is a man who hears a lot of responsibility.</li></ul><p>这句话关系从句原来是 He bears a lot of responsibility, he改为who原本就在句首, 没有移动, 也就不能倒装. </p><h2 id="假设语气（虚拟语气）的倒装"><a href="#假设语气（虚拟语气）的倒装" class="headerlink" title="假设语气（虚拟语气）的倒装"></a>假设语气（虚拟语气）的倒装</h2><p>这种倒装比较单纯. 目的在于加强简洁性. </p><p>在假设语气中（往往是if引导的）, 如果有be动词或助动词, 就可以考虑倒装. 做法是把连接词（如if）省掉, be动词或主动词提前取代关系词. </p><ul><li>If I had been there, I could have done something to help.<br>_ →Had I been there, I could have done something to help.</li></ul><h2 id="引用句的倒装"><a href="#引用句的倒装" class="headerlink" title="引用句的倒装"></a>引用句的倒装</h2><p>在直接引用与间接引用中都可以选择使用倒装来突出引用的内容. 如</p><ul><li>The police said, “None was killed in the accident.”</li></ul><p>引用常出现在宾语位置, 为了突出说话内容使用倒装. </p><ul><li>→”None was killed in the accident.” said the police.</li></ul><p>句尾部分在直接引语时, 主语、动词也可以不倒装, 仍是the police said. </p><ul><li>The WHO warns that <strong>cholera is coming back</strong>.</li></ul><p>这句话除了可以把整个宾语从句移动到句首外, 还可以只把从句主语移到句首, 加强语气. </p><ul><li>→Cholera, warns the WHO, is coming back.</li></ul><h2 id="类似There-is-are的倒装"><a href="#类似There-is-are的倒装" class="headerlink" title="类似There is/are的倒装"></a>类似There is/are的倒装</h2><p>把地方副词挪到句首, 句型和there is/are很像, 目的在于强调语气, 衔接上下文. </p><ul><li>There goes the train! 你看, 火车开走了！</li><li>Here is your ticket for the opera!</li></ul><p>衔接例子: </p><ul><li>To the west of Taiwan lies Southern China.</li><li>To the east spreads the expanse of the Pacific.</li></ul><h2 id="否定副词句首的倒装"><a href="#否定副词句首的倒装" class="headerlink" title="否定副词句首的倒装"></a>否定副词句首的倒装</h2><p>如果把否定意味的副词(not、never、hardly)挪到句首来强调语气, 就得使用倒装句. </p><ul><li>We don’t have such luck every day.</li></ul><p>如果想要强调“不是每天”, 而把not every day放句首, 就要用倒装. </p><ul><li>→Not every day do we have such luck.</li></ul><p>又如: </p><ul><li>I will not stop waiting for you until you are married.</li></ul><p>同样如果把not until you are married移到句首强调语气, 就要把will倒装到主语前. </p><ul><li>Not until you are married will I shop waiting for you.</li></ul><p>另外一些表示否定的副词如hardly,barely等用法类似, 移到句首倒装. </p><ul><li><p>Hardly had I sat down to work when the phone rang.</p></li><li><p>Hardly anyone knew him.</p></li></ul><p>这句话不必倒装, 因为hardly修饰anyone, 句首是正常位置, 没有移到句首一说. </p><ul><li>Only I saw him yesterday.</li></ul><p>这句也不用倒装only修饰I, 放在I前是正常的. </p><hr><p>高级篇就先记到这里.<br>至此这三篇笔记也整理完毕. 可见整个语法体系中还有不少没有涵盖的内容, 至于要学会解构一个难句子, 唯有进行充分的练习才行, 而这本书更多的是告诉你一些结构的来龙去脉.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法俱乐部 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT 实现尝试</title>
      <link href="/fftcode/"/>
      <url>/fftcode/</url>
      
        <content type="html"><![CDATA[<p>这次接着上次说, 花了点时间把按时间抽取基-2的FFT思路用C++代码实现了下. 可以利用递归的思路来实现. </p><span id="more"></span><p>而且, 就像之前理解的FFT那样, 直接在一个序列的存储空间中进行操作, 这里存在vector中. 要实现这个特性, 调用时必须传入当前处理的那一段序列的序号范围, 所以第一次调用FFT时又套了个壳(myFFT). 有遗憾的是没有实现旋转因子的复用, 也就是重复出现的旋转因子都进行了重复计算. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib\mycomplex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> mylib;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Complex&gt; <span class="title">FFT</span><span class="params">(vector&lt;Complex&gt; &amp;xn, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> length = end - begin + <span class="number">1</span>;<span class="comment">//计算该段序列长度</span></span><br><span class="line"><span class="keyword">if</span> (length &gt; <span class="number">2</span>)<span class="comment">//说明需要分组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = begin + <span class="number">1</span>; i &lt;= begin + length / <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">xn.<span class="built_in">insert</span>(xn.<span class="built_in">end</span>() - (xn.<span class="built_in">size</span>() - end - <span class="number">1</span>), xn[i]);</span><br><span class="line">xn.<span class="built_in">erase</span>(xn.<span class="built_in">begin</span>() + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">FFT</span>(xn, begin, begin + length / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">FFT</span>(xn, begin + length / <span class="number">2</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= length / <span class="number">2</span> - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = xn[begin + i];</span><br><span class="line">xn[begin + i + length / <span class="number">2</span>] = xn[begin + i + length / <span class="number">2</span>] *</span><br><span class="line"><span class="built_in">Complex</span>(<span class="built_in">cos</span>(<span class="number">2</span> * i * PI / length), -<span class="built_in">sin</span>(<span class="number">2</span> * i * PI / length));<span class="comment">//旋转因子</span></span><br><span class="line">xn[begin + i] = temp + xn[begin + i + length / <span class="number">2</span>];<span class="comment">//基本蝶形计算</span></span><br><span class="line">xn[begin + i + length / <span class="number">2</span>] = temp - xn[begin + i + length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> xn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Complex&gt; <span class="title">myFFT</span><span class="params">(vector&lt;Complex&gt; &amp;xn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">FFT</span>(xn, <span class="number">0</span>, xn.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> xn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Complex&gt; list = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">myFFT</span>(list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it &lt; list.<span class="built_in">end</span>(); it++)<span class="comment">//debug</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算结果:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">8.000</span>+<span class="number">0.</span>j)(<span class="number">0</span>+<span class="number">0.</span>j)(<span class="number">0</span>+<span class="number">0.</span>j)(<span class="number">0</span>+<span class="number">0.</span>j)(<span class="number">0</span>+<span class="number">0.</span>j)(<span class="number">0</span>+<span class="number">0.</span>j)(<span class="number">0</span>+<span class="number">0.</span>j)(<span class="number">0</span>+<span class="number">0.</span>j)</span><br></pre></td></tr></table></figure></p><hr><p>另外我在网上看到一个原生C接口的FFT函数库<a href="http://www.fftw.org/">FFTW</a>(the Fastest Fourier Transform in the West), 据说是世界上FFT的最快实现. Tutorial在<a href="http://www.fftw.org/fftw3_doc/">这里</a>. </p><p>下面是一个使用示例. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fftw3.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;libfftw3-3.lib&quot;</span>) <span class="comment">// double版本</span></span></span><br><span class="line"><span class="comment">// #pragma comment(lib, &quot;libfftw3f-3.lib&quot;)// float版本</span></span><br><span class="line"><span class="comment">// #pragma comment(lib, &quot;libfftw3l-3.lib&quot;)// long double版本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">fftw_complex *in, *out;</span><br><span class="line">fftw_plan p;</span><br><span class="line">in = (fftw_complex*)<span class="built_in">fftw_malloc</span>(<span class="built_in">sizeof</span>(fftw_complex) * N);</span><br><span class="line">out = (fftw_complex*)<span class="built_in">fftw_malloc</span>(<span class="built_in">sizeof</span>(fftw_complex) * N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) <span class="comment">//输入序列</span></span><br><span class="line">&#123;</span><br><span class="line">in[i][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//实部</span></span><br><span class="line">in[i][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//虚部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">fftw_plan_dft_1d</span>(N, in, out, FFTW_FORWARD, FFTW_ESTIMATE);</span><br><span class="line"><span class="built_in">fftw_execute</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; in[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; in[i][<span class="number">1</span>] &lt;&lt; <span class="string">&quot;j)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; out[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; out[i][<span class="number">1</span>] &lt;&lt; <span class="string">&quot;j)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fftw_destroy_plan</span>(p);</span><br><span class="line"><span class="built_in">fftw_cleanup</span>();</span><br><span class="line"><span class="built_in">fftw_free</span>(in);</span><br><span class="line"><span class="built_in">fftw_free</span>(out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算结果:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">0</span>j)(<span class="number">1</span>, <span class="number">0</span>j)(<span class="number">1</span>, <span class="number">0</span>j)(<span class="number">1</span>, <span class="number">0</span>j)(<span class="number">1</span>, <span class="number">0</span>j)(<span class="number">1</span>, <span class="number">0</span>j)(<span class="number">1</span>, <span class="number">0</span>j)(<span class="number">1</span>, <span class="number">0</span>j)</span><br><span class="line">(<span class="number">8</span>, <span class="number">0</span>j)(<span class="number">0</span>, <span class="number">0</span>j)(<span class="number">0</span>, <span class="number">0</span>j)(<span class="number">0</span>, <span class="number">0</span>j)(<span class="number">0</span>, <span class="number">0</span>j)(<span class="number">0</span>, <span class="number">0</span>j)(<span class="number">0</span>, <span class="number">0</span>j)(<span class="number">0</span>, <span class="number">0</span>j)</span><br></pre></td></tr></table></figure></p><p>结果与我实现的FFT一样, 不过效率…</p><p>使用FFTW除需要先配置一下环境外, 还需要知道几个点: </p><ul><li><p>需添加<code>#include &quot;fftw3.h&quot;</code>, 这不用说了吧. </p></li><li><p>最好使用FFTW中实现的<code>fftw_complex</code>复数变量, 当如果添加了<code>#include &lt;complex&gt;</code>, 将会使用<code>&lt;complex&gt;</code>文件中定义的复数变量. </p></li><li><p><code>fftw_complex</code>复数变量底层实现默认是个数组<code>double[2]</code>, 依次存放了实虚部. </p></li><li><p>另一个比较重要的是<code>fftw_plan</code>变量, 他就像是个机器, 把输入输出序列、序列长度以及其他一些参数传入, 使用<code>fftw_execute(p)</code>函数启动FFT运算. </p></li><li><p>最后不能忘了清理资源, 务必使用<code>fftw_free</code>函数释放资源. </p></li></ul><p>FFTW除了能够处理一维序列的DFT, 还可以处理二维序列及其他功能, 参见Tutorial.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> 信号处理 </category>
          
          <category> DSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFT </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT 为什么那么快</title>
      <link href="/fft/"/>
      <url>/fft/</url>
      
        <content type="html"><![CDATA[<p>17年第一篇文章´_ゝ｀<br>其实这篇文章早之前已经完成了大部分, 谈谈自己对FFT的理解, 碍于种种原因没有发. 期间本站也崩过一次, 还是免费域名, 从tk换到了ml, 又能继续折腾了. </p><span id="more"></span><p>FFT或者说快速傅里叶变换算法是一类高效计算离散傅里叶变换的方法, 现在已经被广泛地应用于数字<br>信号处理系统中了, 对比前面讨论过的直接计算或者<a href="https://granvallen.github.io/goertzel/">Goertzel算法</a>都需要相当于正比于$N^{2}$的浮点运算量, 而FFT是一种正比于$N\log_{2}N$的离散傅里叶变换计算方法, 而且当N值越大, 这种计算方法的优势就越明显. 画了幅图可以感受下. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E5%AF%B9%E6%AF%94.PNG" width="1459" height="619" class="size-full" alt="DFT直接计算与FFT对比" style="zoom:50%" /> </p><p>FFT是一类蝶形计算, 计算方式不复杂, 但要弄懂它的来龙去脉, 还是得费点功夫, 这也是我迟迟没下笔的原因之一. 这里重新理了下FFT的实现思路, 谈谈自己的理解, 同时希望对于这类算法能有触类旁通的益处. </p><p>FFT算法按大类分成时间抽取与频率抽取的两种类型. 然后根据计算序列样值点个数可以分为一系列以n为基的计算方案, 这里重点讨论以2为基的计算过程, 也就是样值点$N=2^{n}$, 从中能方便快速的领悟FFT计算的原理. 至于处理更一般的情况, 一种方法是把N拆分成比如两个或更多的2的幂次个点的序列, 将N个点的DFT变成几组点DFT的和, 然后利用以2为基的FFT计算过程. </p><p>OK, 这里重点讨论按时间抽取的FFT算法并且以2为基这种特殊的情况作为切入点. 之前说了FFT本质上也是一种DFT的简化算法, 其大致思路是把序列拆成两个子序列, 分别计算它们的DFT, 我们会发现此时的运算量比直接计算已经有所减少. 当序列比较长时, 很自然我们仍然可以对两个子序列进行拆分变成更短的序列, 从而进一步减少计算量. 事实上当长度为$2^{n}$个样值点时, 我们最多能够拆到2个长度为1的序列进行DFT, 此时可预见计算整个序列的DFT的运算量将达到最小. </p><p>思路简单粗暴, 下面将先讨论FFT如何将序列拆分, 并使得这种操作能够不断重复进行直至简化到两个样值点进行DFT. 好吧, 其实也没那么复杂, 这里既然以2为基的FFT为例, 每次把序列拆成奇序列和偶序列就行了. 这可以通过改变离散时间信号采样率这一方式实现, 也就是抽取和内插操作. 来看下图: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/fftt.png" width="840" height="281" class="size-full" alt="FFT原理图" /></p><p>别看上图好像什么也没干（我一开始也这么想的）, 但仔细琢磨就会发现它很好地说明了FFT在时域和频域的拆分操作. 在说明之前需要承认的是上述操作在时域是正确的, 也就是$x[n]$经过上述操作最终又回到$x[n]$是能够实现的（借由提取和内插操作的时域变化可看出）, 其次, 上图中的左移右移实际上应该是序列的循环左移与循环右移. </p><p>先来看上图的左边部分, 通过压缩器提取得到的$g[n]$与$h[n]$便是FFT中经过一次拆分得到的子序列. 不难看出$g[n]=x[2n]$提取的是$x[n]$的位置序号为偶数的点, 而$h[n]=x[2n+1]$提取的是$x[n]$位置序号为奇数的点. </p><p>此时我们不妨回忆一下重采样, 以便得到采样前后的频域变化. 回（bai）忆（du）中…</p><script type="math/tex; mode=display">X_{d}(e^{j\omega})=\frac{1}{M} \sum\limits_{i=0}^{M-1}X(e^{j(\omega/M-2\pi i/M)})</script><p>在这里的M就等于2, 于是有: </p><script type="math/tex; mode=display">G(e^{j\omega})=\frac{1}{2}(X(e^{j\omega/2})+X(e^{j(\omega-2\pi)/2}))</script><script type="math/tex; mode=display">H(e^{j\omega})=\frac{1}{2}(X(e^{j\omega/2})e^{j\omega/2}+X(e^{j(\omega-2\pi)/2})e^{j(\omega-2\pi)/2})</script><p>注意$H(e^{j\omega})$的表达式, 由于到$h[n]$有一个左移操作, 由DTFT性质知在频域需乘因子$e^{j\omega}$. </p><p>唔, 如果可能的话, 我们还是比较希望用$G(e^{j\omega})$与$H(e^{j\omega})$来表示$X(e^{j\omega})$, 这样就能直观地看出子序列单独进行DFT后经过怎样的组合变成整个序列的DFT的, 这才是我们关心的问题. </p><p>此时图右边的频域分析可以很快看出这一点, 只需要再回（bai）忆（du）一下经过增采样前后频域变化就行了: </p><script type="math/tex; mode=display">X_{e}(e^{j\omega})=\sum\limits_{k=-\infty}^{\infty}x[k]e^{-j\omega Lk}=X(e^{j\omega L})</script><p>还注意到h[n]除了经过一个内插器外, 还经过了一个时移, 由DTFT的性质我们知道这相当于频域乘以因子$e^{-j\omega}$. 于是我们有: </p><script type="math/tex; mode=display">X(e^{j\omega})=G(e^{j2\omega})+e^{-j\omega}H(e^{j2\omega})</script><p>以上便得到了子序列DTFT与整个序列DTFT的关系, 对于一有限长非周期序列, 我们将引入DFT. 此前我们已经知道: </p><script type="math/tex; mode=display">\mathcal{DFT}:X[k]=\sum\limits_{n=0}^{N-1}x[n]W_{N}^{kn}=\sum\limits_{n=0}^{N-1}x[n]e^{-j\frac{2\pi k}{N}n}</script><script type="math/tex; mode=display">\mathcal{DTFT}:X(e^{j\omega})=\sum\limits_{n=-\infty}^{\infty}x[n]e^{-j\omega n}</script><p>我们可以把DFT看成是对DTFT一个周期内频率采样得到的, 也就是在$\omega _{k}=\frac{2 \pi k}{N},k=0,1,\cdots,N-1$处的取值. 于是: </p><script type="math/tex; mode=display">\begin{align*}X[k]=X(e^{j2\pi k/N})&= G(e^{j(2\pi k/N)2})+e^{-j2\pi k/N}H(e^{j(2\pi k/N)2}) \\                     &= G(e^{j\frac{2\pi k}{\frac{N}{2}}})+e^{-j2\pi k/N}H(e^{j\frac{2\pi k}{\frac{N}{2}}}) \\                     &= G[k]+W_{N}^{k}H[k] \qquad k=0,1,...,N-1\end{align*}</script><p>上式需要注意的是$G[k]$与$H[k]$是长度为$\frac{N}{2}$序列的DFT, 并且两有限长序列暗含着以$\frac{N}{2}$为周期. 如此我们得到了计算最终目标$X[k]$的计算方法, 确切地说是两子序列与因子$W_{N}^{k}$的组合关系, 其展开后即得到之前所述的蝶形计算步骤. 见下图右边部分: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/DIT_N8.jpg" width="532" height="459" class="size-full" alt="8点FFT蝶形图" /> </p><p>到这里不妨停下来看看经过这样一次拆分, 计算次数是否真的减少了. 基于上次估算的经验, 计算$\frac{N}{2}$个点的$G[k]$需要$(\frac{N}{2})^{2}$次复数乘法和$(\frac{N}{2})(N^{2}-1)$次复数加法, 算上$H[k]$计算量翻倍, 接着和因子$W_{N}^{k}$组合计算又需N次复数乘法与N次复数加法, 累计差不多$N+\frac{N^{2}}{2}$次复数乘法与加法, 而直接计算则是大约$N^{2}$次的复数乘法与加法. </p><p>可见计算量有了相当程度的减少, 而这种处理的计算优势才刚刚显现, 当$g[n]$与$h[n]$的样值点数又是2的幂次时, 很自然, 我们能想到再拆分序列以进一步减少计算量. 以$G[k]$为例, 此时$G[k]$在我们眼里即是之前的$X[k]$. </p><script type="math/tex; mode=display">\begin{align*}G[k] = \sum\limits_{l=0}^{\frac{N}{2}-1}g[l]W_{\frac{N}{2}}^{lk}     &= \overbrace{\sum\limits_{l=0}^{\frac{N}{4}-1} g[2l] W_{\frac{N}{2}}^{2lk}}^{g_{1}[n]DFT} + W_{\frac{N}{2}}^{k}\overbrace{\sum\limits_{l=0}^{\frac{N}{4}-1} g[2l+1] W_{\frac{N}{2}}^{2lk}}^{g_{2}[n]DFT}\\     &= \sum\limits_{l=0}^{\frac{N}{4}-1} g[2l] W_{\frac{N}{4}}^{lk} + W_{\frac{N}{2}}^{k}\sum\limits_{l=0}^{\frac{N}{4}-1} g[2l+1] W_{\frac{N}{4}}^{lk} \\     &= G_{1}[k]+W_{\frac{N}{2}}^{k}G_{2}[k] \\     &= G_{1}[k]+W_{N}^{2k}G_{2}[k] \qquad k=0,1,...,\frac{N}{2}-1\end{align*}</script><p>简单说明一下, 这里$g_{1}[n]$与$g_{2}[n]$便是从$g[n]$抽取出来的奇偶序列, 就像从$x[n]$抽取出来$g[n]$与$h[n]$一样. $g_{1}[n]$与$g_{2}[n]$是长度为$\frac{N}{4}$的序列, 且暗含着以$\frac{N}{4}$为周期. </p><p>到此我们又能进一步补全蝶形计算流图了. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/DIT_N4.jpg"  style="zoom:60%" alt="4点FFT蝶形图" /> </p><p>最后看下第一级的运算, 此时是2点DFT, 取x[0], x[4]计算为例: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/DIT_N2.jpg" width="212" height="140" class="size-full" alt="2点FFT蝶形图" /> </p><p>于是整个按时间抽取基2的8点DFT蝶形计算流图就分解完毕了, 如下图: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/DIT_N8_ALL.jpg" style="zoom:90%" alt="完整8点FFT蝶形计算流图" /> </p><p>蝶形图不仅清楚地表示出各序列的组合关系, 连计算量也可以很方便估算出来, 因为基本的蝶形计算流图（2点进行DFT）所需的计算量是相同的, 对应两次复数乘法与两次复数加法. 因此只需知道有多少次基本蝶形计算就行了, 而且发现如果序列的长度N为2的幂次, 每一级基本蝶形计算无一例外都需要进行N次, 而最多有$log_{2}N$级, 即需要$Nlog_{2}N$次的复数乘法和复数加法. </p><p>还没完, 最后的优化来源于因子$W_{N}^{r}$的对称性和周期性, 具体来说是基于这样的事实: 对于两点经过两个对应旋转因子的组合运算得到两个DFT的值, 而那两个因子的指数部分正相差$\frac{N}{2}$. 正如前面两点蝶形图所示的那样. 于是: </p><script type="math/tex; mode=display">W_{N}^{r+\frac{N}{2}}=W_{N}^{\frac{N}{2}}W_{N}^{r}=-W_{N}^{r}</script><p>因此简化后的基本计算流图变成这个样子: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/DIF_N2%E6%94%B9.jpg" width="225" height="133" class="size-full" alt="简化后两点蝶形图" /> </p><p>可见化简后基本蝶形图的复数乘法次数变为一次, 从而整体上复数乘法次数减少一半. 完整的8点FFT蝶形图应该如下图:</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/FFT.jpg" width="425" height="362" class="size-full" alt="简化后完整8点FFT蝶形图" /> </p><p>下面再深入讨论下FFT的计算过程, 以便启发编程实现的思路. 蝶形计算中还潜藏着编程实现FFT的方法, 或者可以说这才是我们真正的目的. </p><p>上面蝶形流图表示出的FFT计算过程又被称之为是一种同址计算, 观察一下, 每级基本蝶形图输入$x_{m-1}[p]$、$x_{m-1}[q]$输出$X_{m}[p]$、$X_{m}[q]$, 也就是说新的p、q位置的节点值正是由上一节p、q位置的节点值计算得来的. 这意味着计算N点FFT只需一列存N个点的存储寄存器, 而不必更多, 因为允许我们每计算出一个结果直接覆盖对应位置的输入上(事实上, 由于每个输入计算时都会用到两次, 所以还需要一个寄存器临时存放两个输入中的其中一个). 另一个比较头疼的问题是序列的存取问题, 在如前所述的计算中, 读取计算样值点的位序似乎是“错乱无章”的, 而最终输出的DFT结果序列则是正序的. </p><p>这种蝶形计算的读取次序又被称为倒位序, 把输入输出位序以二进制表示可以直观得出这一点. 以8点序列为例, 输入输出序号做如下变化: </p><script type="math/tex; mode=display">\begin{array}{|c|c|c|}\hlinex[n] & \text{倒位序} & X[k] \\ \hline0 & x[000] \to X[000] & 0 \\ \hline4 & x[100] \to X[001] & 1 \\ \hline2 & x[010] \to X[010] & 2 \\ \hline6 & x[110] \to X[011] & 3 \\ \hline1 & x[001] \to X[100] & 4 \\ \hline5 & x[101] \to X[101] & 5 \\ \hline3 & x[011] \to X[110] & 6 \\ \hline7 & x[111] \to X[111] & 7 \\ \hline\end{array}</script><p>输入序列的位序正好是输入为序的倒序. 其实造成这个原因的本质说也简单, 因为每一级的序列都是按位序的奇偶来分组的, 故可以从二进制表示中看出这一点, 0表示被分到偶序列组, 1表示被分到奇序列组. </p><p>到这里我想基2FFT的计算思路及过程细节讲完了, 也对蝶形图有了更深的理解. 通过输入与输出的重新排列组合, 还可以画出很多样式的蝶形图, 比如使输入正序, 输出倒序, 甚至是输入输出都正序（但此时数据即不能顺序存取, 计算也不是同址的, 因此并没有优势）. 受人们关注的还有Singleton在1969年提出的按时间抽取的蝶形计算流图, 其也是通过重排蝶形图内部节点顺序画成的, 最大的特点是每一级的几何形状都相同, 这使数据顺序存取成为可能. 见下图: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/Singleton.jpg" alt="Singleton流图" class="size-full" style="zoom:50%" /> </p><p>除此之外, 对于不同的序列长度, 还有基-3、基-4以及分裂基的一些FFT算法, 以及另外一些不同角度或思路快速计算DFT的方法, 比如按频率抽取的FFT、Winograd傅里叶变换算法等等. 有机会必定再深入研究下. </p><p>本文大多数蝶形图取自维基百科<a href="https://www.google.com.hk/search?q=cooley+tukey%E7%AE%97%E6%B3%95&hl=zh-CN&" target="_blank">库利－图基快速傅里叶变换算法词条</a>. </p><p>参考: <a href="https://book.douban.com/subject/26307919/" target="_blank">《离散时间信号处理（第三版）》</a>Alan V. Oppenheim, Ronald W. Schafer 著. </p><p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> 信号处理 </category>
          
          <category> DSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFT </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人向漫画推荐 -- 生存</title>
      <link href="/comicrecom1/"/>
      <url>/comicrecom1/</url>
      
        <content type="html"><![CDATA[<p>有空分享一些看过的漫画, 其实大多是一些冷门作品. 好了, 本篇主题是我收藏漫画中的一大类, 虽然也是题材烂大街的邪道漫. 这类题材漫画拥有架空的世界观, 里面角色一开始都是普通人, 但因为某种原因被强制参加一个游戏, 为了在新的残酷规则下生存, 不得不抛弃常识, 重新寻找各自的生存方式. 借对于这个世界众生相的想象, 揭露人性社会暗面或仅仅是满足猎奇欲. 早前被动画化的《未来日记》《惊爆游戏》正是这类作品. 暗黑悬疑风格, 这类题材漫画看了根本停不下来啊 (ノ`Д´)ノ</p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=22793168&auto=0&height=66"></iframe><h1 id="1《弥留之国的爱丽丝》"><a href="#1《弥留之国的爱丽丝》" class="headerlink" title="#1《弥留之国的爱丽丝》"></a>#1《弥留之国的爱丽丝》</h1><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E5%BC%A5%E7%95%99%E4%B9%8B%E5%9B%BD%E7%9A%84%E7%88%B1%E4%B8%BD%E4%B8%9D%20%E7%AC%AC%E4%B8%80%E5%8D%B7%E5%B0%81%E5%9B%BE.jpg" alt="弥留之国的爱丽丝 第一卷封图" style="zoom:80%" /></p><p>一事无成的高三学生有栖良平因为经常被旁人与优秀的弟弟比较, 愈加逃避着现实放纵自己. 有一天, 他与死党苅部与张太一同鬼混时, 突然目睹了一个不同寻常的烟火, 来到了一个恍若末世的奇异世界. 在这个世界中每天晚上都上演着一场场以生命为代价的游戏. 滞留者要想在这个国度里生存下去需要“签证”, 通过Clear游戏才能获得签证, 如果签证过期就会被从天而降的激光杀死. </p><p>本作可以说是这个主题下的经典了, 游戏的设计与人物的塑造都不错, 或者说游戏的设计都很好得烘托了人物个性. 主角从一个又一次的残酷的游戏中逐渐成长, 从逃避现实到为自己的信念而活着, 实在让人振奋. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%BA%A2%E6%A1%837.jpg" alt="红桃7-1" style="zoom:80%" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%BA%A2%E6%A1%837-2.jpg" alt="红桃7-2" style="zoom:80%" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%BA%A2%E6%A1%837-3.jpg" alt="红桃7-3" style="zoom:80%" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%BA%A2%E6%A1%837-4.jpg" alt="红桃7-4" style="zoom:80%" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E9%BB%91%E6%A1%835.png" alt="黑桃5" style="zoom:80%" /><br>猎奇场面常见的马头面具, 难道有什么典故？</p><p>该作品已经在今年年初完结, 并发售了三集OVA, 质量上乘, 还原得也不错. </p><hr /><h1 id="2《朋友游戏》"><a href="#2《朋友游戏》" class="headerlink" title="#2《朋友游戏》"></a>#2《朋友游戏》</h1><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E6%9C%8B%E5%8F%8B%E6%B8%B8%E6%88%8F-2.jpg" alt="朋友游戏-2" style="zoom:80%" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E6%9C%8B%E5%8F%8B%E6%B8%B8%E6%88%8F.jpg" alt="朋友游戏" style="zoom:80%" /></p><p>家境贫寒的片切友一所在班级的校外教学旅行的费用200万日元被盗, 又莫名奇妙而和其他4个同伴一起卷入了“朋友游戏”之中. 朋友游戏的每一轮都需要朋友之间的配合, 如果彼此信任通过非常容易, 然而随着游戏的进行, 每个人的复杂身世被一点点揭开, 游戏结局却越来越不确定. 游戏中用金钱来衡量人与人之间的友谊, 通关游戏则减少负债, 否则增加负债. 游戏运营方设计看似能简单通关的游戏, 却夹杂着许多破坏友谊的诱惑. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E6%9C%8B%E5%8F%8B%E6%B8%B8%E6%88%8F-3.jpg" alt="朋友游戏" style="zoom:80%" /></p><p>本作的男主是典型腹黑, 又像是双重人格, 为达成目标不择手段的“恶人”, 虽然这么说, 但我感觉是所有人中三观最正的了吧. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E6%9C%8B%E5%8F%8B%E6%B8%B8%E6%88%8F-4.png" alt="朋友游戏" style="zoom:80%" /></p><p>py游戏没有像很多生存题材一样, 通过血腥暴力来寻求刺激, 更多玩的是心理战. 一些游戏最大的不确定性来自朋友之间的信任程度. 话说作者山口ミコト简直腰折王, 一些作品没头没尾就结束了, 比如《向死神许下最后的愿望》, 结局交给读者推理…不过不得不说脑洞还是很大的, 悬疑味很足, 还有比如《深夜的X仪式》. </p><hr /><h1 id="3《天空侵犯》"><a href="#3《天空侵犯》" class="headerlink" title="#3《天空侵犯》"></a>#3《天空侵犯》</h1><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E5%A4%A9%E7%A9%BA%E4%BE%B5%E7%8A%AF-2.jpg" alt="天空侵犯" style="zoom:80%" /></p><p>架空的世界观, 放眼望去全是高楼大厦, 高楼大厦之间有吊桥相连, 所有人没有办法下到地面, 除非坠落而死. 有一群戴面具的杀人鬼到处活动, 目的是逼迫活人跳楼或被他们杀死. 漫画到后期设定愈加复杂.<br>女高中生本城游理滞留在这个世界, 凭借过人的胆识探索世界, 并寻找着逃离这个世界的方法. </p><p>每话必露胖次, 作者何等的执念…  (￣▽￣”)</p><p>这作狙哥人气很高</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%8B%99%E5%93%A5.jpg" alt="天空侵犯" style="zoom:80%" /></p><hr /><h1 id="4《约定的梦幻岛》"><a href="#4《约定的梦幻岛》" class="headerlink" title="#4《约定的梦幻岛》"></a>#4《约定的梦幻岛》</h1><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%BA%A6%E5%AE%9A%E7%9A%84%E6%A2%A6%E5%B9%BB%E5%B2%9B-1.jpg" alt="约定的梦幻岛-1" style="zoom:80%" /></p><p>总算换了个偏美漫的画风, 讲的是不知道什么地方有这么一个孤儿院, 所有在哪儿的孩子都过着无忧无虑的生活, 亲切地称呼唯一的一个保姆“妈妈”, 唯一的规矩就是不能跑出孤儿院, 这对于孩子过于危险. 没有孩子担心他们的未来, 因为每当孩子满12岁, 都会被孤儿院送到某个收留孩子的家庭里, 从此过上幸福的生活, 没有人对此抱有怀疑. </p><p>因为被送走的孩子落了东西, 两个伙伴便跑去大门口归还, 结果看到了…</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%BA%A6%E5%AE%9A%E6%A2%A6%E5%B9%BB%E5%B2%9B-2.jpg" alt="约定的梦幻岛-2" style="zoom:80%" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%BA%A6%E5%AE%9A%E6%A2%A6%E5%B9%BB%E5%B2%9B-3.jpg" alt="约定的梦幻岛-3" style="zoom:80%" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%BA%A6%E5%AE%9A%E6%A2%A6%E5%B9%BB%E5%B2%9B-4.jpg" alt="约定的梦幻岛-4" style="zoom:80%" /></p><p>简直神展开, 本作少年JUMP人气连载中, 各方面素质都非常不错. </p><p>我特么一直以为黄毛是男的, 直到白毛说他喜欢黄毛, 我才感觉哪里不对. </p><hr /><h1 id="5《见面之后5秒开始战斗》"><a href="#5《见面之后5秒开始战斗》" class="headerlink" title="#5《见面之后5秒开始战斗》"></a>#5《见面之后5秒开始战斗》</h1><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%9B%B8%E9%81%87%E4%BA%94%E7%A7%92%E5%8D%B3%E6%88%98%E6%96%97-1.jpg" alt="见面5秒即战斗" style="zoom:80%" /></p><p>题材是老套路了, 一群人被抓起来被改造, 拥有了超能力, 被迫参加生死存亡的游戏. 这让我想起了漫画《死囚乐园》. 然而本作最称得上有趣的地方, 恐怕就是主角的能力了吧. </p><p>Ps:本作的原作版漫画也是简笔画. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%9B%B8%E9%81%875%E7%A7%92%E5%8D%B3%E6%88%98%E6%96%97-2.jpg" alt="见面5秒即战斗" style="zoom:80%" /></p><p>至少到目前来看, 作者对于这个能力拿捏得相当不错. </p><hr /><h1 id="6《达尔文游戏》"><a href="#6《达尔文游戏》" class="headerlink" title="#6《达尔文游戏》"></a>#6《达尔文游戏》</h1><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E8%BE%BE%E5%B0%94%E6%96%87%E6%B8%B8%E6%88%8F-1.jpg" alt="达尔文游戏" style="zoom:80%" /></p><p>讲的是一款叫《达尔文游戏》的手游, 参加游戏后能够获得独特的异能, 通过对战来获得得Point, Point作用就和普通手游的虚拟币一样, 唯一不同的是Point清零玩家也会死亡. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E8%BE%BE%E5%B0%94%E6%96%87%E6%B8%B8%E6%88%8F-2.png" alt="达尔文游戏" style="zoom:80%" /></p><hr /><h1 id="7《Real-Account》"><a href="#7《Real-Account》" class="headerlink" title="#7《Real Account》"></a>#7《Real Account》</h1><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%9C%9F%E5%AE%9E%E8%B4%A6%E5%8F%B7-1.jpg" alt="真实账号" style="zoom:80%" /></p><p>讲述的是风靡的社交网站”真实账号”主办方通过某种手段, 把用户的大脑囚禁在真实账号的网络中进行生死游戏, 在游戏中死亡, 也意味着现实世界的死亡, 附加规则是: 如果你的粉丝数为0者会当场死亡, 当你死的时候, 你的粉丝也会跟着死. </p><p>题材是十分有趣的, 本作前后换了两个主角, 前期剧情拿捏得不错, 不过后期剧情暴走, 感觉加入了许多无关的元素呢, 难道是要腰折的前奏. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%9C%9F%E5%AE%9E%E8%B4%A6%E5%8F%B7-2.jpg" alt="真实账号" style="zoom:80%" /></p><hr /><h1 id="8《王国游戏》"><a href="#8《王国游戏》" class="headerlink" title="#8《王国游戏》"></a>#8《王国游戏》</h1><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E7%8E%8B%E5%9B%BD%E6%B8%B8%E6%88%8F-1.jpg" alt="王国游戏" style="zoom:60%" /></p><p>讲的是7个玩伴莫名奇妙参加了一个仪式, 之后, 7个人组成了一个微型王国, 每天每个人都会扮演王国的一个角色, 国王、贵族或平民, 上级可以命令下级, 他们只有团结才能使王国得以生存, 以及抵御其他王国的冲击. </p><p>好吧, 竟然也写了这么多, 这个主题暂时就想到这么多. XD</p><p>把我觉得有趣想安利的漫画归归类的话可能可以凑出生存、智斗、狗粮、欢乐向(伪)、历史这些主题吧, 下一次再从中挑一个看看. </p><p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
          <category> 漫画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anli </tag>
            
            <tag> Tucao </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈离散傅里叶变换简化算法--Goertzel算法</title>
      <link href="/goertzel/"/>
      <url>/goertzel/</url>
      
        <content type="html"><![CDATA[<p>契机是之前对Matlab与Mathematica实现FFT算法(Fast Fourier Transformation快速傅里叶变换算法)感到好奇, 加之学习《数字信号处理》这门基础课, 于是就好好研究了下这部分内容. 边看边写, 目测写不到什么高深的内容里去. 说了半天Goertzel算法又是什么东西呢?在讨论FFT之前, 这次先来谈谈这个Goertzel算法. </p><span id="more"></span><p>在Matlab中实现离散傅里叶变换用fft函数:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a0 = <span class="built_in">fft</span>(f1)/<span class="built_in">length</span>(f1)*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><br>在Mathematica中实现离散傅里叶变换用Fourier函数: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1 = <span class="number">2</span> Fourier[f1, FourierParameters -&gt; &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;];</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2 = <span class="number">2</span> Fourier[f1, FourierParameters -&gt; &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;]/Length[f1];</span><br></pre></td></tr></table></figure><br>Goertzel算法简单说就是计算离散时间信号傅里叶变换的一种方法, 由Gerald Goertzel 在1958年首次提出. Goertzel算法是直接计算离散信号傅里叶变换的简化, 从效率上说, 这种算法所需要的计算实数乘法次数大约是直接计算的一半, 而加法次数稍逊于直接计算. 尽管如此, 这在当时主要靠人工手算的时代, 还是十分欢迎. 当N值很大, 正比于$N^{2}$次的浮点运算量十分庞大, 直到1965年J. W. Cooley和J. W. Tukey合作发表了快速傅里叶变换算法后, 计算量下降了几个数量级, 才开启了数字系统处理信号的时代. </p><p>虽然Goertzel算法的地位与FFT算法比起来像是个配角, 但当我们不需要计算所有点的傅里叶变换时, Goertzel算法是可取的, 理解实现起来也相对容易, 因此比较适合小型处理器中实现. </p><p>计算离散傅里叶变换还得从源头说起, 也就是直接手算开始, 并以此为参照, 容易体会到计算的简化. </p><script type="math/tex; mode=display">X[k]= \sum\limits_{n=0}^{N-1} x[n] W_{N}^{kn}\quad k=0,1,...,N-1</script><p>这是大家熟悉的长度为N有限长序列的离散傅里叶变换计算方法（以下简称DFT）,用这个式子我们可以讨论下直接计算X[k]的计算量. </p><p>考虑最大计算量时视x[n]与$W_N^{kn}$皆为复数. </p><script type="math/tex; mode=display">x[n]W_{N}^{kn}=(Re\{x[n]\}Re\{W_N^{kn}\}-Im\{x[n]\}Im\{W_N^{kn}\})  \\ \quad \quad \quad \quad +j(Re\{x[n]\}Re\{W_N^{kn}\}+Im\{x[n]\}Im\{W_N^{kn}\})</script><p>可以看到两个复数相乘需要4次实数乘法与2次实数加法. 计算每一个k的X[k]需要$4N$次实数乘法以及$2N+2(N-1)=4N-2$次实数加法, 因此如果计算所有N个k值再分别乘以N就行了, 也就是$N^{2}$级的计算总量. </p><p>后面改善DFT计算效率的算法大多利用了$W_N^{kn} (=e^{-j(2 \pi /N)kn})$这个因子的对称性与周期性, 也就是:</p><script type="math/tex; mode=display">W_N^{k(N-n)}=W_N^{-kn} \quad</script><script type="math/tex; mode=display">W_N^{kn}=W_N^{k(N+n)}=W_N^{(k+N)n}</script><p>以上两式都容易看出来, 第一个式子说明了这个因子的对称性, 第二个式子说明这个因子对于$k$和$n$有周期性, 周期为$N$. </p><hr><p>Goertzel算法便是利用了周期性改善计算的栗子. </p><p>首先根据周期性: </p><script type="math/tex; mode=display">W_N^{-kN}=e^{j(2 \pi /N)Nk}=e^{j2\pi k}=1</script><p>在计算的的目标$X[k]$中插入这个因子</p><script type="math/tex; mode=display">X[k]=W_N^{-kN} \sum\limits_{n=0}^{N-1}x[n]W_N^{kn} =\sum\limits_{n=0}^{N-1}x[n]W_N^{-k(N-n)}</script><p>然后我们需要构造这么一个序列, $u[n]$为单位阶跃序列</p><script type="math/tex; mode=display">y_k [n]=\sum\limits_{r=-\infty}^{\infty}x[r] W_N^{-k(n-r)} u[n-r]</script><p>发现当$n=N$时</p><script type="math/tex; mode=display">y_k [N]=\sum\limits_{r=-\infty}^\infty x[r] W_N^{-k(N-r)} u[N-r]</script><p>由于$x[n]$是有限长序列, 对于上式, r只在[0, N-1]取的值$x[r]$才不为0, 因此, 对比之后发现, $X[k]=y_k [N]$. 这样就把序列$y_k [n]$与$X[k]$联系起来了. </p><p>回过头再来看我们构造的离散序列$y_k [n]$, 可以看成有限长序列$x[n]$与$W_N^{-kn} u[n]$序列的离散卷积和是不是. 联想到离散卷积可以求得系统响应, 故$y_k [n]$也可以看作单位脉冲响应为$W_N^{-kn} u[n]$的系统对输入$x[n]$的响应, 这点对于之后的推导有重要意义. </p><p>利用上述这一点, 能够表述出系统的差分方程, 这个我们能从系统单位脉冲响应的Z变换中得出. </p><script type="math/tex; mode=display">H(z)=Z\{W_N^{-kn} u[n]\}=\frac{1}{ 1-W_N^{-k} z^{-1} }</script><p>我们知道系统函数$H(z)$能够描述离散LTI系统, 并从中得出系统差分方程的系数, 关系是这样的(可以从对系统差分方程两边同时Z变换得到): </p><script type="math/tex; mode=display">\sum\limits_{k=0}^{N}a_k y[n-k]=\sum\limits_{k=0}^{M}b_k x[n-k]</script><script type="math/tex; mode=display">H(z)=\frac{Y(z)}{X(z)}=\frac{\sum\limits_{k=0}^M b_k z^{-k} }{\sum\limits_{k=0}^N a_k z^{-k} }</script><p>对比就可得到描述这个LTI系统差分方程的系数, 即</p><script type="math/tex; mode=display">H(z)=\frac{1}{ 1-W_N^{-k} z^{-1} }=\frac{b_{0}z^{0}}{a_{0}z^{0}+a_{1}z^{-1}}</script><p>于是, 可写出差分方程: </p><script type="math/tex; mode=display">y_k [n]=W_N^{-k} y_k [n-1]+x[n]</script><p>它是一个递推式, 这意味着每一个$y_k [n]$的计算都可由前一个计算值计算. 若画出递推计算的信号流图, 大概是这样的: </p><p><img class="" src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/X%5Bk%5D%E4%B8%80%E9%98%B6%E9%80%92%E6%8E%A8%E8%AE%A1%E7%AE%97%E6%B5%81%E5%9B%BE.PNG" width="360" height="180" alt="X[k]一阶递推计算流图" /> </p><p>这是Mathematica做的信号流图, 画了一下午看来还是没能画出想要的效果, 我只能说用GraphPlot画比之前用Graph函数画的效果好一点´_&gt;`. </p><p>有了简单明了的信号流图, 再来看看求$X[k]$的计算量. 计算每一个新的$y_k [n]$需要4次实数乘法与4次实数加法, 为了递推计算到$y_k [N]$需要计算之前的N-1个值, 也就是大约4N次实数乘法, 4N次实数加法, 而到这只是计算了X[k]的其中一个k的值. 如此看来乘法次数差不多而加法次数比直接计算稍逊一筹. </p><p>然而这种递推的计算方法也带来了改善效率的可能, 通过变换离散信号结构使用直接II型来实现系统, 就能得到令人满意的结果. </p><p>之前我们得到了$H(z)$(因为是某个k值下的, 其实更应该写做$H_k (z)$), 进行如下变形: </p><script type="math/tex; mode=display">H(z)=\frac{1-W_N^{-k} z^{-1}}{(1-W_N^{-k} z^{-1})(1-W_N^k z^{-1})}=\frac{1}{1-2Cos(2\pi k/N) z^{-1}+z^{-2} } (1-W_N^{-k }z^{-1})</script><p>$H(z)$重新看作两个系统级联:</p><script type="math/tex; mode=display">H(z)=H_{1}(z)H_{2}(z)</script><p>系统函数分别为: </p><script type="math/tex; mode=display">H_1 (z)=\frac{1}{1-2Cos(2\pi k/N) z^{-1}+z^{-2} }</script><script type="math/tex; mode=display">H_2 (z)=1-W_N^{-k} z^{-1}</script><p>用之前的方法可以求得两个系统的差分方程, 引入中间信号$v_k[n]$: </p><script type="math/tex; mode=display">H_{1}(z)=\frac{V_{k}(z)}{X(z)}</script><script type="math/tex; mode=display">H_{2}(z)=\frac{Y_{k}(z)}{V_{k}(z)}</script><script type="math/tex; mode=display">v_k [n]=2Cos(2\pi k/N) v_k [n-1]- v_k [n-2]+x[n]</script><script type="math/tex; mode=display">y_k [n]=v_k [n]-W_N^{k} v_k [n-1]</script><p>此时系统的信号流图可表示为: </p><p><img class="" src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/X%5Bk%5D%E4%BA%8C%E9%98%B6%E9%80%92%E6%8E%A8%E8%AE%A1%E7%AE%97%E6%B5%81%E5%9B%BE.PNG" width="360" height="266" alt="X[k]二阶递推计算流图" /></p><p>图中可以发现为了计算$y_k [N]$不用再计算之前的所有n从0到N-1的值了, 从图上看只需左边回路循环计算N次, 右边回路计算一次就行了. 也就是: </p><script type="math/tex; mode=display">y_k [N]=v_k [N]-W_N^{k} v_k [N-1]</script><p>对于计算每一个$v_k [n]$, 由于计算式中的系数都是实数, 需要两次实数乘法与4次实数加法, 迭代N次需要2N次实数乘法与4N次实数加法, 接着计算一次右边回路需要4次实数乘法与4次实数加法. 总结一下, 计算某个k值下$y_k [N]$一共需要大约$2N+4$次实数乘法与$4N+4$次实数加法, 因此如果计算所有k值再乘以N, 大约需要$2N(N+2)$次实数乘法与$4N(N+1)$次实数加法, 说了半天可见实数乘法计算量约是直接计算的一半. </p><p>Goertzel算法在N值较小或只是计算部分N值时能体现出这种方法的优势. 另一个不得不提的优势来自于迭代的计算方法, 这使得计算在输入第一个样值点后就可以开始. </p><hr><p>下面是几个简单实现的例子, 先来最近折腾的Mathematica</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(*Mathematica*)</span></span><br><span class="line"><span class="built_in">Clear</span><span class="punctuation">[</span><span class="variable">Gortzel</span><span class="punctuation">]</span></span><br><span class="line"><span class="variable">Gortzel</span><span class="punctuation">[</span><span class="type">signal_List</span><span class="punctuation">]</span><span class="operator">:=</span> </span><br><span class="line">  <span class="built_in">Block</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">n</span> <span class="operator">=</span> <span class="built_in">Length</span><span class="punctuation">[</span><span class="variable">signal</span><span class="punctuation">]</span><span class="operator">,</span> <span class="variable">ini</span> <span class="operator">=</span> <span class="variable">signal</span> <span class="operator">//</span> <span class="built_in">First</span><span class="operator">,</span> <span class="variable">signallist</span> <span class="operator">=</span> <span class="variable">signal</span><span class="operator">~</span><span class="built_in">Append</span><span class="operator">~</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="operator">,</span> </span><br><span class="line">   <span class="built_in">Table</span><span class="punctuation">[</span><span class="type">#2</span> <span class="operator">-</span> <span class="built_in">E</span><span class="operator">^</span><span class="punctuation">(</span><span class="operator">-</span><span class="built_in">I</span> <span class="punctuation">(</span><span class="number">2</span> <span class="built_in">Pi</span><span class="operator">/</span><span class="variable">n</span><span class="punctuation">)</span> <span class="variable">k</span><span class="punctuation">)</span> <span class="type">#1</span><span class="operator">&amp;@@</span> <span class="built_in">Block</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="operator">,</span> </span><br><span class="line"><span class="built_in">Nest</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="type">#</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">,</span> <span class="built_in">N</span><span class="punctuation">[</span><span class="number">2</span> <span class="built_in">Cos</span><span class="punctuation">[</span><span class="punctuation">(</span><span class="number">2</span> <span class="built_in">Pi</span> <span class="variable">k</span><span class="punctuation">)</span><span class="operator">/</span><span class="variable">n</span><span class="punctuation">]</span><span class="type">#</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">-</span> <span class="type">#</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">+</span> <span class="variable">signallist</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="variable">i</span><span class="operator">++</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">&#125;</span> <span class="operator">&amp;,</span> <span class="punctuation">&#123;</span><span class="number">0</span><span class="operator">,</span> <span class="variable">ini</span><span class="punctuation">&#125;</span><span class="operator">,</span> <span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">,</span> </span><br><span class="line"><span class="punctuation">&#123;</span><span class="variable">k</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="operator">;</span></span><br></pre></td></tr></table></figure><p>算出结果没问题, 但不够高效, 计算几百个点的序列就得等好一会儿了. </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%Matlab</span></span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">[xk]</span>=<span class="title">Goertzel</span><span class="params">(xn)</span></span></span><br><span class="line">clear xk;</span><br><span class="line">signallist = [xn, <span class="number">0</span>];</span><br><span class="line">N=<span class="built_in">length</span>(xn);</span><br><span class="line">xk=<span class="built_in">ones</span>(<span class="number">1</span>,N);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">0</span>:N<span class="number">-1</span></span><br><span class="line">    box=[<span class="number">0</span>, signallist(<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">for</span> ii=<span class="number">2</span>:N+<span class="number">1</span></span><br><span class="line">        box=[box(<span class="number">2</span>), <span class="number">2</span>*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*k/N)*box(<span class="number">2</span>)-box(<span class="number">1</span>)+signallist(ii)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    xk(k+<span class="number">1</span>)= box(<span class="number">2</span>)-<span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">j</span>*<span class="number">2</span>*<span class="built_in">pi</span>*k/N)*box(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>看了下原来Matlab自带这个算法, 使用goertzel函数, 试了下还挺高效. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mycomplex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> E=<span class="number">2.718281828459</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.1415926535898</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Complex&gt; <span class="title">Goertzel</span><span class="params">(vector&lt;Complex&gt; xn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Complex&gt; xk;</span><br><span class="line">    <span class="type">int</span> n = xn.<span class="built_in">size</span>();</span><br><span class="line">    xn.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex box[<span class="number">2</span>] = &#123; <span class="number">0</span>, xn[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = xn.<span class="built_in">begin</span>() + <span class="number">1</span>; it != xn.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            Complex temp = box[<span class="number">1</span>];</span><br><span class="line">            box[<span class="number">1</span>] = box[<span class="number">1</span>] * <span class="number">2</span> * (<span class="built_in">cos</span>(<span class="number">2</span> * PI*k / n)) - box[<span class="number">0</span>] + *it;</span><br><span class="line">            box[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        xk.<span class="built_in">push_back</span>(box[<span class="number">1</span>] - <span class="built_in">Complex</span>(<span class="built_in">cos</span>(<span class="number">2</span> * PI*k / n), -<span class="built_in">sin</span>(<span class="number">2</span> * PI*k / n)) * box[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考: <a href="https://book.douban.com/subject/26307919/" target="_blank">《离散时间信号处理（第三版）》</a>Alan V. Oppenheim, Ronald W. Schafer 著.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> 信号处理 </category>
          
          <category> DSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> DFT </tag>
            
            <tag> Matlab </tag>
            
            <tag> Mathematica </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《语法俱乐部》笔记 2.中级篇</title>
      <link href="/grammarclub2/"/>
      <url>/grammarclub2/</url>
      
        <content type="html"><![CDATA[<p>时间一长就忘了填坑了 O-Q 最近在折腾Mathematica, 被其强大深深折♂服, 有空写写关于学习的感受(无责任挖坑中…)</p><p>言归正传, 从中级篇开始将告别简单句引入复合句的概念. </p><span id="more"></span><p>首先区分下书中所述<strong>合句</strong>与<strong>复句</strong>的区别. </p><p>合句很简单, 两个简单句用and、but等连词连接即作为合句, 两个简单句是并列的关系, 无主从之分, 故也称为对等从句；</p><p>复句也可以看成是两个简单句的合体, 但需要把其中的一个简单句改造成名词、形容词、副词等词类, 从而作为另一个简单句的某个句子成分, 根据充当成分的不同, 分成主语从句/宾语从句、定语从句、状语从句等, 因此他们是有主从之分的. </p><p>为了与书中保持一致, 这里将采用名词从句、关系从句、副词从句这样的说法(尽管可能之前的分法更耳熟, 但意思都一样）. </p><h1 id="名词从句（主语从句-宾语从句-同位语从句）"><a href="#名词从句（主语从句-宾语从句-同位语从句）" class="headerlink" title="名词从句（主语从句/宾语从句/同位语从句）"></a>名词从句（主语从句/宾语从句/同位语从句）</h1><h2 id="构造名词从句"><a href="#构造名词从句" class="headerlink" title="构造名词从句"></a>构造名词从句</h2><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E5%90%8D%E8%AF%8D%E4%BB%8E%E5%8F%A5%E6%9D%A5%E6%BA%90.jpg"  style="zoom:50%" alt="" align=center /></p><p>疑问句自然也需要分成特殊与一般来考虑, 不过在此之前我还记录了这么几点: </p><ul><li><p>1.在<strong>简单句前面加的连接词that没有实际含义, 而只有语法功能</strong>, 表示后面是一个名词从句. </p></li><li><p>2.名词从句在主句中充当名词成分, 作为主语/宾语/补语/同位语. </p></li></ul><p>几个例子: </p><p><strong>主语位置</strong></p><ul><li>1.Something is strange.</li><li>2.He didn’t show up on time.</li></ul><p>→(A)That he didn’t show up on time is strange.<br>→(B)It is strange that he didn’t show up on time.</p><p>如果名词从句很长, <strong>避免头重脚轻, 常使用虚词it来填充, 从句后移</strong>, 在这里显得突出strange.</p><p><strong>宾语位置</strong></p><ul><li>1.The defendant said something.</li><li>2.He didn’t do it.</li></ul><p>→(A)The defendant said that he didn’t do it.<br>→(B)The defendant said he didn’t do it.</p><p>名词从句连接词that因为没有实际含义, 所以有时能够省略. <strong>如果名词从句放在了及物动词的宾语位置, 读者可以清楚看出这是名词从句, 此时便可省略that</strong>, 就像上面这个例子一样. 但总的判断原则即省略that后能否再维持原来意思的清楚. </p><p>宾语位置使用it的例子</p><ul><li>1.I find something strange.</li><li>2.He didn’t show up on time.</li></ul><p>→I find it strange that he didn’t show up on time.</p><p><strong>补语位置</strong></p><p>→The car is ruined. The important thing is that we’re all right.<br>→The car is ruined. The important thing is we’re all right.</p><p>名词从句在补语位置时, 只要不会产生断句困难、意思混淆, 就可省略that. </p><p><strong>同位语位置</strong></p><ul><li>1.I am afraid of that thing.</li><li>2.I can’t help you.</li></ul><p>→(A)I am afraid of that thing that I can’t help you.<br>→(B)I am afraid I can’t help you.</p><p>I can’t help you加上连接词that成为名词从句, 视为thing的同位语. 这里That thing无实际含义（实际含义在同位语中）, 故介词短语of that thing介词短语可有可无, 可省略. 剩下的that I can’t help you仍视为同位语, that也可省略. </p><h2 id="名词从句放大"><a href="#名词从句放大" class="headerlink" title="名词从句放大"></a>名词从句放大</h2><p>名词从句放大说的是有时相比于主句, 更想突出从句的内容, 此时可以去掉that, 把从句放最前面. </p><p>如: </p><ul><li>I suppose that this is your last offer?</li></ul><p>→This is your last offer, I suppose?</p><h2 id="疑问句改造成的名词从句"><a href="#疑问句改造成的名词从句" class="headerlink" title="疑问句改造成的名词从句"></a>疑问句改造成的名词从句</h2><h3 id="特殊疑问句"><a href="#特殊疑问句" class="headerlink" title="特殊疑问句"></a>特殊疑问句</h3><p>对于特殊疑问句而言, 需用相应的疑问词（who\what\when\how等）引导疑问句. </p><ul><li>1.I know the question.</li><li>2.Who are you?</li></ul><p>→(A)I know who you are.</p><p>使用who引导, who are you改写为非疑问句语序who you are. </p><h3 id="一般疑问句"><a href="#一般疑问句" class="headerlink" title="一般疑问句"></a>一般疑问句</h3><p>一般疑问句选择<strong>whether/if</strong>来引导. 比较特别的是whether, whether作为一个介词, 不能独立当作疑问词来引导带问号的疑问句, 可是他可以引导代表一个问题的名词从句. </p><ul><li>1.I can’t tell which.</li><li>2.Either he’s telling the truth or he’s not.</li></ul><p>→I can’t tell <strong>whether he’s telling the truth or not</strong>.</p><p>whether可以看成是which与either的合成. </p><p>whether与解释为”是否”的if在大多数情况下可以互换, 但在<strong>句首位置与介词后只能用whether</strong>. 这是因为, 句首的if易误解为”如果”, 至于在介词后接名词短语是合理的, 不适合用连词性的if来接, 而whether是做为代名词类是合理的. </p><h2 id="wh-ever这类词在名词从句中的使用"><a href="#wh-ever这类词在名词从句中的使用" class="headerlink" title="wh-ever这类词在名词从句中的使用"></a>wh-ever这类词在名词从句中的使用</h2><p>wh-ever一般解释成anyxxx that来引导名词从句. </p><ul><li>1.I’ll fire whoever (=anyone that) stole the money.</li><li>2.Whatever(=Anything that) he may say won’t be true.</li><li>3.Whichever way(=Any way that) you go is fine with me.</li></ul><h1 id="副词从句（状语从句）"><a href="#副词从句（状语从句）" class="headerlink" title="副词从句（状语从句）"></a>副词从句（状语从句）</h1><ul><li>1.Because he needs the money, he works hard. → 副词从句</li><li>2.He needs the money, and he works hard. → 对等从句</li></ul><p>副词从句与对等从句的差别是, <strong>对等从句使用对等连接词, 连接之后无主从之分；副词从句则使用从属连接词, because he needs the money成为从属地位的从句, 作为副词使用, 修饰主句动词的原因</strong>. </p><h2 id="副词从句和名词从句差别表现在"><a href="#副词从句和名词从句差别表现在" class="headerlink" title="副词从句和名词从句差别表现在"></a>副词从句和名词从句差别表现在</h2><ul><li><p>1.连接词: 名词从句用that引导且无具体意义, 副词从句由从属连接词引导且有具体含义, though表让步, because表原因, if表条件. </p></li><li><p>2.名词从句属于名词类, 放在主语中作名词成分, 也就意味着去掉从句, 主句一般不完整. 副词从句的主句则是完整的句子. </p></li></ul><h2 id="副词从句的种类"><a href="#副词从句的种类" class="headerlink" title="副词从句的种类"></a>副词从句的种类</h2><p>副词从句因为结构简单, 因此重点放在各种连接词的选择上. </p><p><strong>从句表时间、地方</strong></p><ul><li>1.He became more frugal(节俭的) <strong>after he got married</strong>.</li><li>2.I’ll be waiting for you <strong>until you’re married</strong>.</li></ul><p>从句使用现在时, 语气上当成确定的事件来说. </p><ul><li>3.It was all over <strong>when I got there</strong>.</li><li>4.A small town grew <strong>where three roads met</strong>.</li></ul><p><strong>从句表条件</strong></p><ul><li><p>1.<strong>If he calls</strong>, I’ll say you’re sleeping.<br>一样的道理, 先让假设成立, 从句使用现在时</p></li><li><p>2.He won’t have it his way, <strong>as long as I’m here</strong>.</p></li><li>3.Suppose you were ill, <strong>where would you go</strong>?</li></ul><p><strong>从句表原因、结果</strong></p><ul><li>1.<strong>As there isn’t much time left</strong>, we might as well call it a day.</li><li>2.There’s nothing to worry about, <strong>now that Father is back</strong>.</li><li><p>3.He looked <strong>so</strong> sincere <strong>that no one doubted his story</strong>.<br>so/such…that…表因果</p></li><li><p>4.The mother locked the door from the outside, <strong>so that the kids couldn’t get out when they saw fire</strong>.</p></li></ul><p><strong>从句表目的</strong></p><ul><li>1.The mother locked away the drugs <strong>so that the kids wouldn’t swallow any by mistake</strong>.</li><li>2.I’ve typed out the main points in boldface, <strong>in order that you won’t miss them</strong>.</li><li>3.I’ve underlined the key points, <strong>lest you miss them</strong>.</li><li>4.You’d better bring more money, <strong>in case you should need it</strong>.</li></ul><p><strong>从句表让步</strong></p><ul><li><p>1.<strong>Although you may object（反对）</strong>, I must give it a try.</p></li><li><p>2.<strong>while the disease is not fatal</strong>, it can be very dangerous.</p></li><li><p>3.Wh-ever的连接词, 若解释为No matter…(不论), 就表示让步语气, 引导副词从句. (前面我们说过解释为anyxxx that可以引导名词从句)</p></li><li><p>Whether(=No matter) you agree or not, I want to give it a try.</p></li><li>Whoever(=No matter who) calls, I won’t answer.</li><li>Whichever(=No matter which) way you go, I’ll follow.</li><li>However(=No matter how) cold it is, he’s always wearing a shirt.</li><li>Wherever(=No matter where) he is, I’ll get him!</li><li>Whenever(=No matter when) you like, you can call me.</li></ul><p><strong>从句表限制</strong></p><ul><li>1.<strong>As far as money is concerned</strong>, you needn’t worry.</li><li><ol><li>Picasso was a revolutionary <strong>in that he broke all traditions</strong>.</li></ol></li></ul><p><strong>从句表方法、状态</strong></p><ul><li>1.He played the piano <strong>as Horowitz(霍洛维茨) would have</strong>.</li><li>2.He writes <strong>as if he is left handed</strong>.→真左撇子<br>   He writes <strong>as if he were left handed</strong>.→冒充左撇子<br>   He writes <strong>as if he was left handed</strong>.→无法判断<br>注意as if的用法. </li></ul><h1 id="关系从句（定语从句）"><a href="#关系从句（定语从句）" class="headerlink" title="关系从句（定语从句）"></a>关系从句（定语从句）</h1><p>关系从句没有经过省略时, 都以形容词从句看待, 有以下特点: </p><p>1.组成的两个简单句有<strong>交叉部分</strong>, 也就是有重复的元素, 并由此建立起”关系”, 这是关系从句的构成条件.<br>如: </p><ul><li>For boyfriend I’m looking for <strong>a man</strong>.</li><li><strong>He</strong> is tall, rich, and well-educated.</li></ul><p>2.用关系词（wh-）代替交叉的内容, 让他产生连接词的功能. </p><p>如上例把 He → who, 变成who is tall, rich, and well-educated. </p><ol><li>将关系从句附于主句交叉点（名词）后, 作为形容词修饰名词. </li></ol><p>即: </p><ul><li>For boyfirend I’m looking for a man who is tall, rich, and well-educated.</li></ul><h2 id="关系代词与关系副词"><a href="#关系代词与关系副词" class="headerlink" title="关系代词与关系副词"></a>关系代词与关系副词</h2><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E5%85%B3%E7%B3%BB%E4%BB%A3%E8%AF%8D%E4%B8%8E%E5%85%B3%E7%B3%BB%E5%89%AF%E8%AF%8D.jpg"  style="zoom:50%" alt="" align=center /></p><h2 id="关于关系代词的省略"><a href="#关于关系代词的省略" class="headerlink" title="关于关系代词的省略"></a>关于关系代词的省略</h2><ul><li>1.<strong>The man</strong> is my uncle.</li><li>2.You saw <strong>him</strong> just now. </li></ul><p>→You saw whom just now → whom you saw just now →The man [whom] you saw just now is my uncle.</p><p>此处省略whom意思不变, 由于从句中是S+V+C的结构主从句也不会混淆, whom可省略. </p><ul><li>1.<strong>The man</strong> is my uncle.</li><li>2.<strong>He</strong> was here just now. → who was here just now → The man who was here just now is my uncle.</li></ul><p>这里如果省略了who会造成断句困难, The man was here 与 is my uncle混杂, 故关系词不可省.<br><strong>这样总结起来关系词在从句中做宾语的一般可以省略. </strong></p><ul><li>1.He is not <strong>the man</strong>.</li><li>2.He used to be <strong>the man</strong>. → who he used to be. → He is not the man [who] he used to be.</li></ul><p>此时who也可省略. </p><h2 id="使用关系词that取代who和which的情况"><a href="#使用关系词that取代who和which的情况" class="headerlink" title="使用关系词that取代who和which的情况"></a>使用关系词that取代who和which的情况</h2><p>that是借自指示代词, 具有指示的功能. 所以, <strong>关系从句若是有限定范围指示作用, 用that更好</strong>. 此类用法多见于下定义的时候. 如: </p><ul><li>Man is an animal that is capable of reason.</li></ul><p>反过来, 不用that的情况就是从句没有限定范围的指示作用, 而只是起补充说明的性质. 特别是用逗号将先行词隔开的用法: </p><ul><li>1.For boyfriend, I’m considering your brother John, who is tall.</li><li>2.I like Time Classic Words, which many people like too.</li></ul><p>称这样的关系从句为”非限定用法”, 在”非限定用法”中, 由于从句与主句断开, 不能利用先行词这个重复点, 故关系词不能省略. </p><p>另外, <strong>介词后也不能用that来引导关系从句</strong>. </p><h2 id="再谈”非限定用法”"><a href="#再谈”非限定用法”" class="headerlink" title="再谈”非限定用法”"></a>再谈”非限定用法”</h2><ul><li>1.Shakespeare was born <strong>in 1564</strong>.</li><li>2.Queen Elizabeth I was on the throne <strong>then</strong>.</li></ul><p>这里先行词1564已经是一个明确的年代, 因此从句是补充说明那年有什么特别的事, 而非进一步指示时间, 实则无关紧要. 这种情况, 用逗号将先行词分隔开, 不可省略关系词. </p><p>→Shakespeare was born in 1564, when Queen Elizabeth I was on the throne.</p><h2 id="关于先行词的省略"><a href="#关于先行词的省略" class="headerlink" title="关于先行词的省略"></a>关于先行词的省略</h2><p>要省略先行词, 首先这个先行词得是”空的”, 即没有内容的字眼, 如thing、people等空泛的字眼. 其次, 关系从句与先行词之间不能有逗号断开. 而且, 因为先行词属于重要元素, 所以一旦省略掉先行词, 在关系词部分要有所表示, 大致分这么几种情况: </p><p><strong>把关系代词改写为what来表示前面省掉的先行词</strong></p><ul><li>1.I have <strong>the thing</strong>.</li><li>2.You need <strong>it</strong>.</li></ul><p>→I have the thing <strong>that/which</strong> you need.</p><p>两种简化方案</p><ul><li>3.I have the thing you need. 关系词在从句中做宾语可省略</li><li>4.I have what you need. 索性改成了宾语从句</li></ul><p>把that改为what, 表示前面有一个省略掉的先行词. 在句型分析时也可以说what you need是名词从句, 作为have的宾语. </p><p><strong>把关系词who变成whoever</strong></p><p>如果把关系词who变成whoever, 表示先行词不管是谁, 那么就可以省略掉先行词. </p><ul><li>1.I’ll shoot <strong>any person</strong>.</li><li>2.<strong>He</strong> moves.</li></ul><p>→I’ll shoot any person who moves.<br>→I’ll shoot whoever moves.</p><p>whoever表示前面省略了一个先行词. 与上例类似, <strong>本质上都是把关系从句转化成了名词从句</strong>, 下例也类似. </p><p><strong>表示”任意选哪个”的意思, 用whichever来代表先行词的省略</strong></p><ul><li>1.You can take <strong>any car</strong>.</li><li>2.You like <strong>it</strong>.</li></ul><p>→You can take any car that you like.<br>→You can take any car you like.<br>→You can take whichever car you like.</p><h2 id="关于关系从句的位置"><a href="#关于关系从句的位置" class="headerlink" title="关于关系从句的位置"></a>关于关系从句的位置</h2><p>一般是放在先行词后, 但总的原则是在不会混淆意思的前提下与其修饰的对象尽量接近, 以增强明确性. </p><ul><li>1.There are two apples in <strong>the basket</strong>.</li><li>2.<strong>The basket</strong> is lying on the table.</li></ul><p>→There are two apples in the basket which is lying on the table.</p><ul><li>1.You can find two <strong>apples8</strong> in the basket.</li><li>2.I bought <strong>the apple</strong>.</li></ul><p>→You can find two apples which I bought in the basket.</p><p>上句中in the basket是修饰can find, 而两者太远, 易产生歧义, 以为是在修饰bought. 应该改成: </p><p>→In the basket you can find two apples which I bought.</p><h2 id="使用关系副词"><a href="#使用关系副词" class="headerlink" title="使用关系副词"></a>使用关系副词</h2><p>如果关系从句中以副词和主句中先行词重复, 就会改写为关系副词, 关系副词不是名词类, 所以可以自由省略, 除非与关系代词一样被逗号所隔开. </p><p><strong>when</strong></p><ul><li>1.The rain came <strong>at a time</strong>.</li><li>2.The farmers needed it most <strong>then</strong>.</li></ul><p>→The rain came at a time [when] the farmers needed it most.</p><p>a time与then是一个交叉点. </p><p>如果认定when的先行词是a time, 那么关系从句形容这个名词, 依旧是形容词类. 这样诠释比较统一, 也比较单纯. 也就是: 在省略之前, 关系从句全都是形容词从句, 两者等价. </p><p><strong>where</strong></p><ul><li>1.The car stopped <strong>at a place</strong>.</li><li>2.Three roads met <strong>there</strong>.</li></ul><p>→(A)The car stopped at a place [where] three roads met.</p><p><strong>how/why</strong></p><ul><li>1.Can you show me <strong>the way</strong>?</li><li>2.You pulled off that trick in <strong>that way</strong>.</li></ul><p>→Can you show me the way [how] you pulled off that trick?</p><h2 id="再简单谈谈关系副词的省略"><a href="#再简单谈谈关系副词的省略" class="headerlink" title="再简单谈谈关系副词的省略"></a>再简单谈谈关系副词的省略</h2><p>上面的栗子中有一句: </p><ul><li>The rain came at a time [when] the farmers needed it most.</li></ul><p>1.at a time与when都是无内容的字眼, 不指明实际的时间</p><p>2.at a time与when在一定程度上有重复</p><p>故有以下两种省略方式: </p><p>→The rain came <strong>when</strong> the farmers needed it most.<br>→The rain came <strong>at a time</strong> the farmers needed it most.</p><p>这里我们发现省略at a time后从句变成了由when引导的<strong>副词从句</strong>了. 再看上面的这个例子: </p><p>Can you show me the way [how] you pulled of that trick?</p><p>同样的道理, 可以省略the way或how. </p><p>→Can you show me <strong>how you pulled of that trick</strong>?<br>→Can you show me the way you pulled of that trick?</p><p>值得关注的是省略了主句中的名词the way的情况, 此时的how引导的从句应视为how did you pull of the trick?这个疑问句改造而成的名词从句.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法俱乐部 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《语法俱乐部》笔记 1.初级篇</title>
      <link href="/grammarclub1/"/>
      <url>/grammarclub1/</url>
      
        <content type="html"><![CDATA[<p>《语法俱乐部》初级部分, 关于简单句5种基本句型与其组成部分的故事. </p><span id="more"></span><h1 id="五种基本简单句（灰常重要）"><a href="#五种基本简单句（灰常重要）" class="headerlink" title="五种基本简单句（灰常重要）"></a>五种基本简单句（灰常重要）</h1><ol><li>主 + 动→S + V</li><li>主 + 动 + 宾→S + V + O</li><li>主 + 动 + 补（主补）→S + V + C（或称主系表结构）</li><li>主 + 动 + 宾 + 宾→S + V + O + O</li><li>主 + 动 + 宾 + 补（宾补）→S + V + O + C</li></ol><ul><li>be动词若是直接翻译为“是”, 则是最具代表性的“连缀动词”, 也称“系动词”. </li><li>其他常见的”系动词”有 look, seem, appear, sound, feel, taste, turn, prove, become, make. 作为系动词时的他们, 若抛开他们本来的意思, 统统翻译为”是”, 一般前后差别不大. </li><li>补语词类一般就是adj与n. adj词类指的形容词性的词, 一般是由形容词、动名词、过去分词、名词和物主代词充当. </li><li>若be动词后无补语, 那么考虑be不是作为连缀动词存在, 而应该翻译为存在, 即变为S+V句型结构. 其他系动词也有类似现象, 请多注意. </li><li>再说明下关于<code>S+V+O+O</code>句型结构, 有一种动词后面可以接两个宾语.<br>例如: <code>John&#39;s father gave him a dog.</code>区别于S+V+O+C结构例如: <code>John&#39;s father called him a dog.</code></li></ul><p>在句子组成部分介绍中, 大多比较熟悉, 给人印象深刻的地方做个记录. 比如下面作者关于定冠词与”<strong>专有名词</strong>“的论述. </p><p>在”传统”语法中说: 定冠词与“专有名词”之间是有矛盾的, 不能同时存在. 这种说法本身是没有问题的, 有问题的是, 常常语法书中又给出一些个特例. 像是和地方关联的”专有名词”又可以加定冠词the, 如<strong>the Pacific（太平洋）</strong>、<strong>The Himalayas（喜马拉雅山）</strong>等等. </p><p>而作者的解释是不存在所谓特例, the Pacific实际上是<strong>the Pacific （Ocean）</strong>的简化, 可以理解为特指叫Pacific的海洋, 即Pacific并不是真正意义上的“专有名词”. </p><h1 id="动词时态-→-简单式-amp-完成式"><a href="#动词时态-→-简单式-amp-完成式" class="headerlink" title="动词时态 → 简单式 &amp; 完成式"></a>动词时态 → 简单式 &amp; 完成式</h1><h2 id="1-简单式"><a href="#1-简单式" class="headerlink" title="1.    简单式"></a>1.    简单式</h2><p> → 能用括弧框出时间范围的情形使用, 时间范围不论大小. </p><p>如:<br>The witness <strong>was</strong> being questioned in court when he had a heart attack.<br>首先需要说明的是在作者构想的语法中being、questioned都作为形容词看, 作为补语. 这在之后也会谈到, 这么做的原因就是简化语法, 或者说是为了清晰语法, 把时态仅分成简单的两种情况. </p><p>句中表现时间的部分是<strong>when he had a heart attack</strong>,  心脏病发作是需要持续一段时间的, 故用简单式. 从had中看出应该用过去时, 故用了was. 而being作为形容词看, 表当时“正在”, 而questioned作为形容词, 有被动的意味. 所以连起来是”当时正在被质询”. </p><h2 id="2-完成式"><a href="#2-完成式" class="headerlink" title="2.    完成式"></a>2.    完成式</h2><p>→ 用箭头来表示时间, 往往是表示动作的截止时间</p><p>举几个栗子:<br>We have been working overtime for a week to fill your order.<br>同样把分词working看作形容词, 作为补语, 表示工作的持续性. for a week是说之前的一个礼拜到现在, 如果表示成箭头就是从一星期前指向”现在”这个时间点的箭头. 因此这句用了完成式have been. </p><p>又如:<br>I had been smoking three packs of cigarettes a day before I decided to quit.</p><p>再如:<br>Next April, I will have worked here for 20 years.</p><p>因为以前完成时的不是太熟悉, 多记了几句例句. 把截止的那个点移到过去、现在和未来, 产生了这三种情况. </p><h1 id="动状词（非谓语动词）"><a href="#动状词（非谓语动词）" class="headerlink" title="动状词（非谓语动词）"></a>动状词（非谓语动词）</h1><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E5%8A%A8%E7%8A%B6%E8%AF%8D%E6%A6%82%E8%A7%88.jpg"  style="zoom:40%" alt="概览" align=center /></p><h2 id="不定式"><a href="#不定式" class="headerlink" title="不定式"></a>不定式</h2><p>从上图中不难看出不定式的作用十分广泛, 经常与同样能作名词的动名词相混. 但一种区分方法是, 语法上<code>不定式不能放在介词与所有格后</code>. </p><h3 id="不定式to-do与助动词的关系"><a href="#不定式to-do与助动词的关系" class="headerlink" title="不定式to do与助动词的关系"></a>不定式to do与助动词的关系</h3><p>→ 不定式是助动词的变化. </p><ul><li>must → (have) to do</li><li>should → (ought) to do</li><li>will/should → (be able) to do</li><li>may/might → (be likely) to do</li></ul><p>不定式描述有<code>不确定的语气</code>, 因此常用在<code>描述结果未知或还未发生的事情</code>上. 与此相反, 动名词则大多描述确定的事实. </p><h3 id="不定式特殊用法"><a href="#不定式特殊用法" class="headerlink" title="不定式特殊用法"></a>不定式特殊用法</h3><p>使役动词由于有强制性, 结果确定, 接不定式一般把to省去（即动词原形）. </p><p>常见使役动词有: learn、get、keep、make、let、help、have（有；让；从事；允许）</p><p>感官动词碰到不定式与使役动词情况一样. </p><p>使役动词在被动语态中要把to补回去. </p><h2 id="动名词"><a href="#动名词" class="headerlink" title="动名词"></a>动名词</h2><p>动名词在句子中作名词. 通常表示一个<code>经常性</code>的或<code>持续性</code>的动作. </p><p>动名词还应用于<code>从句简化</code>. 从句简化是本书中一个非常重要的内容, 在后面会详细叙述, 先看一个简单例子. </p><p>I really enjoyed that <strong>I taught English to school children</strong> at night.</p><p>简化后<br>→I really enjoyed <strong>teaching English to school children</strong> at night.</p><p>观察第一个句子, 是一个名词从句(宾语从句), 所以属于名词从句的简化. <strong>特点是主从句的主语是一样的, 那就没必要说两遍. 省去从句主语后, enjoy后应该接个名词, 那么是to teach还是teaching呢？经常性的动作用teaching. </strong></p><p>如果主从句主语不一致怎么办呢？一种方法是<code>从句主语转化为所有格形式</code>. </p><p>如:<br>I don’t like that <strong>John calls my girlfriend</strong> day after day.</p><p>简化<br>→I don’t like <strong>John’s calling my girlfriend</strong> day after day.</p><p>如果从句用的是被动态, 则简化时可采用being ven(过去分词)形式. 更多关于从句简化问题, 在书的高级部分有详细讨论. </p><h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><p>→ 现在分词 &amp; 过去分词 → 都看作形容词</p><ul><li>现在分词 ving 表示“主动”、“正在进行”、“持续”意味. </li><li>过去分词 ven 表示“已经完成”、“被动”意味. </li></ul><h3 id="主被动的辨别"><a href="#主被动的辨别" class="headerlink" title="主被动的辨别"></a>主被动的辨别</h3><ul><li>His scores are <strong>disappointing</strong>. </li><li>He is <strong>disappointed</strong> at his scores.</li></ul><p>可以先还原为His scores disappoint him.(S+V+O), 再判断用哪种分词. </p><h2 id="带过-分词在简化从句中的应用"><a href="#带过-分词在简化从句中的应用" class="headerlink" title="带过 分词在简化从句中的应用"></a>带过 分词在简化从句中的应用</h2><ul><li>Toys <strong>which are made in Taiwan</strong> are much better now.<br>→Toys <strong>made in Taiwan</strong> are much better now.</li></ul><p><strong>After/Because he was wounded in war</strong>, the soldier was sent home.<br>→<strong>Wounded in war</strong>, the soldier was sent home.</p><h1 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h1><ul><li><p>someone、anybody等复合名词, 因为限定词（some、any）已经和名词的one、body写在一起, 所以中间形容词的位置被“挤掉了”, 形容词只能放在这些名词后. </p></li><li><p>另外有些<code>a-</code>开头的古英语形容词, 除了可以放在补语位置外, 如果要形容名词, 也只能放在名词后. 像是alone、alike这样的. </p></li></ul><p>书中解释道: </p><blockquote><p>“a-”词首代表一种暂时性的状态, 类似拉丁文“-ing”词尾的味道. 因而这一类的形容词不适合放在名词短语中代表属性的位置, 如在限定词与名词之间. </p></blockquote><ul><li>前面说过形容词也可以来源于名词, 这种情况与他形容的名词构成复合名词, <strong>此时作为形容词的名词是没有复数概念的</strong>. </li></ul><h2 id="形容词修饰顺序问题"><a href="#形容词修饰顺序问题" class="headerlink" title="形容词修饰顺序问题"></a>形容词修饰顺序问题</h2><p>概括成一句话: <strong>越接近本质和客观属性的形容词越靠近名词</strong>.<br>举个栗子感受下:<br>He’s wearing a <strong>handsome old brown U.S. Air Force leather flying</strong> jacket.</p><h2 id="带过-形容词比较级"><a href="#带过-形容词比较级" class="headerlink" title="带过 形容词比较级"></a>带过 形容词比较级</h2><p>-y → -ier → -iest</p><ul><li>形容词比较级前加不加冠词, 关键在于是作定语还是补语, 如果是补语则不加. (P118)</li></ul><h1 id="语气"><a href="#语气" class="headerlink" title="语气"></a>语气</h1><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E8%AF%AD%E6%B0%94%E6%A6%82%E8%A7%88.jpg"  style="zoom:40%" alt="" align=center /></p><h2 id="叙述事实语气"><a href="#叙述事实语气" class="headerlink" title="叙述事实语气"></a>叙述事实语气</h2><p>→ 用于现在与过去发生的事</p><ul><li>未来的事有不确定性, 需加will来表达这种不确定性. </li><li><strong>而对于一些虽然是要在之后发生但已经固定或是时间表上安排好的事情, 也使用简单事实语气. </strong></li><li>比较特殊的是, 当同时提到两件未来的事, 并且之间存在一定的关联性时, 常把作为前提条件的那件事先假定为事实进行叙述, 用叙述事实语气的现在时. </li></ul><p>如:<br>I’ll be ready when he comes.</p><p>再如: If you are late again, you’ll be fired.</p><h2 id="条件语气"><a href="#条件语气" class="headerlink" title="条件语气"></a>条件语气</h2><p>→ 句子中加上语气助动词（must、should、will/would、can/could、may/might）就产生了不确定语气, 书中称之为条件语气. </p><h3 id="关于语气助动词"><a href="#关于语气助动词" class="headerlink" title="关于语气助动词"></a>关于语气助动词</h3><p>需要注意几点: </p><ul><li><p>语气助动词表达时间的功能不完整. 如can be与could be并不表示时间上的差异, 而表示语气的不确定程度, 后者比前者更不确定. </p></li><li><p>接上, 因为表达时间的功能不完整, 于是<code>用完成式表达对过去的猜测</code>. </p></li></ul><p>如: </p><ul><li>1.It may rain any minute now.   </li><li>2.It may have rained a little last night.</li></ul><h2 id="假设语气（虚拟语气）"><a href="#假设语气（虚拟语气）" class="headerlink" title="假设语气（虚拟语气）"></a>假设语气（虚拟语气）</h2><p>→ “说反话”所说与事实相反, 用动词过去形态来表达“非事实”</p><h3 id="现在时间"><a href="#现在时间" class="headerlink" title="现在时间"></a>现在时间</h3><p>If I were you, I wouldn’t do it.</p><p>连带着主句中也用过去时, 用不代表过去的would来表示“非事实”. </p><h3 id="过去时间"><a href="#过去时间" class="headerlink" title="过去时间"></a>过去时间</h3><p>If I had know earlier, I might have done something.</p><p>时间本来是过去, 若还要用过去形态表“非事实”必须用过去时的完成式had known,主句也同样. </p><h3 id="未来时间"><a href="#未来时间" class="headerlink" title="未来时间"></a>未来时间</h3><p>If an asteroid should hit the earth, man could die out.</p><p>这是唯一在从句中出现语气助词的情况. 如果为了强调是绝无可能发生的事, 可以用be going to的过去形态were to来表示. </p><p>如:<br>If I were to take the bribe, I could never look at other people in eye again.</p><h3 id="混合时间需要分别判断"><a href="#混合时间需要分别判断" class="headerlink" title="混合时间需要分别判断"></a>混合时间需要分别判断</h3><p>如:<br>If I had studied harder in school, I could qualify for the job now.</p><p>不难看出从句是过去时虚拟语气, 而主句是现在时虚拟语气. </p><h3 id="混合真假也同样"><a href="#混合真假也同样" class="headerlink" title="混合真假也同样"></a>混合真假也同样</h3><p>如:<br>I could have contributed to the fund drive then, only that I didn’t have any money with me.</p><h3 id="其他句型"><a href="#其他句型" class="headerlink" title="其他句型"></a>其他句型</h3><ul><li>If only I had more time!</li><li>I wish I had more time!<br>假设语气的句型变化还有很多. </li></ul><h2 id="祈使语气"><a href="#祈使语气" class="headerlink" title="祈使语气"></a>祈使语气</h2><p>→ 又称为命令句, 总之还不是事实</p><p>这种语气可视为是条件语句中, 省略助动词表示“希望能成真, 但尚未实现”. </p><p>例如<br>Come in!<br>可以视为<br>You may come in!(你可以进来!)</p><h3 id="留意间接的命令句"><a href="#留意间接的命令句" class="headerlink" title="留意间接的命令句"></a>留意间接的命令句</h3><p>如:<br>The court demands that the witness <strong>leave</strong> the courtroom.<br>留意句中原形的leave. 法官要求证人离开法庭. 如果法官直接对证人提出要求, 会说: （You must）Leave the courtroom!</p><h1 id="介词短语"><a href="#介词短语" class="headerlink" title="介词短语"></a>介词短语</h1><p>→ 介词 + 名词短语 → 作为<code>形容词短语/副词短语</code>(P171)</p><h2 id="常见介词分类"><a href="#常见介词分类" class="headerlink" title="常见介词分类:"></a>常见介词分类:</h2><p>空间介词</p><ul><li>1.at → 点（能够视为一个抽象的点）</li><li>2.on, along → 线（路线）</li><li>3.on → 面, on the lake</li><li>4.in → 体（空间内部）</li></ul><p>时间介词</p><ul><li>1.at → 点 at 5:27 AM</li><li>2.in → 长时间,  in winter</li><li>3.on → 特定日期, on New Year’s Day</li></ul><h2 id="几个介词短语的辨析"><a href="#几个介词短语的辨析" class="headerlink" title="几个介词短语的辨析"></a>几个介词短语的辨析</h2><ul><li>1.on one’s way / in one’s way</li></ul><p>He’s on his way to Taizhong.<br>→ 抽象成一条路线<br>Step aside! You’re in my way!<br>→ 不能简单抽象成一条线, 而是一个具体空间通道</p><ul><li><p>2.arrive in / arrive at<br>区别与上面类似, 只是抽象成一个点来看的, 使用at. 不能的, 只能以具体空间体现的使用in. </p></li><li><p>3.made of / made from </p></li></ul><p>of接近中文中的“的”, 材料与成品关系直接, 如: </p><p>a chair made of wood.</p><p>from有“出自于”的意思, 故材料与成品有距离, 不是看就能直接辨识出材质的. </p><ul><li>4.between / among</li></ul><p>between有标示地理位置的作用, 而among没有. </p><ul><li>5.throw to / throw at</li></ul><p>to代表方向 扔给at当作一个点（作为目标）</p><ul><li><p>6.from…to / from…through</p></li><li><p>7.above / over</p></li></ul><p>above表示相对高度超过, over有标示定点的功能, 表示“在…上方”</p><ul><li>8.below / under</li></ul><p>与7相似, below表示相对高度低者, under”在…之下”. </p><h1 id="主语单复数判断"><a href="#主语单复数判断" class="headerlink" title="主语单复数判断"></a>主语单复数判断</h1><p>→ 本质上通过名词短语个数判断→限定词（冠词、no、all、every等）+形容词+名词=名词短语</p><ul><li>The senator and delegate 单数, 双重身份</li><li>The senator and the delegate 复数, 两个人</li></ul><p>对于<code>有非冠词的限定词</code>名词短语需要通过理解判断单复数. </p><p>如:<br>All work and no play <strong>makes</strong> Jack a dull boy.</p><p>All work与no play说的大致是同一件事. </p><p><code>无限定词</code>的名词短语也需要理解是否指的是一样东西. </p><p>如:<br>Bread and butter <strong>is</strong> not very tasty but very filling.<br>Bread and butter <strong>have</strong> both risen in price.</p><p>前一个应该指的是涂了奶油的吐司面包吧. </p><h1 id="判断句子主语是哪一个"><a href="#判断句子主语是哪一个" class="headerlink" title="判断句子主语是哪一个"></a>判断句子主语是哪一个</h1><ul><li><p>I, as well as you, am broke.<br>→I am broke as well as you.</p></li><li><p>2.<strong>Everyone</strong> but a few complete idiots was able to see that.</p></li></ul><p>but → 除了, 主语看肯定部分即Everyone. not与此类似. </p><ul><li>3.Not only you but also I <strong>was</strong> at fault.</li></ul><p>语气偏重在I部分, Not形式上否定you, 主语即为I. </p><ul><li>4.Either my father alone or both my parents <strong>are</strong> coming.</li></ul><p>or连接语法上离动词近的作为主语. Neither…nor…与此类似. </p><p>Does he or his friends want to go?<br>一般疑问句类似, Does/Do取决于靠近的he. </p><ul><li><p>5.主语中有every、each、either、neither等有表示“一”的字眼时, 后面名词都<code>使用名词单数</code>, 同时<code>配合单数动词</code>. </p></li><li><p>Everybody <strong>is</strong> to report have tomorrow.</p></li><li>Every student <strong>has</strong> several chapters to report on.</li><li>Each <strong>has</strong> to make a five-minute speech.</li><li>You <strong>have</strong> to make a five-minute speech each.</li></ul><p>上句each在这里作修饰, 提示主语是“你们”, 因此用复数. </p><ul><li><p>Each (of you) <strong>is</strong> responsible for half of the job.</p></li><li><p>6.以一些单位作主语, 需要看他是否应该看成一个整体. </p></li></ul><p>如:<br>Ten seconds <strong>is</strong> quite a record for the 100-meter dash.</p><ul><li>7.主语后有介词短语, 一般不用管介词短语进行判断. </li></ul><p>如:<br>Mrs. Lindsey, together with his sons, <strong>is</strong> on a European tour.</p><p>又如:<br>There is a list of things to <strong>buy</strong> in the handbag.</p><ul><li>8.如果主体只是表达“全部/部分”概念, 而看不出具体的东西, 需要根据后面的介词短语来判断单复数. </li></ul><p>几个栗子: </p><ul><li>All of these <strong>are</strong> Lishan pears.</li><li>All of the money <strong>has</strong> been spent.</li><li>Half of the pears still <strong>look</strong> good.</li><li>All but one of the pears <strong>are</strong> ripe.</li></ul><p>上句除了一个梨, 其他都熟了, 用复数. </p><p>None of the pears is/are really good to eatNone<br>→ no one, 可用单数, 但也可以看成没有具体含义, 根据后面的the pears判断为复数. </p><ul><li>9.集合名词, 如: staff、faculty、police、committee、crew等, 表示一个整体时用单数, 指成员时用复数. </li></ul><p>如: </p><ul><li>The committee <strong>is</strong> five years old.    </li><li><p>The committee <strong>are</strong> mostly Republican politician.</p></li><li><p>10.带过 某些以“-s”结尾的名词, 不一定是复数, 像是一些学课、疾病的字眼. </p></li></ul><p>如:<br>Mathematics <strong>is</strong> my forte(特长).</p><p>还有一些需要通过意思判断如: </p><ul><li>1.Statistics was born in the gambling house(赌场).</li><li>2.The statistics are not all accurate.指统计数字</li></ul><p>到这里, 笔记上记录的初级部分就告一段落了.<br>简单总结一下, 先是以5种重要的基本句型引入, 形成了句子的大致框架. 接着简单介绍了一系列句子中的组成部分, 像是各种词类、动状词、介词短语等, 以及重要的修饰语气的概念. 之后讨论了寻找主语与动词单复数问题. 让人印象最深刻的莫过于作者对于动词时态的讲解. 对于后面比较重要的是动状词的理解. 本书与其说是语法书, 不如说是解决理解英语句子难题的书更为贴切. 后面我们将会看到, 不像很多罗列一堆规则的语法书, 而是从句子构成与简化的来龙去脉中学习语法.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法俱乐部 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《语法俱乐部》笔记 0.预告篇</title>
      <link href="/grammarclub0/"/>
      <url>/grammarclub0/</url>
      
        <content type="html"><![CDATA[<p>前段时间自食了英文图书《小王子》, 配合着另一本译本狼狈地读完了, 还算愉快的阅读体验. 内容而言, 让我感到相见恨晚, 狂热了一阵子, 还特地看了同名电影, 但今天的主角并不是他. </p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=39227190&auto=0&height=66"></iframe><p>读前以为自己能很容易啃完这本英文版, 实则坎坷. 对我来说, 生词虽然也是一方面, 但深感自己的句子分析能力太弱, 不由地又回忆起以前遇到的单词都认识, 但理解总是有偏差的问题. 于是决定稍微补补语法方面的知识, 网上一查, 大家一致推荐旋元佑老师的<a href="https://book.douban.com/subject/1014914/" target="_blank">《语法俱乐部》</a>, 立马找来资源, 边看边做笔记, 阅毕感慨”为何不再早点遇到《语法俱乐部》呢“, 那种open mind的感觉着实让人爽快. </p><p>于是呢, 打算分享下书中思想的一些精华, 顺便就把资源也放上(虽然网上也不难找), 《语法俱乐部》貌似出版过两次, 一版繁体一版简体, 不过网上原版实体书还是有点难找, 大多也都是影印版. 网上看到有博主制作的<a href="https://www.gitbook.com/book/zhusandiao/grammar-club/details" target="_blank">Gitbook在线阅读版</a>, 以及PDF版在此<a href="http://pan.baidu.com/s/1kUSVcwf" target="_blank">有爱自取啦</a><em>^-^</em>（9o58）</p><p>开始之前, 先谈谈对于英语语法的感觉, 阅读《语法俱乐部》之后让我对此产生改观, 所谓语法, 不过是过来人总结英语中的规律得出来的东西, 虽然有比较多人认可的规则逐渐堆砌而形成语法体系, 但说到底是不存在所谓绝对”权威“的. 每个人根据自己的学习经验, 都可能对传统语法有不同的理解. 更有能耐者, 自己改进发展出一套语法规则来也未尝不可, 只是不能忘了语法存在的本质, 为的是正确清晰地用英语进行表达. 旋元佑老先生在书中所说就是经过思考, 自己整理出的规则, 东西还是那个东西, 但作为不同的概念加以分类, 力求减少初学者的学习阻力. </p><p>书中前言部分, 作者还分享了自己的学习经历, 提到了阅读法. 所谓阅读法, 就是放任自己的兴趣广泛地英语阅读, 不死抠一词一句, 而是连贯地看下去, 知道个大概意思就行了. 旋元佑先生认为初学者, 阅读的“量”要比“质”重要得多. 连先生自己也曾被“不求甚解”的阅读效果吃了一惊, 因而打开了英语阅读的大门. </p><p>说了一大堆, 正式开始吧. 400多页的本书自然涵盖不到所有语法现象, 权当抛砖引玉, 从另一个角度重新审视英语语法. 说起来笔记记了仅仅20几张, 打算写4篇作为一个特辑吧XP. </p><p>首先要说明的是全书的体系, 也是本篇的主要任务之一呢ˋ( ° ▽、° )</p><p>———————————————————-迷之分割线——————————————————————————————</p><p>全书大致分为三个部分, 初级、中级与高级. </p><p>在初级部分简单介绍了简单句的5种基本句型, 以及讲解构成句子中组成成分的各种词类. </p><p>在中级部分较详细地介绍了各类从句的组成方法. </p><p>而高级部分详细介绍了各类从句的简化方法以及倒装句的应用条件. </p><p>好了, 说明完毕. </p><p>记录下来的都是基于理解与记忆, 限于水平, 表达可能会有所偏差, 请参照原版图书, 欢迎讨论. </p><p>需要指出的是, 台湾方面与大陆方面对于语法中的一些说法存在细微差异, 但并不难意会. 另外从作者的”吐槽“中看, 两者传统较公认的语法体系应该相差不大.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.</p><p>预告篇 終わり</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法俱乐部 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Ghost Trick》幽灵诡计 clear</title>
      <link href="/ghosttrick/"/>
      <url>/ghosttrick/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/ghost%20trick%202.jpg" width="240" height="217" class alt="封面" /></p><p>前一阵子连玩了几天通了这个游戏, 没看攻略clear想想还有些成就感, 废话不多说, 吃我一发安利ʅ（´◔౪◔）ʃ</p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=4948291&auto=0&height=66"></iframe><p>《Ghost Trick: Phantom Detective》, 暂译作《幽灵诡计: 幻影侦探》, 体验下来可以说是一款剧情优秀、玩法有趣的推理解谜AVG游戏, 如大家所见最初是10年出在任天堂NDS平台上, 随后又陆续登录各地区ios平台. 本作由卡普空(Capcom) 出品, 《逆转裁判》生父巧舟负责企划. 从各方面素质来看毫不逊色于《逆转裁判》系列:有着和逆转相似的略显夸张的人物塑造, 风格相近的的配乐, 还有不输给逆转的剧情逆转. 除此之外是全新的玩法. 细细讲来, 两者的侧重不同, 如果说《逆转裁判》把重点放在证据收集以及逻辑推理的乐趣上, 那么《Ghost Trick》则能让玩家体验绝妙的解谜乐趣吧. </p><p>故事开始于主人公被杀而成为一个幽灵, 失去了生前记忆. 因为“某种原因”使主角得到所谓“死者的力量”——可以依附于一些无生命物体上进行操纵, 一盏喜欢扭来扭去名叫库纽利的台灯（同样也是一个幽灵的样子）告诉主角如何使用“死者的力量”, 并告诉充满谜团的主角, 幽灵在黎明之后便无法存在于世. 为了找到凶手以及弄清自己的身份, 接触可能目击到自己死亡的少女刑警凛音, 开始了仅此一夜的物语. </p><p>下面就本作耳目一新的玩法説明しましょう！<em>^-^</em></p><p>作为游戏中的重要概念“死者的力量”指的其实是两方面:其一为力量, 即能够附于物体进行操纵；其二为时间, 即能够回到死者死前4分钟. 解谜正是运用这两种能力在四分钟内改变死者死亡的命运, 从而最终改变未来走向. 本作在剧情上环环相扣, 难得的是兼顾了谜题设计趣味性与故事叙述的流畅性, 细节部分的处理与伏笔同样十分出色. </p><p>简单介绍到这里就结束了, 如果是逆转系列粉丝或是解密游戏爱好者, 一定会喜欢上这个有爱的游戏. </p><p><strong>依旧高能提醒, 以下内容涉及剧透, 为不失乐趣请谨慎阅读XD. </strong><br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=4948278&auto=0&height=66"></iframe><p>关于剧情什么的, 抛开一些剧情中不谈的保留部分, 整个事件来龙去脉还是很清楚的. </p><p>一切的起源都是十年前的那起案件, 年轻有为的系统工程师尤米尔被怀疑“泄露国家机密”而被当成间谍逮捕, 前程被毁. 被年轻刑警卡巴尼拉施压, 绝望的尤米尔抓住机会持枪逃脱, 在公园被另一个年轻刑警乔多追上, 僵持之下, 尤米尔挟持正在烤红薯的小女孩凛音. 就在这时天降陨石“阿斯塔尔”, 碎片直接击中尤米尔撕裂心脏, 但在陨石的神奇的辐射下, 又使得尤米尔的身体获得了非凡的治愈能力, 尤米尔成了介于生与死之间的存在, 获得了所谓的”死者的力量”而成为”操纵者“, 之后失忆的尤米尔附在路过的一只黑猫上逃走了. </p><p>逐渐回忆起一切的尤米尔去找他的未婚妻, 却得知未婚妻西塞尔以为尤米尔已死, 留下遗书自杀, 伤心的尤米尔将那只黑猫取名为西塞尔. 之后尤米尔一直孤独地生活, 悲痛渐渐酝酿成仇恨, 在成功从警局夺回自己因为陨石而不老的身体后, 开始执行复仇计划. 尤米尔也想让十年前毁了自己一切的人们, 承受同样的痛苦. 已然成为了一个悲剧. </p><p>拥有非凡能力（直接控制他人或物体）的尤米尔制造了两起被称作”不可能事件“的事件, 果然引起了一个迷之组织的关注. 尤米尔与组织做了个交易, 用阿斯塔尔”的秘密交换组织协助尤米尔的复仇计划. </p><p>复仇事件一, 尤米尔操纵乔多女儿佳诺为庆祝妈妈生日设计的连锁装置, 将惊喜逆转成悲剧, 连锁装置射杀了佳诺妈妈, 乔多庇护女儿, 顶罪入狱. </p><p>复仇事件二, 控制法务大臣在乔多的死刑判决书上签字. </p><p>复仇事件三, 带领组织杀手闯入乔多家, 射杀了宠物犬导弹与佳诺. 没想到的是导弹在死亡时受到尤米尔体内陨石“阿斯塔尔”的辐射也获得了”死者的力量“, 拼命追逐尤米尔到复仇的第四幕, 游戏开始的垃圾场. </p><p>复仇事件四, 终结一切的最后一个晚上, 尤米尔约出正在追查乔多妻子被杀事件真相的年轻刑警凛音, 控制凛音拿枪将自己射杀, 让监控拍下杀人罪证, 嫁祸凛音. 只是第一枪的时候凛音反抗激烈, 射偏却意外地打死了尤米尔一同带来皮箱内的黑猫西塞尔, 西塞尔在尤米尔体内陨石辐射下也获得”死者的力量“, 之后尤米尔附身黑猫逃离现场. </p><p>在场却什么也做不了的导弹告诉了失忆的西塞尔发生的一切, 并希望西塞尔能拯救他的主人, 但西塞尔听后仅关心自身, 听完便离开寻找自己肉体去了. 导弹没办法只好用”死者的力量“回到了尤米尔死前四分钟, 那竟然是在十年前, 导弹静静地等待着那个晚上的重现, 为了拯救自己的主人必须找到一个可靠的帮手…</p><p>导弹等了十年, 那个夜晚如期而至, 回到了游戏的开头…</p><p>这就是在进行游戏前玩家所不知道的故事, 后来知道导弹的能力是交换两个形状相似的物体, 确实不怎么实用, 无能为力也是无可奈何. 但十年的时间让导弹学聪明了, 稍加引导, 让失忆的四塞尔误以为尤米尔的尸体是他的, 自然去追查凶手和自己的身份, 进而与整个事件接触, 并告诉他只有一个晚上的时间, 这样才能让西塞尔尽快行动拯救自己的主人. 十年的时间让导弹的能力也发生了一些变化, 使他能够附身于物体上做微小动作. </p><p>游戏主人公正是一只叫做西塞尔的黑色猫咪. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/ghost%20trick%203.jpg" width="211" height="249.5" class alt="主角-西塞尔" /></p><p>说真的, 确实挺像坂本先生的（笑）.<br><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E5%9D%82%E6%9C%AC%E3%81%95%E3%82%93.jpg" width="222" height="300" class="alignnone" /><br>说起让我印象最深刻的解谜设计差不多是解救”公园守护神“、解救法务大臣以及在尤米尔眼前设计假装老法医与卡巴尼拉刑警的死亡. 前两个都花了比较长的时间, 最后的比较有意思, 稀里糊涂就给解出来了. </p><p>本作在人物塑造上十分用心, 每个角色都个性鲜明, 不过一些并没有透露姓名, 一些人物及事件还留有一定的发挥空间, 有生之年希望这个系列能推出续作. </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=4948312&auto=0&height=66"></iframe><p>一些有趣对话汇集gif(部分来自贴吧)<a href="http://tieba.baidu.com/p/905463492?pn=1" target="_blank">原帖传送门</a></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/a.gif" alt="你的思想也太危险了吧喂！？" width="459" height="341"  /><br>.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/e.gif" alt="凌音, 你有当灵媒师的潜质啊" width="459" height="341" /><br>.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/b.gif" alt="不不不, 警察先生你更可爱" width="461" height="347" /><br>.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/f.gif" alt="耿直的警察先生" width="459" height="341" /><br>.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/c.gif" alt="挨批的警察先生" width="461" height="346" /><br>.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/d.gif" alt="伤感的警察先生" width="465" height="340" /><br>.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/g.gif" alt="我也是" width="459" height="341" /><br>.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/Cabanela_dance.gif" alt="纯白lovely等你出场跳完犯人都跑了呀" width="256" height="156" /><br>.</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/z.gif" alt="迷之天手古舞(假装很忙的样子)" width="256" height="192" /></p><p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anli </tag>
            
            <tag> Tucao </tag>
            
            <tag> Ghost Trick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三月阅读小记</title>
      <link href="/readinglog160501/"/>
      <url>/readinglog160501/</url>
      
        <content type="html"><![CDATA[<p>想花点时间写点东西, 静下来想想确实还有这么一件事. </p><p>总而言之, 抽空翻了两本书, 更准确点说应该是一本半, 都在上次帮忙打扫图书馆时寻获——盛田昭夫<a href="https://book.douban.com/subject/1034962/" target="_blank">《学历无用论》</a>与久石让<a href="https://book.douban.com/subject/10467105/" target="_blank">《感动, 如此创造》</a></p><span id="more"></span>    <div id="cplayer-80180593"></div>    <script>      (function(){        function loadcplayer() {          if (typeof window.cplayerList === 'undefined') window.cplayerList = {};          if (typeof window.cplayerList["cplayer-80180593"] !== 'undefined') return;          if (!cplayer.prototype.add163) cplayer.prototype.add163 = function add163(id) {            if (!id) throw new Error("Unable Property.");            return fetch("https://music.huaji8.top/?id=" + id).then(function(res){return res.json()}).then(function(data){              let obj = {                name: data.info.songs[0].name,                artist: data.info.songs[0].ar.map(function(ar){ return ar.name }).join(','),                poster: data.pic.url,                lyric: data.lyric.lyric,                sublyric: data.lyric.tlyric,                src: data.url.url              }              this.add(obj);              return obj;            }.bind(this))          }          window.cplayerList["cplayer-80180593"] = new cplayer({            element: document.getElementById("cplayer-80180593"),            playlist: [{"name":"Don't Cry Little Girl","artist":"Saycet","src":"https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/music/Don't Cry Little Girl.mp3"}],            generateBeforeElement: true,            deleteElementAfterGenerate: true,            autoplay: false          });                  }                if (typeof window.cplayer === 'undefined' && !document.getElementById("cplayer-script")) {          var js = document.createElement("script");          js.src = 'https://cdn.jsdelivr.net/gh/MoePlayer/cPlayer/dist/cplayer.js';          js.id = "cplayer-script";          js.addEventListener("load", loadcplayer);          document.body.appendChild(js);        } else {          window.addEventListener("load", loadcplayer);        }      })()    </script><p>盛田昭夫不用多说, 索尼创始人之一. 1946年, 25岁的盛田昭夫和技术宅井深大一拍即合创办了索尼. 在擅于公关的盛田昭夫和专于研发的井深大互补配合下, 废墟之上诞生的索尼一次次引领了世界潮流. 索尼超前的理念与近乎偏执的研发投入让其几乎成了消费者口中“黑科技”的代名词. </p><p>而本书生于日本历昭和41年（1966）年, 即索尼为开拓美国市场, 1960年成立美国索尼之后的第6年. 大背景是日本过了“神武景气”（54-57年）经济高速增长时期, 随着经济全球化发展开放经济时代到来, 日本企业及产品面临全球竞争, 机遇与困难并行. 60年盛田昭夫借此机会举家搬到美国, 学习美国企业的管理理念. 本书便是在对比美国与日本企业管理方面的差异, 和一些个人管理企业的看法与心得. 学历无用论是盛田昭夫其中一个响亮的论点. </p><p>开始确实是被索尼和标题吸引了, 借机了解下美日企业文化的差异. </p><p>据盛田昭夫观察, 美国的企业十分注重效率. 具体来说, 企业期望每一个员工都能”称职”, 即为公司创造了多少价值, 同时也决定了每个员工的价值. 而与此相对应的员工跳槽与要求加薪的现象也十分地普遍, 谓之事业以人为本. 因此美国公司聘人也愈发慎重, 求职要求中非常清楚地描述了求职者应具备的技能要求、处理的具体事务等. 公司内的员工有较高的自由权且分工明确各司其职. </p><p>盛田昭夫认为这种美国式的人才雇佣方法是美国企业能在开放的经济环境中长期屹立不倒的重要原因. </p><p>反观相对讲究“人际关系”的日本职场, 盛田昭夫形象地描述日本企业为”社会保障中心“, ”游乐场“, 以及提到了根深蒂固的”论资排辈制度“. 盛田昭夫列举了从进入公司, 在公司工作过程中的种种不合理现象. 其中之一便是企业过分地看重求职者的学历, 与美国式的要求具体办事能力相比, 不免觉得略带“赌博”性质. 一旦员工进入公司, 为了维持个人忠心忠诚的形象, 不论企业是否真的适合自己, 或是否有前途, 都会一干干到底, 即便心有不满. 在这种情况下, 如果公司倒了, 可能反倒对于一些员工来说是一种解脱. 反过来, 公司为了回应员工的忠心, 即使员工没能确实达到公司的期待, 也不能轻易解雇. 员工抱着不求有功, 但求无过的心态在公司工作, 无积极性、工作效率可言. 正是这样的相互约束, 使日本职场的人才流动非常低. 不得不说这确实保障了稳定, 却也极大地制约了企业及个人的发展. </p><p>当然这在那个时代的日本是相对普遍的现象. 一直以来仿佛有这样的矛盾, 既然有企业的”保障制度”, 为什么还常听别人说日本人的工作压力山大. 其实这根本是两回事. 这里指的是普遍现象, 而具体到一家企业往往会存在差异, 同时工作压力大来源于很多因素, 特别是员工自己的一些原因, 是不能忽视的. </p><p>书的后半部分涉及一些具体的方法论及索尼在企业改革方面的创新与探索, 像是员工的阶段性考核等等, 由于没怎么了解过企业经营就先弃读了. 这本身是一个大而专的话题, 不擅发挥. </p><p>总的来说本作比较有时代背景感的. 学历无用, 说的只是一种意识形式上的不过分追求, 而并不意味着学问不重要. </p><p>虽然这么说, 不过时至今日, 日本恐怕还未真正走出这种风气. 上次看到一部电影《预告犯》, 虽然为了艺术效果放大了社会阴暗面, 但我想多多少少可以感受到它带来的压抑.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=442567&auto=0&height=66"></iframe><p>关于久石让, 从他的音乐谈起吧. 小时候第一次接触久石让的曲子, 恐怕都是在《天空之城》、《龙猫》等吉卜力的动画电影里, 吉卜力成就了早期的久石让. 那时还没有一个动画电影概念, 它是集很多人的心血制作而成的, 有导演、画师、配乐、声优等, 即便如此, 我们还是对一些电影中的旋律感到痴迷, 把片名作为了那些耳熟能详旋律的名字. 我想直到现在, 没去仔细了解过的朋友应该还会把那首《君をのせて》（《载着你走》）说成《天空之城》, 它也曾被改成各种版本, 都足以说明曲子与电影的影响力. 久石让的曲子单独拿出来听, 足以触及心底最柔软的部分, 而放在电影里, 又能与电影表达的主题契合, 实属难得. </p><p>《感动, 如此创造》原来是久石让的第三本书, 是自传性质的作品. 与众不同的是, 这是久石让首次以文字的形式记录他对音乐创作的见解. 说真的, 在读之前, 对久石让的印象也还停留在动画电影配乐的阶段. 从他的音乐中, 想象创作者是怎样一个人. 作品的大部分内容都在谈论音乐创作, 如音乐人如何保持感性与敏锐的直觉, 捕获灵感, 学音乐的可能会更有感触收获更丰. 话虽如此, 在一些工作生活的共性方面, 久石让的见解还是有一定的启发性的. </p><h3>创作者的态度</h3><p>久石让把创作者分成两种, 一种是以自己为中心, 以自己的价值判断去创作, 同时不允许创作受外界的影响, 谓之”纯艺术家”；另一种是以社会需求为导向, 置身于社会大众洪流之中进行的创作, 可以称之为”商业艺术家“, 社会上的大多数专业人士属此类. </p><p>从一而终的秉持后者是久石让的觉悟. 如此看清自己的身份与使命不是简单得来的. 在久石让大学期间和毕业此后十年, 前卫艺术是他的奋斗方向, 如“极简音乐”, 将旋律稍作变化不断重复, 以产生古典没有的节奏与和声. 但随后走进了一个创作的死胡同. 久石让终于停下之前的创作开始思考音乐对他的意义. 他觉得如果从事纯粹的音乐艺术创作, 难以避免要在一些理论上寻求其合理性, 这不是他所追求的音乐之路, 同时也考虑到自身特点, 退而想去成为“街头音乐家”这样与普通大众接触的角色, 以创作出接受度高的音乐为目标努力. 抱着这样的态度与觉悟, 接了不少配乐创作的项目, 结识了宫崎骏与吉卜力. 而时至今日, 久石让能在电影配乐方面有所作为, 也离不开前期他对极简音乐积累下的思考, 形成了自己独特的风格. </p><blockquote>无论是哪一个方向, 创作者期望创作好作品的心情并没有什么不同. 差别在于每个人在生命中对于有价值、有意义的东西的认知不同所谓出色的专业人士, 指的就是能持续不断地表现自己专业能力的人. 所谓的一流, 即拥有每一次都能够发挥高水平的能力. </blockquote><h3>创作就是要不断把自己逼至极限</h3><p>久石让认为非凡的作品大多来自无意识. 保持自身的感性与直觉, 捕获来自无意识的灵感, 并把自己逼至极限去跟随直觉的引导, 不断调整创作方向, 这是久石让一贯的创作方法. </p><blockquote>所谓的创作, 就是要让拥有如此多样面相的自己完全动起来, 同时又要剥除自己所意识到的东西, 如此一来, 自然就会享受个中乐趣, 不是吗？</blockquote><h3>扩展自我的关键</h3><p>谈到创作者应具有的素质, 久石让提到这么几点, 简单概括. 其一”量胜于质”, 说的是一个自身积累的过程, 放开眼界, 多走、多看、多听、多读、多想, 去尝试一些新鲜事物, 有时还会有意外的收获. 量与质并不存在矛盾, 因为随着量的积累, 对于信息的选择与辨识能力会得到提高, 是一种相互促进. 这也训练了包容力. </p><p>创作者还应该关注自身的感受能力, 保持对外物的敏感. 这一方面能更好地借外物催生出灵感, 另一方面更能抓住一些创作过程中的本质方面. 如何去培养这种能力, 无非是经验的积累. 也可以通过多欣赏一些好的作品, 曾经听到一句描述艺术的话记忆犹新, 说真正的艺术能让原本麻木的感觉重新变得鲜活. </p><p>当然仅有经验而不加活用是完全没有意义的, 反而会成为一个人的包袱, 变得畏首畏尾, 如果是让人变得狭隘的经验不如越少越好. </p><p>久石让不认为干什么事像别人说的“最好吃点苦…..”, 而最好能够不要吃苦. 把吃苦讲得很伟大的人, 对于他自己, 那些往事或许是其人生的全部, 但对于旁人而言毫无实际帮助. </p><blockquote>没有所谓轻松的人生, 每个人总有些不为人知的苦处, 因此不需要再去自寻辛苦. 以吃苦为自豪的人, 欠缺了冷静审视自己的第三者视角思考, 也没有客观观察的能力, 甚至无法感受知性</blockquote><h3>束缚住自我的“羞耻感</h3><p>任何人都有其独特的价值观, 当对别人的所做的事感到“哇！这么丢脸的事还真敢做啊！”的时候仔细想想, 自己所认为的那些“庸俗可耻”的事自己做不来, 在某种程度上对自己是不是一种束缚, 这种高高在上自以为是的态度也意味着可能会失去一些“自由”, 错失一些好的作品. 有时放开去做, 反而能收到意想不到的好效果. </p><blockquote>所谓的羞耻感, 就是想要好好展现自我的反向想法, 也是恐惧毫无保留呈现自己的心理. 脑中如果存在着这种意识, 大概就无法做出真正能够令人感到喜悦的作品吧</blockquote><h3>影视音乐的思考</h3><p>在欣赏一部电影的时候, 我们往往是认为在欣赏艺术作品, 会容忍电影中的一些不自然, 纯调戏智商的除外. 从这个角度说, 影视音乐便成了有意思的存在, 因为这种存在本身就是不自然的流泄. 而久石让一类的配乐师正是解决这类问题, 在音乐与电影之间寻求协调. </p><p>久石让对北野武导演大胆的执导风格大为敬佩, 导演的执导方针是:若演员演得做作, 不如什么都不做, 只是站着, 这样才能留给观众想象的空间. 这种运用写实手法拍出来的电影中, 沉默很多, 配乐很少. 久石让形容北野导演的电影呈现出的是一种不畏惧沉默的坚强. </p><p>除了北野武式电影这个比较极端的栗子, 久石让认为的优质配乐还有黑泽明的电影《野良犬》, 特别是最后高潮的配乐让人叫绝. 说的是二战结束后的混乱年代, 都是退伍老兵的刑警与其追捕的罪犯在郊外草丛中扭打在一起, 两人弄得满身泥泞. 这时附近一屋子里传来某主妇弹奏钢琴的声音, 是弗瑞德里希·库劳的小奏鸣曲. 一边是底层的退伍兵, 一边是有一定社会地位的中产阶级；一边是无奈随战争改变自己命运的落魄年轻人, 一边是享受安逸生活的高雅主妇. 对比之中, 寓意深远. 如果把钢琴换成配合打斗令人振奋的音乐, 绝对不会有那样的深度. 从中配乐的技巧性不言而喻. </p><blockquote>宫崎导演曾经说过: "（看完电影后）最好让一楼入场的人, 能够感觉自己是从二楼出场的. "对于这句话, 我深有同感, 我期盼观众从电影中能够获得某些有益的感悟, 无论是勇气也好, 或一则启发也罢. 我希望自己参与制作的电影能具备这种价值. 因此, 电影的配乐也应该是能活化观众脑细胞的作品才对. 能够带给观众想象空间的电影配乐, 才是我想要创造的东西</blockquote><h3>身处亚洲</h3><p>近年来, 久石让经常参与中韩的电影配乐工作, 从而能站在一个客观的角度, 看到日本在某些方面的局限性. 比如说提到的过于固守传统而缺少创新活力, 使发展陷于停滞, 又如过于注重技术的卓越, 忽视个人风格的塑造, 难自成一派等等, 由此也引申出一些社会教育方面的问题. 我想对于中国, 在一定程度上也受用. </p><p>身为亚洲一份子, 久石让梦想通过处于政治纷争之外的音乐创作的合作, 促进亚洲的文化交流. </p><blockquote>和日本比较, 亚洲其他各国的创作能量更加充沛. 创作者接触到这股能量时, 能被激发出更多的想法</blockquote><h3>创作者的理想</h3><p>久石让不喜欢现代社会所谓只想成为“only one”的说法, 而是有着要做就做第一名的决心, 无法认同对于无法成为第一也无所谓的想法. </p><blockquote>人生随时都要力争上游. 这并不是随口说说、充场面的话. 这是生活在都会型社会的人们, 应该有的态度. 当然, 如果从未曾想过生活在这种体制中的人, 可以过自己喜欢的人生, 只要好好打造自己的世界就好了. </blockquote><p>在还年轻的时候, 久石让一直惧怕着自己跟不上时代的那天到来, 那时觉得50岁会是一个节点, 如今看来还远远没到放手时候, 写这本书的时候已经55岁了. 久石让有时也会听一些流行歌曲, 把注意力放在大众流行的原因上, 就能揣测出当下的时代潮流. </p><blockquote>创作者的理想就是能像毕加索那样, 即使上了年纪, 仍旧不断挑战自己, 一辈子都持续不断地创作. 现在, 我认为从事创作工作应该没有结束的一天. 这辈子, 我希望都能当个创作者. </blockquote><p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>推荐几首久石让的曲子<br>《6番目の駅》: </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=443842&auto=0&height=66"></iframe><p>出自《千与千寻》, 水上列车背景乐, 一种怅然所失感, 前途未卜</p><p>《風のとおり道》:   </p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=25727281&auto=0&height=66"></iframe><br>出自《龙猫》, 自然的神秘, 对自然的虔诚, 乡下的童年</p><p>《いつも何度でも》:  </p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=443860&auto=0&height=66"></iframe><br>出自《千与千寻》, 这是经常被误认为是久石让的曲子, 其实是由木村弓与觉和歌子创作, 宫崎骏提议代替原本是久石让创作的主题曲</p><p>而《千与千寻》中久石让创作的主题曲《あの夏へ》: </p><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=443794&auto=0&height=66"></iframe><br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Nichijou </category>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>除草机 三月号</title>
      <link href="/mower160405/"/>
      <url>/mower160405/</url>
      
        <content type="html"><![CDATA[<p>除草作业中…</p><p>三月过去了, 度过了回校之后的四个星期了. 发生了不少事, 也了解了不少东西, 算是小小地满足了一下求知欲. 渐渐感觉大学里的时光真的要珍惜, 正如我在沪江上看到的一篇文章《趁着20几岁, 大学生必做的七件事》所说的, 是一个「権利はあって義務はない世代」. </p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=38358664&auto=0&height=66"></iframe><p>最近天气渐渐转暖, 北方的春天, 一些行道树还光秃秃地没有抽芽呢. </p><p>最近也逐渐习惯晚上到操场跑几圈, 天气好抬头也能看到不少星星嘛. </p><p>稍稍回顾了下这四个星期, 翻看我的记事本大概写了六篇小记, 主要还是自我探索方面的, 简单谈谈一些内容和想法吧. </p><p>其一, 在回校之前去北京逛了逛, 缘于心中苦闷想散散心, 顺便拜访在北京生活的亲戚. 景区自然也是逛了的, 不过除了累以外真没给我留下多少印象, 最后一天我像傻子一样在新华书店呆了半天. </p><p>我在漫画区漫不经心地抽了本漫画翻看起来, 名字什么的已经记不清了, 是一本画国内一些漫画家成长经历的漫画, 老实说看了他们早年的经历让我有点触动, 从那本漫画里仿佛看到了小时候的自己, 但他们与我走的是完全不同的道路. </p><p>虽然看过不少漫画, 但对漫画这行业我没怎么了解过, 更没有关注过中国漫画业的发展现状. 那些现在看来比较知名的漫画家, 在他们青年时代付出了怎样的努力去追逐自己的梦想, 心中怕是有了点眉目, 从亲戚的口中了解到的所谓“北漂”意味着什么. </p><blockquote><p>“真的老妈, 我就想成为那样的人”</p></blockquote><p>因为儿时的这样一句话, 坚持到现在的人真的存在着. 无论成功与否, 都打从心里敬佩这样的人. 相比经历各种各样已经对一些事物失去信心的我, 有点耀眼. </p><p>其二, 谈谈最近的工作, 由于好奇Web方面的内容寒假简单地啃完了HTML与CSS, 打算再主动接触下计算机网络, 额, 概念好多, 还比较难实践, 虽说也硬生生啃完了, TCP/IP不知道还记得多少, 感觉都了解了, 却又不知道怎么用的感觉, 仅仅看了两遍效果也不怎么好呢. 下一步还是找找实践的机会吧. </p><p>同时开始学习C++. </p><p>四个星期也有看点杂书啦, 会写在杂文里吧（大概）. </p><p>总之这段时间大幅减少了娱乐时间. </p><p>反思也是有的, 想到就去尝试固好, 能不能沉住气表现出从容与坚持会是这个学期的命题吧XD</p><p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Nichijou </category>
          
          <category> 杂文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Lifeline》生命线 clear</title>
      <link href="/Lifeline/"/>
      <url>/Lifeline/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/Lifeline1.jpg" width="290" height="366" alt=封面"" /> </p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=19278445&auto=0&height=66"></iframe><p>……………………………………………..[通讯正在接入]……………………………………………</p><p>……………………………………………..[正在建立连接]……………………………………………</p><p>……………………………………………..[正在接受消息]……………………………………………</p><p>喂喂？</p><p>这玩意儿能用吗？</p><p>有谁能收到吗？</p><p>……………………………………………………………………………………………………………..谁在说话？</p><p>啊呀呀呀, 不好意思. 我应该先自我介绍一下的. </p><p>我只是收到回复太激动了. </p><p>我是泰勒, 我是, 原本是瓦里亚号星际飞船上的一名宇航员. </p><p>.<br>.<br>.<br>.<br>.<br>.<br>.</p><p>断断续续玩这个游戏几个星期, 终于迎来了终结. </p><p>Lifeline中文翻译为生命线, 这是一个科幻逆境生存题材的文字冒险类游戏, 由3 Minute Games 15年在ios平台上开发. 这款风格极其简单的游戏曾在App Store付费榜取得不错成绩, 现在与其续作Lifeline2与Lifeline silentnight在商店售价1元. </p><p>凭借着良好的口碑和1元良心价, 原本应该入正的, 奈何适配最低需ios8以上, 我的小4s驾驭不了. 无解, 幸好（这里应该用这个词吗）国内有人把这款游戏汉化移植到了安卓平台, 当然国内尿性广告少不了, 而官方安卓版又遥遥无期, 于是就下在了家母的安卓机里了. </p><p>如前面所见, 这是一款玩家与游戏主人公泰勒通讯的AVG游戏, 没有复杂设置, 界面极其简单（如果无视广告）, 只有玩家与泰勒的对话框. 操作极其简单（如果没有误触广告）, 二选一的选项框点击选择其一, 你的选择将改变故事走向. </p><p>游戏讲了宇航员泰勒搭乘的飞船失事在一个荒芜星球上, 幸运地与在地球上的你取得通信, 并帮助他逆境求生的故事…</p><p>其实文字冒险类对我来说不算陌生, 但还是不得不佩服Lifeline的代入感, 有时真念念不忘那个话痨宇航员. </p><p>我想这一方面是因为单调的bgm, 没错整个游戏只有一个bgm. 单调略带沉闷的旋律让人很容易静下来投入游戏, 结合主题又有那么点神秘感, 仿佛自己真的是泰勒唯一的那根救命稻草. </p><p>另一方面像「君と彼女と彼女の恋」一样得益于游戏系统, 为了让游戏更加真实, 当遥远星球上的泰勒在专注干一件事情, 比如睡觉吧, 泰勒跟你告别后, 游戏提示Taylor is busy.此时就不能再与泰勒通话. 这样的时间有长有短, 几分钟, 几个小时都有. 那么问题来了, 如果泰勒就这样睡了没有再起来, 游戏作何结束, 虽然我后来知道了答案, 这里就不说了. 这样的设定把游戏的可控性从玩家手里夺了过来, 而一切又是那么真实自然. 当泰勒又重新发来信息, 会出现在首页标签, 与普通短信无异. 你好呀, 话痨宇航员, 我们又见面了. </p><p>终于回到泰勒身上了, 是的, 我们的宇航员泰勒是一个可爱的话痨, 有事没事跟你扯点别的, 我得说得亏了这天生的幽默感, 在那样的环境下我比他更着急, 虽然他不断跟我抱怨这抱怨那…而羁绊也是如此诞生的吧. </p><p>游戏的流程不算长, 虽然有另类的系统, 但足以了解整个故事全貌. 同时游戏虽然设置了Bad End, 但只要不“超常规”发挥, clear应该还是容易的, 更何况还有优等生泰勒的提醒, 除了一个莫名奇妙的物理能量问题可能需要问度娘外. 游戏有多个结局, 我只达成了一个, 传说存在最完美结局. </p><p>不错的体验, 如果有机会会尝试两部续作Lifeline2与Lifeline silentnight, Lifeline2讲的是魔法世界姐姐救弟弟的故事, 而Lifeline silen tnight静夜讲的是泰勒获救后的故事. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/lifeline2.jpg" width="253" height="450" class alt="Lifeline2封面" /> </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/Lifeline%20silent%20night.jpg" width="290" height="515" class alt="Lifeline silent night封面" /> </p><p><strong>游戏简单介绍到这里就结束了, 下面的内容涉及故事情节, 为避免剧透谨慎阅读. </strong></p><p>顺便一提, 文章前面插入的BGM来自瑞士后摇乐队The Evpatoria Report的Taijin Kyofusho. 曲子前面的人声取材于NASA通讯资料, 那是一个悲痛的回忆, 03年2月1日美国哥伦比亚航天飞机返回地球解体, 7名宇航员全部遇难, 这段人声片段是休斯顿指挥中心与飞船宇航员的最后联络. 觉得很应景放在这里. 向所有为人类太空事业做出巨大牺牲的人致敬. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E5%AE%98%E5%9B%BE.jpg" width="580" height="870" class alt="官图" /> </p><p><strong>再次高能提醒, 现在走还来得及, 要知道一款文字AVG游戏, 剧情是灵魂. 如果对本作感兴趣不如留个悬念. </strong></p><p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.</p><p>下面是对Lifeline的吐槽与猜测. </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=31152621&auto=0&height=66"></iframe><p>其实对于故事结局倒不是那么得意外, 可能是欺骗类的游戏接触多了. 泰勒星人(姑且这么叫他们吧)的阴谋也算合情合理, 我做的选项发生的剧情中已经有了足够的暗示. </p><p>其一是泰勒绿色的口水, 不知多少次泰勒向我抱怨他身上这恶心的变化；其二是失踪的老鼠尸体；其三是泰勒形容发着绿光的眼睛, 发出打孔声音的迷之物体；其四是远处看似非自然形成的极对称的山. </p><p>第一次接触泰勒星人应该是在救生舱那, 天色渐晚, 安全起见, 我建议就地休息. 在此之前泰勒搜索飞船时就遭遇了那些迷之生命体, 我原本建议一探究竟, 泰勒像见了鬼一样不断劝说放弃, 指南针又莫名失灵, 只好作罢. 于是我建议他修好警报, 晚上警报竟然响了一次, 我安慰他先别管警报尽早休息. 第二天检查警报竟拍到了人影…</p><p>在这个泰勒星上唯一看到另外的人就是瓦里亚号上的船员, 但发现他们时, 已经全员遇难了. 其实前面的一些选项还有一条线好像是阿雅船长能幸存. </p><p>然后泰勒就起身前往那座怪异的山, 并发现了山脚的一个入口. </p><p>泰勒说山壁上写着中文, 为什么是中文, 难道是翻译的问题, 不, 在英文版里确实是说Chinese, 难道歪果仁看到看不懂的文字都会认为是中文！</p><p>让人吃惊的是山还会消失, 这什么黑科技, 泰勒在里面会断开联系. 不过听泰勒说存在时差, 这边的几秒相当于泰勒那边的十几分钟. </p><p>泰勒找到了一个类似控制中心的地方, 放满了显示屏, 还有那几只失踪的老鼠. 在不小心触发警报后, 一切都开始疯狂转动了起来, 自相残杀的老鼠们、飞速赶来进入警报视野的五个人影、显示屏幕上被某种武器锁定即将降落的飞船、若影若现的山峰以及另一个监视画面上无数的飞船残骸…剧情走上高潮, 而泰勒终于发现了真相. </p><p>其实在了解真相之前, 我大概脑补一个真相, 类似于欺骗实验. 一切都是泰勒的幻想. 出于某种需要, 被抽签抽中的泰勒参加了这次实验, 组织对外宣称是空间探索. 有点类似《楚门的世界》这样的感觉, 不过这样玩家是怎样的存在就不好解释了, 毕竟这种得是第一人称的, 有个旁观者什么的…</p><p>相比之下, 原作真相能很好解释这些. 泰勒星人为了寻找宿主, 即肉身容器, 引导天外来客失事在这个星球上, 同时利用飞船上的资源建造了这个控制中心. </p><p>老鼠自相残杀不会流血, 皮肉撕裂后爬出一个长满小眼睛的粘稠生物, 并试图再进入老鼠的躯壳内. 我哔一一, 这不是《极黑的布伦希尔特》里的外星生物吗(╯‵□′)╯︵┻━┻. </p><p>那五个人影赶到后果然是失事船员, 不过眼睛里闪着绿光. </p><p>根据整个剧情分析, 可以大概推测出一些东西</p><ul><li><p>泰勒星人在地表生存能力很弱, 因此需要生物的肉身容器, 就像人类需要宇航服一样吧. 侵入后能灵活控制原生命体的动作, 泰勒与其他船员对峙时可以看出. </p></li><li><p>泰勒星人应该也有幼体与成体之分, 侵入老鼠的应该是幼体一类, 因为没有对泰勒有明显的攻击欲望, 并会吃泰勒扔给老鼠的鼠饲料, 嗯…嗯？！</p></li><li><p>根据泰勒说泰勒星人是从口入侵的, 这个星球上可供人呼吸的空气也可能是泰勒星人的阴谋之一, 从泰勒的身体反应来看, 很可能是为了让宇航员摘下呼吸面罩, 同时让生物体内产生什么变化以利于寄生, 这是我的脑洞. </p></li><li><p>泰勒星人的设定更加接近于僵尸吧. </p></li></ul><p>最后泰勒成功警示了降落的飞船, 并趁乱逃出控制中心奔向飞船. 山峰开始崩坏, 无数类似生命体从地缝里溢出. 由于飞船降落太远, 泰勒跑到一半会放弃, 并产生寄生前反应, 语无伦次, 这时需要玩家嘴炮给泰勒活下去的信念. </p><p>奋力逃命到飞船上, 游戏结束, 之后的故事会在静夜中有所交代吧. </p><p>游戏最让人动人的确是BadEnd. </p><p>終わり<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.</p><p>……<br>唔, 听着. 我只是……只是太累了. 我现在就想躺下.<br>也许我只是, 你知道的, 只是喜欢夸张. 也许我在这里不会有事.<br>只要睡一觉, 我就会像洗了八个钟头的冷水澡一样清醒.<br>只是, 嗯……万一我没醒过来的话……<br>我想对你说声谢谢. 感想你用声音在黑暗中一直陪伴着我.<br>这是我所经历过的最深沉的黑暗, 所以……我真的很感激你.<br>这里真的好美, 看天上这些星星. 成千上万, 成千上万的星星.<br>你要是能看到该有多好.<br>我……稍微合会儿眼.<br>……<br>……<br> [ connection terminated ]</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/I%20wish%20you.jpg" width="400" height="566" class alt="I wish you could see this" /> </p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anli </tag>
            
            <tag> Lifeline </tag>
            
            <tag> Tucao </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWM实现DAC尝试</title>
      <link href="/pwmdac/"/>
      <url>/pwmdac/</url>
      
        <content type="html"><![CDATA[<p>不久前在数电中自学了DA与AD的内容, 书中介绍的主要是基于ADC, DAC芯片实现的数模之间的转换. 而实现DA还可以通过单片机输出PWM的方法. </p><span id="more"></span><p>网上找了相关资料, 一些作者的文章写得很不错, 让我这个“门外汉”也能简单了解PWM技术. 虽然不高深, 但这个过程中, 有数电, 模电和数学的综合运用, 这让我有点兴趣, 可以搞一搞. 尽管因为经验不能像那些文章那般专业, 但至少能把我的理解再简单地表述出来. 下面先从一些概念下手. </p><p>PWM（Pulse Width Modulation）, 又称为脉冲宽度调制, 是利用MCU输出的数字信号（一般就是调制的矩形波）进而去产生控制模拟信号（各种其他波形等）的方法. PWM一般应用在测量通信方面（度娘如是说）. PWM在这些领域如何风光暂且按下不表, 这次只对利用计时器I/O口输出PWM实现DA做思考. </p><p>顺便记一下, 单片机要实现PWM, 有两种方法:一种是利用计时器设置, I/O口输出PWM；另一种使用模块输出PWM. 一些功能强劲的MCU自带PWM模块用于产生PWM脉冲信号, 使用前对特定寄存器赋值, 比直接用计时器方便点. 如STC12C5A60S2系列,  AVR和PIC等等. </p><p>大致的原理是这样的, 利用MCU的timer控制产生特定占空比频率的矩形波, 由傅里叶级数分析知道, 矩形波形函数可以分解为各级三角谐波, 所以运用模拟电子中的低通滤波器, 滤去高次谐波, 低频部分如果视为理想的话, 就能作为DA转换的直流输出. 因此关键是解决三个问题:</p><ul><li>1.如何调节矩形波频率产生所需占空比, 程序上如何实现. </li><li>2.理想条件下, 滤去高次谐波后所得电压与控制量之间的关系, 具体来说数学表达式是怎样的. </li><li>3.低通滤波器设计, 如何使其滤波效果较好.<br>附带一个</li><li>4.如此构建的DA转换分辨率如何及误差. </li></ul><p>为了说明简单, 先假设通过PWM设定输出了一个稳定周期不变矩形波, 然后引入一些变量, 思路大概是这样: </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/PWM%E5%AE%9E%E7%8E%B0DA%E8%BD%AC%E6%8D%A21.jpg" width="604" height="288" alt="调制波形" /></p><p>上图是调制后产生的稳定的矩形波, 参数说明如下: </p><ul><li>T  -  由单片机定时器设定的最小取样时间间隔</li><li>N  -  一个周期包含的最小时间间隔数, 图中是10</li><li>n  -  一个周期内输出高电平的最小时间间隔数, 图中是7<br>函数方程: </li></ul><script type="math/tex; mode=display">f(t)=\left\{\begin{array}{ll}V_{H}, & kNT \le t \lt kNT+nT \\ V_{L}, & kNT+nT \le t \lt kNT+NT\end{array}\right.</script><p>采用展成复指数形式的傅里叶级数分析可能更简单些. 众所周知, 其级数系数$a_{k}$计算公式即: </p><script type="math/tex; mode=display">a_{k}=\frac{1}{T}\int_{T}x(t)e^{-jk \omega_{0}t}dt</script><p>简便起见, $V_{L}$视为0. </p><p>考虑$k=0$时, 在一个周期内积分得$a_{0}$:</p><script type="math/tex; mode=display">a_{0} = \frac{1}{NT}\int_{0}^{nT}V_{H}dt = \frac{n}{N}V_{H}</script><p>这就是直流分量部分.<br>再考虑$k \neq 0$时: </p><script type="math/tex; mode=display">a_{k} = \frac{1}{NT} \int_{0}^{nT}e^{-jk \omega_{0}t} V_{H} dt = \left.-\frac{1}{jk \omega_{0}NT} e^{-jk \omega_{0}t} \right|_{0}^{nT} = \frac{Sin(\frac{1}{2}k\omega_{0}nT)}{k \pi}e^{-\frac{1}{2}jk \omega_{0}nT}</script><p>这是滤波器需要去除的高次谐波部分.<br>从计算结果中可以看出, 如果能滤去较高次谐波, 只剩下$\frac{n}{N}V_{H}$, 当n从0变化到N, 输出电压范围从$V_{L}\sim0$. 设计滤波器需要计算计算截止频率以一次谐波频率为参照. 若使用最简单的RC低通滤波器, 特征频率应设置为$f_{0}=\frac{1}{NT}$,又因为RC滤波器$f_{c}=\frac{1}{2\pi RC}$, 应使$f_{c}$大于$f_{0}$, 得到NT小于2πRC,应该先设置好N与T再选择R与C, 在程序中N与T应该是设定不变的. </p><p>再稍微考虑下如何设置T与N, 这关乎到DA转换的精确度与分辨率. </p><p>说DAC芯片的时候有分辨率这一概念, 用以描述DA转换精度, 定义成能分辨出来的最小电压与最大电压之比. 比如10位DAC芯片, 分辨率表示为$\frac{1}{2^{10}}$. </p><p>而在用脉宽调制的方法时, 也是同样, 即n=1与n=N之比, 分辨率简单表示为$\frac{1}{N}$. 当然n也可以不以1作为变化间隔. 如令N=1024, 应该就可以大致模拟出10位DAC. </p><p>这里就引出一个矛盾, 增大N的设定值, 能够提高分辨率, 但也会增大NT, 使得高次谐波的频率降低, 这又为低通滤波器的工作带来麻烦, 会夹杂更多的纹波而降低精确度. 因此并不是N越大越好. 同时在选择R与C时, 也可以考虑留一些余地. </p><p>那么减小T如何呢, 这是个不错的选择, T往往受限于单片机的工作频率与其速度性能. </p><p>叙述完毕, 先用Proteus绘制仿真电路, 最终方案采用RC二阶无源低通滤波, 为能有一定带载能力输出采用电压跟随器. 如果是需要驱动大功率设备, 需要再加个功放. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE.jpg" style="zoom:50%" class="aligncenter" /></p><p>程序的实现是这样的(先让n固定, 也就是输出电压不变):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;        <span class="comment">//初始化计时器0函数</span></span><br><span class="line">sbit pwm = P2^<span class="number">1</span>;    <span class="comment">//P2.1口输出pwm脉冲</span></span><br><span class="line">uint count = <span class="number">0</span>;     <span class="comment">//用于计数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">900</span>)  <span class="comment">//count由计时器设定每1us加1, 900这个位置</span></span><br><span class="line">            pwm = <span class="number">1</span>;      <span class="comment">//就是n, 这里先固定为900</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pwm = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TMOD &amp;= <span class="number">0x0f</span>;</span><br><span class="line">    TMOD |= <span class="number">0x01</span>;</span><br><span class="line">    TH0 = (<span class="number">65536</span> - <span class="number">1</span>) / <span class="number">256</span>;  <span class="comment">//定的时间即上文提到的T, 为了精确这里定时1us</span></span><br><span class="line">    TL0 = (<span class="number">65536</span> - <span class="number">1</span>) % <span class="number">256</span>;  <span class="comment">//是不改变时钟周期下的极限</span></span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer0</span><span class="params">()</span> interrupt 1   <span class="comment">//计时器0中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TH0 = (<span class="number">65536</span> - <span class="number">1</span>) / <span class="number">256</span>;</span><br><span class="line">    TL0 = (<span class="number">65536</span> - <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1024</span>)  <span class="comment">//1024的位置就是N, 这个一般设定不变</span></span><br><span class="line">    &#123;                  <span class="comment">//如果count计数到头了清零重新计数</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略仿真波形结果</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E4%BB%BF%E7%9C%9F%E6%B3%A2%E5%BD%A2.jpg" width="302" height="301" alt="Proteus仿真波形" /></p><p>从上到下ABCD通道分别是:<br>A - P2.1口输出调制后的矩形脉冲<br>B - 经过一次RC低通滤波<br>C - 二次RC低通滤波<br>D - 电压跟随器输出</p><p>由于定时器定时1us, 已经达到了指令周期级别, 输出的矩形波会有一些不稳定, 这恐怕是这种方法难以避免的. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E6%B3%A2%E5%BD%A2%E9%97%AE%E9%A2%98.jpg" width="598" height="214" alt="不稳定的波形" /></p><p>利用protues中的电压探针可以更为精确的测定输出的电压与程序中设定n的关系. 为了计算简单把N设定为1000吧. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpg" width="543" height="209" alt="测试结果" /></p><p>从仿真测试结果来看, 还是可以的嘛o(*￣▽￣*)ブ</p><p>简单地应用下实现 LED呼吸灯<br>在原来程序上稍微改改, 嗯…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> uchar unsigned char</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">sbit pwm = P2^<span class="number">1</span>;</span><br><span class="line">uint n = <span class="number">0</span>, t = <span class="number">0</span>, flag = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span>(t &gt; <span class="number">100</span>)   <span class="comment">//这里设定n的变化快慢, 100us变化一次亮度</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>)  <span class="comment">//flag用于控制n的递增与递减</span></span><br><span class="line">            &#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1000</span>)  <span class="comment">//当n到1000时递减, 到0时递增</span></span><br><span class="line">        &#123;               <span class="comment">//led从暗到明, 再从明到暗, 制造呼吸效果</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; n)   <span class="comment">//这里使用n, 因为输出电压需要变化</span></span><br><span class="line">            pwm = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        pwm = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TMOD &amp;= <span class="number">0x0f</span>;</span><br><span class="line">    TMOD |= <span class="number">0x01</span>;</span><br><span class="line">    TH0 = (<span class="number">65536</span> - <span class="number">1</span>) / <span class="number">256</span>;</span><br><span class="line">    TL0 = (<span class="number">65536</span> - <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer0</span><span class="params">()</span> interrupt 1</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TH0 = (<span class="number">65536</span> - <span class="number">1</span>) / <span class="number">256</span>;</span><br><span class="line">    TL0 = (<span class="number">65536</span> - <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考: <a href="http://www.doc88.com/p-771863132888.html" target="_blank">《基于PWM实现DA转换电路设计》</a><br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> 电子工学 </category>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> C/C++ </tag>
            
            <tag> CFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Altium Designer画电路板初体验</title>
      <link href="/altiumdesigner/"/>
      <url>/altiumdesigner/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/Altium%20Designer%E5%90%AF%E5%8A%A8.jpg" style="zoom:40%" alt="" /></p><p>第一次尝试使用Altium Designer画pcb电路图（算作一个插曲）, 在经过一些尝试后把简单的使用方法及体验做下笔记. </p><span id="more"></span><p>写完了再来写几句, 虽然学会了简单绘制, 但还是有很多内容不甚了解, まだまだです. 文章很长临时增加了个目录. 有些内容自己探索, 如发现错误持续更新. 0(:3　)～ =͟͟͞͞(‘､3)_ヽ)＿</p><h1 id="Altium-Designer简单介绍"><a href="#Altium-Designer简单介绍" class="headerlink" title="Altium Designer简单介绍"></a>Altium Designer简单介绍</h1><p>已经不记得是什么时候知道的这个软件, 但是在一些pcb设计者眼中神器一般的存在吧. 在以前一直用Multisim画电路图的本渣渣, 在打开这个软件后完全不知道干什么, 没有元件, 没有导线, 只好从零一步步尝试.<br>Altium Designer是Altium公司推出的win平台上的一款一体化的电子产品开发系统（亲测在最新的win10系统上兼容性良好, 就是这软件在高分屏表现略尴尬, 后面会说明）, 其前身是Protel,  Altium Designer 在继承先前Protel软件功能的基础上, 综合了FPGA设计和嵌入式系统软件设计功能. AD是电路设计自动化技术 EDA的代表, 融合原理图设计、电路仿真、PCB绘制编辑、拓扑逻辑自动布线等技术. 编辑完成可以把工程或生成的gerber文件发至工厂生产制造.<br>AD功能强大, 但前期很多功能还用不上, 先熟悉学会一些简单操作和绘制有利于以后的学习. 这次的目标就定为绘制51最小系统的pcb及原理图. </p><h1 id="绘制之前"><a href="#绘制之前" class="headerlink" title="绘制之前"></a>绘制之前</h1><p>AD绘制电路图与另一个我接触过的另一个电路仿真软件protues有点类似, 需要自己去设定甚至绘制一些元件.<br>AD制图的一种流程（我见过的）是先绘制原理图库（schematic library）, 再绘制封装库（pcb library）, 使用model manager使原理图库与封装库建立对应联系, 并合成一个集成库（Integrated Library）. 当然除原理图库与封装库外, 还可以有一个3D库, 包含在封装库中, 给元件增加3D封装, 在放置元件时能通过3D视角观察, 更加直观. 但3D封装是可选的, 就我现阶段试验来看是比较困难的（如果是自己建立集成库）, 在画电路图时可能会跳过这一步吧. 建立了集成库就算是完成了一半, 之后便能新建原理图（schematic）与PCB, 用制作完成的集成库中的元件设计电路, 完成后编译执行, 能把原理图中的电器关系同步更新到PCB文件中. 再在PCB中合理放置元件与布线、敷铜就算完成了.<br>而另一种是先建立原理图与PCB, 需要什么元件再去新建库去找去画, 完成一个元件马上用于原理图绘制, 其实与第一种流程并无本质区别.<br>因为是自己学的, 打算先尝试第一种流程完整地熟悉一遍, 嗯. </p><h1 id="画原理图之前的准备-建立自己的集成库"><a href="#画原理图之前的准备-建立自己的集成库" class="headerlink" title="画原理图之前的准备, 建立自己的集成库"></a>画原理图之前的准备, 建立自己的集成库</h1><h2 id="起步还是新建工程"><a href="#起步还是新建工程" class="headerlink" title="起步还是新建工程"></a>起步还是新建工程</h2><p>文件&gt;新建&gt;工程&gt;pcb工程 重命名保存<br>在左侧工程上右键&gt;给工程添加新的&gt; schematic library, 同时也添加pcb library, 分别重命名保存在一个文件夹内. 我都取名最小系统.<br>如果左边的project栏消失了, 可以点击右下角的system选择project简单打开. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb1.jpg" style="zoom:40%" alt="" /></p><h2 id="添加元件"><a href="#添加元件" class="headerlink" title="添加元件"></a>添加元件</h2><p>建立完成后要向库内添加画图所需要的元件符号及封装.<br>对于原理图库添加的是在原理图中用到的各种元件符号.<br>对于原理图库, 有两种添加元件的方式, 第一种自己画, 第二种从其他库中复制.<br>自己画可以用上方的绘制工具, 简单地画出矩形, 添加针脚等. 我自己尝试绘制了一个51单片机, 有一些要点简单记录下. </p><ul><li>1.鼠标点着移动图形的时候可以使用xy使其对称翻转, 使用空格键旋转, 还可使用tab键快速打开属性菜单, 比如针脚可以设置名字与标识是否可见, 名字指的比如P1.0口, 标识使用管脚序号1-40, 用于以后电器连接的参照. 一般让两个都可见. （更多的快捷键在抓住图像时, 下面会有提示）</li><li>2.针脚每放一个序号会自动加1, 这里要注意两针脚之间的距离, 此后所有器件相邻针脚的距离尽可能相同, 否则后期连线异常痛苦, 不要问我是怎么知道的. </li><li>3.针脚有叉的一端是热点, 朝器件外与导线相连. </li><li>4.对于有些管脚名字上有横线, 比如EA脚, 可输成E\A\来显示. </li><li>5.画完一个元件后除了设定名称, 比如stc89c51, 还要设定一下器件属性（菜单栏工具&gt;器件属性）中的Default Designator, 如电阻在该栏填入R？, R表示是电阻, ？在后期可自动填充为数字, 变成R1, R2, R3等标号. </li></ul><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb2.jpg" style="zoom:40%" alt="" /></p><p>这是自己绘制的51芯片<br>总的来说自己绘制元器件看似有较大自由度, 其实不然, 如果没有暗定的标准, 比如前面说的针脚宽度, 到连线时各种不匹配. 元器件绘制的大小也有讲究, 弄得不好会变成笑话, 比如下面这个. 当然, 牢记各种标准规则之后应该会更加灵活. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb3.jpg" style="zoom:40%" alt="笑话" /></p><p>对于刚使用AD的人来说, 直接借鉴别人画好的元器件符号是不错的选择, 而事实上也很多都是这么做的. 比较明智的做法大概是自己或是别人的整理出一个元件库来, 有需要直接能拿来用就行. 只需简单的复制黏贴就能建起一个原理图库或是封装库, 再编译整合成集成库（由于集成库不可编辑只能直接拿来画原理图, 所以别人的集成库不能把元件直接复制到自己的集成库内）. 听说集成库能重新分解为原理图库和封装库, 奈何探索无果.<br>使用复制其他库的元件需要先在网上下载一些有常用元件的原理图库或封装库, 在右边栏库&gt;library&gt;工程标签&gt;添加库, 找到下载的库文件添加. 添加后可以选择添加的库, 并查看元件. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb4.jpg" style="zoom:40%" alt="" /></p><p>复制过程只要找到需要的元件右键&gt;Edit Component, 然后全选图形复制, 切换到自己建的库 工具&gt;新器件 然后改名黏贴即可, 然后保存.<br>至于封装库也可以进行类似操作.<br>封装库包含了各种器件封装的焊盘样式, 也可以自己画, 一些要点记录下</p><ul><li>1.切换到pcb library, 使用右上角的焊盘在图上放置焊盘, tab打开属性都是一样的. </li><li>2.AD中的默认单位是mil（1mil=0.0254mm）, 可以按q切换成mm. 焊盘放置长度应该与元件封装匹配. 普通洞洞板两孔之间的长度是100mil,<br>如果是直插轴型电阻器件, 焊盘距离300mil比较美观. </li><li>3.使用菜单报告&gt;测量工具（ctrl+m）可用于测量两焊盘之间的距离, 不过在此之前, 可以使用编辑&gt;设定参考&gt;定位 重新设置参考点. </li><li>4.画元件不仅要有焊盘有时必须要有轮廓, 这会在pcb电路板上起表示作用. 选择底部的Top Overlay丝印层（黄色的）, 在这层作图会作为标记印在电路板上. 选放置走线（焊盘左边）进行作画. </li></ul><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb5.jpg" style="zoom:40%" alt="" /></p><p>5.还需要注意的一点是封装的焊盘也是有标号的, 标号需要与原理图库的元件的针脚序号相对, 特别是三极管, 电解电容之类有管脚差异的元器件.<br>6.焊盘属性设置的时候小屏高分辨率显示屏碰到的麻烦. 无法看到整个菜单, 确认只能用回车, 或者让任务栏消失会好点. 这样的问题不在少数. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb6.jpg" style="zoom:40%" alt="尴尬" /><br>我通过查找复制, 完成了原理图库和封装库, 嗯, (ー`′ー)</p><p>一共用到9个元器件</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb7.jpg" style="zoom:40%" alt="" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb8.jpg" style="zoom:40%" alt="" /></p><p>要点: 在复制封装库元件的时候全选复制后还要左键选一个点作为参照才能成功粘过去.<br>参考部分增加各种器件的封装资料</p><h2 id="连接库"><a href="#连接库" class="headerlink" title="连接库"></a>连接库</h2><p>选中建好的原理图库&gt;工具&gt;模式管理<br>依次选中元件&gt;add footprint&gt;输入对应封装名（建库时我把两库元件名字都统一了）会自动找到对应封装&gt;点确定即可<br>经试验好像不分大小写</p><h2 id="编译成集成库"><a href="#编译成集成库" class="headerlink" title="编译成集成库"></a>编译成集成库</h2><p>集成库的生成是可选的, 库连接完毕后, 就可以添加进工程进行原理图绘制的<br>新建&gt;工程&gt;集成库 改名保存<br>把原理图库和封装库都拖到集成库内, 右键集成库&gt;Compile Integrated Library 成功不会报错（其实不知道出错会怎样(　・ˍ・)<br>成功后, pcb工程会自动安装上制作的集成库, 马上就可以用里面的元器件作图了. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb10.jpg" style="zoom:40%" alt="" /></p><h2 id="补充部分-3D封装"><a href="#补充部分-3D封装" class="headerlink" title="补充部分-3D封装"></a>补充部分-3D封装</h2><p>在制作封装库的时候可以顺带加入3D封装库（这是可选的, 增加后可以生成3D模型）操作是打开一个元件的封装&gt;放置&gt;3D元件体, 弹出的设置菜单选择属性步骤模型&gt;插入步骤模型, 找到3D模型文件就行了, 一般是step文件, AD不能画3D模型, 必须在其他绘制软件中画好来导入, 像是Solidworks. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb9.jpg" style="zoom:40%" alt="" /></p><p>无语菜单栏又显示不完全<br>紫色框是插入的3D封装, 正上方的选框可以切换到3D视角观察, 可以更改菜单中的xyz参数, 使3D模型处于合适的位置, 管脚能进入焊盘. 如果大小什么的不合适, 只能删了重找.<br>3D封装与普通封装类似, 也可从有3D封装的封装库中复制过来.<br>参考部分增加3D封装查找资料</p><h1 id="原理图及PCB设计"><a href="#原理图及PCB设计" class="headerlink" title="原理图及PCB设计"></a>原理图及PCB设计</h1><h2 id="原理图绘制"><a href="#原理图绘制" class="headerlink" title="原理图绘制"></a>原理图绘制</h2><p>左侧PCB工程右键&gt;给工程添加新的&gt;Schematic和PCB 改名保存<br>Schematic就是原理图, 直接把右侧集成库中的元件拖出来作图. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb11.jpg" style="zoom:40%" alt="" /></p><p>作图中…<br>大致上完工, 还需做一下细节部分的处理, 在此之前先做下记录</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb12.jpg" style="zoom:40%" alt="" /></p><ul><li>1.上方的 放置线 设置导线 VCC与GND也不多讲了</li><li>2.设置网络. 设置网络是图上两点作上标记, 不显示导线而实现电气连接. 方法是先用放置线画导线延长一段, 使用上方的 放置网络标号, 点击延长导线的末端. 双击末端打开网络标签, 在网络选项填写需要连接的另一端标号. 使用VCC与GND, 必须要有点连接到他们. </li><li>3.元件边上的红线表示有错误, 上图应该是器件重复了（如有了两个R1）下面会处理. 可以先编译下, 能显示出错误. 保佑我不是其他错误. </li><li>4.如果有元器件对不齐可以改小格点或改大格点, 左下角的Grid显示了当前格点大小, 右上角的栅格工具可以调节. </li></ul><p>下面是细节处理操作</p><ul><li>1.首先是给各元器件编号消除错误（使？变为数字, 生成R1, R2等等）, 有特殊需要可以自己一个个改, 但这样就失去了使用？的意义. 我是用自动标号进行处理, 工具&gt;标注所有器件. 果然红线消失了. </li><li>2.隐藏元器件名称. 选中一个元器件的名称（选中有绿框）&gt;右键查找相似对象(把下面的钩都打上)&gt;确定之后会把图上所以的器件名称选定并弹出菜单&gt;hide项打钩退出&gt;图上右键&gt;过滤器&gt;清除过滤器 完成<br>有点后悔当时让针脚的序号可见, 不然看起来更简洁一些.<br>这是一个很有用的方法, 不止可以用在这里, 比如统一改封装等等. </li><li>3.添加器件的值（如一个10k电阻）, 双击一个器件符号&gt; parameters栏（右边大白框）下的添加&gt;在值那一栏添加元件的值（10k）, 并设置为可见. </li><li>4.多针脚器件连接时, 可以先针脚对其连接, 按住ctrl键往外拉, 此时两器件针脚之间是连着导线的. 用这种方法可以快速连接两多针脚器件. </li></ul><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb13.jpg" style="zoom:40%" alt="" /></p><p>这样就算完成了, 右下角的原理图信息可以右键&gt;放置&gt;文本框 填写</p><h2 id="PCB与放置play"><a href="#PCB与放置play" class="headerlink" title="PCB与放置play"></a>PCB与放置play</h2><p>完成原理图绘制后&gt;菜单栏 设计&gt;Update PCB document XXX&gt;执行更改<br>执行没有错误后切换到PCB, 所有元器件封装就在黑板边上, 先拖动封装到黑色区域内, 选中包围封装的膜删除. 然后就是摆放器件封装.<br>这个应该需要积累经验, 简单来说是整洁美观便于之后的布线. 有导线连接的焊盘之间有显示白线, 供放置与布线参考<br>放置完后大概是这个样子, 不知布局是否合理</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb14.jpg" style="zoom:40%" alt="" /></p><p>接下来是确定电路板大小, 下方选择Mechanical标签（机械层也是禁止布线层, 紫色的）&gt;用右上角的应用工具选 放置走线画出边框&gt;选中所有边框&gt;设计&gt;板子形状&gt;按照所选对象定义<br>完成后 右键&gt;过滤器&gt;清除过滤器</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb15.jpg" style="zoom:40%" alt="成品" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb16.jpg" style="zoom:40%" alt="3D视角" /></p><p>补充</p><ul><li>1.如果有需要可以把边框棱角做一个弧度, 方法类似. 如果还需要四个螺丝洞做一个支架, 在四个角分别放置一个口径差不多的 过孔（焊盘边上） 就行. </li><li>2.如果加入了3D封装, 3D视角时是摆满元件的, 直接是焊接完成之后的效果. <h2 id="布线与敷铜"><a href="#布线与敷铜" class="headerlink" title="布线与敷铜"></a>布线与敷铜</h2>pcb焊盘之间需用铜线相连, 简单电路用一层布线, 也就是只用了电路板的表面或底面布线. 稍复杂的两层布线也能解决问题, 还可以利用过孔. 过孔是穿越两层的空洞, 铜线能穿越过孔从一层到另一层, 以解决棘手的连接问题, 当然也可以利用焊盘, 有时是不得已而为之. 三层四层的电路板可以想象, 薄薄的电路板中有多层电气通路, 设计难度可见一斑.<br>布线也需要经验的积累吧, 原则上是两层的线尽量垂直而不平行（比如顶层线都尽量竖直, 底层就尽量水平）, 减少电容效应与干扰.<br>下方的Top Layer与Bottom Layer标签就是顶层与底层布线层.<br>使用右上角的 交互式布线连接 进行布线. 把VCC电源与GND的布线放到最后, 电源部分的线宽应稍大些, 设置为40mil. </li></ul><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb17.jpg" style="zoom:40%" alt="不如自动布线系列" /></p><p>其实也可以使用自动布线&gt;全部 不过灵活性差些, 对于复杂电路, 布线还是交给电脑吧<br>要点</p><ul><li>1.规则. 设计&gt;规则 规则是布线时不需要遵守的, 比如线离焊盘的最小距离, 线宽等等. 虽然项目很多, 一般需要更改的只有几个, 线宽可以在width项更改, 设置线宽上限, 使电源部分可以与其他部分不同. 不符合规则的元件会变绿提示. </li><li>2.过孔使用需先放在线上, 还可以shift+ctrl+滚轮（研究了半天눈_눈）<br>完成后应该就可以敷铜了, 敷铜也有很多的模式, 关于敷铜是什么看到设置页面就知道了 放置&gt;多边形敷铜&gt;设定完成确定后 点击板四个角画框&gt;右键完成</li></ul><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb18.jpg" style="zoom:40%" alt="顶层的敷铜" /></p><p>要点</p><ul><li>1.有三种样式的敷铜solid、hatched和none, 而Protel不支持solid填充模式, 意味着如果工厂没有AD而用的是Protel, 就不能识别soild样式. 不过可以通过更改轨迹宽度与栅格尺寸相同（如图）, 来达到solid的效果. </li><li>2.左侧属性 层选择要敷铜的层. 右侧 连接到网络 就是指铺完后大片的铜（没有作为导线连入网络的铜, 作为死铜）可能需要连接的导线, 一般选择GND接地, 下面的选项便是设置是否连接到所选网络. Pour Over ALL Same Net Objects是使得大片的铜与所选网络融合, Don’t Pour Over Same Net Objects则相反. </li></ul><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb19.jpg" style="zoom:40%" alt="最终成品" /></p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/pcb20.jpg" style="zoom:40%" alt="底层敷铜" /></p><p>PCB画好了_(´ཀ`」 ∠)_</p><h1 id="修饰与导出"><a href="#修饰与导出" class="headerlink" title="修饰与导出"></a>修饰与导出</h1><p>可以在空白处 切换到丝印层做一些修饰如使用放置&gt;字符串 印上自己的名字之类的.<br>文件导出:<br>文件&gt;制造输出&gt;Gerber Files<br>或直接将工程发给工厂, 把工程另存为PCB4.0 Binary Files,  Protel也能打开的文件格式. </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>常用封装 <a href="http://blog.csdn.net/kobesdu/article/details/24257755">参考</a><br>3D封装库 <a href="http://www.3dcontentcentral.cn/Search.aspx?arg=0805">参考</a><br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> 电子工学 </category>
          
          <category> EDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Altium Designer </tag>
            
            <tag> Tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蜂鸣器君的发声练习</title>
      <link href="/beep/"/>
      <url>/beep/</url>
      
        <content type="html"><![CDATA[<p>最近搞到一个51单片机, 看了下有个控制蜂鸣器发声的实验, 挺有意思, 嗯, 就做个记录吧. </p><span id="more"></span><p>如何让蜂鸣器响起来就不多说了, 上图, 硬件上利用了三极管开关, 用51一个管脚就能控制了. </p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E8%9C%82%E9%B8%A3%E5%99%A8%E7%94%B5%E8%B7%AF%E5%9B%BE.jpg" style="zoom:50%" alt="蜂鸣器控制电路" align=center /></p><p>关键难题是如何让蜂鸣器君演奏出旋律, 仔细看了例程, 所幸不是很难. 只要知道曲子中的每个音（即知道音的频率）和每个音的拍子（即持续的时间）就能简单实现了. 下面是找到的例程框架. 可以看到这个例程是利用m（发音频率的参考变量）和一个延迟函数配合, 发出曲谱上的每个音；利用n（发音时间的参考变量）和一个计时器timer0配合, 组成曲谱的拍子. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit Beep = P1^<span class="number">5</span>;    <span class="comment">//定义P1.5管脚控制蜂鸣器</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> n = <span class="number">0</span>;  <span class="comment">//n作为每个音持续时间的参考变量</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////曲谱表</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code music_tab[] = &#123;</span><br><span class="line">  ………               <span class="comment">//编写规则: 一个频率(m), 一个拍子(n)</span></span><br><span class="line"></span><br><span class="line">  <span class="number">0x00</span>              <span class="comment">//0x00作为结束符 休止符为0xff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先把主函数放上来看看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> p, m;      <span class="comment">//m为音频率参考变量, </span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;     <span class="comment">//p在后面作为检测是否播放完毕</span></span><br><span class="line">   TMOD &amp;= <span class="number">0x0f</span>;            <span class="comment">//设置timer0为工作方式1</span></span><br><span class="line">   TMOD |= <span class="number">0x01</span>;            <span class="comment">//原来可以这么写, 长姿势了</span></span><br><span class="line">   TH0 = (<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>; <span class="comment">//设置timer0初值, 计时为50ms</span></span><br><span class="line">   TL0 = (<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;</span><br><span class="line">   IE = <span class="number">0x82</span>;               <span class="comment">//timer中断使能</span></span><br><span class="line">   play:                    <span class="comment">//核心播放部分, 用了goto语句Σ( ° △ °|||)︴</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      a: p = music_tab[i];  <span class="comment">//从表中取出一个值检测</span></span><br><span class="line">         <span class="keyword">if</span>(p == <span class="number">0x00</span>)      <span class="comment">//若是休止符则计数归零, 延迟1s后重新播放</span></span><br><span class="line">          &#123;</span><br><span class="line">             i=<span class="number">0</span>;</span><br><span class="line">             <span class="built_in">delayms</span>(<span class="number">1000</span>);</span><br><span class="line">             <span class="keyword">goto</span> play;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="number">0xff</span>)  <span class="comment">//若是休止符（就是不发音）, 计数加1, 延迟100ms</span></span><br><span class="line">          &#123;                   <span class="comment">//后跳到到下一个音. 这里感觉缺少灵活性, 不同曲子</span></span><br><span class="line">             i = i+<span class="number">1</span>;         <span class="comment">//的休止符时长不一定相同吧</span></span><br><span class="line">             <span class="built_in">delayms</span>(<span class="number">100</span>);</span><br><span class="line">             <span class="keyword">goto</span> a;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>                 <span class="comment">//没遇到上述特殊情况, mn分别从表中取值</span></span><br><span class="line">          &#123;</span><br><span class="line">             m = music_tab[i++];</span><br><span class="line">             n = music_tab[i++];</span><br><span class="line">          &#125;</span><br><span class="line">          TR0 = <span class="number">1</span>;             <span class="comment">//启动timer0, 发声开始</span></span><br><span class="line">          <span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">          Beep =~ Beep;</span><br><span class="line">          <span class="built_in">delay</span>(m);            <span class="comment">//没错, 通过设定频率地不断打开关闭蜂鸣器, 制造</span></span><br><span class="line">                               <span class="comment">//出特定频率的声音</span></span><br><span class="line">          TR0 = <span class="number">0</span>;             <span class="comment">//在由计时器与n设定的发声时间内发声结束, 关闭</span></span><br><span class="line">    &#125;                          <span class="comment">//计时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是配合演出的函数们</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer0</span><span class="params">()</span> interrupt 1 <span class="comment">//timer0中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TH0 = (<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>;  <span class="comment">//每过50ms进入一次, 做n--</span></span><br><span class="line">    TL0 = (<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;  <span class="comment">//举个栗子, 若一个音发500ms, 曲谱表中那个音的n</span></span><br><span class="line">    n--;                      <span class="comment">//的位置写10即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delay</span> <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> m)</span><span class="comment">//这个delay函数用于控制频率, 用于us级时间控制</span></span></span><br><span class="line"><span class="function"></span>&#123;                           <span class="comment">//经过仿真, 精确程度还行, while(--i)大概8us</span></span><br><span class="line">    <span class="type">unsigned</span> i = <span class="number">2</span>*m;       <span class="comment">//运行一次, 嗯</span></span><br><span class="line">    <span class="keyword">while</span>(--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delayms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span><span class="comment">//网上找的比较精确的ms级延迟函数, 替代了例程</span></span></span><br><span class="line"><span class="function"></span>&#123;                           <span class="comment">//中的延迟函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> k, j;</span><br><span class="line">    <span class="keyword">for</span>(j=n; j&gt;<span class="number">0</span>; j--)</span><br><span class="line">      <span class="keyword">for</span>(k=<span class="number">112</span>; k&gt;<span class="number">0</span>;k--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最有(dan)趣(teng)的是编曲部分, 从网上找到了音阶对应频率的表</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/2-1.jpg"  style="zoom:50%" alt="音阶对应频率" align=center /></p><p>比如要蜂鸣器发低音Do, 频率为262Hz, 也就是要在1s内开关蜂鸣器262次, 大概3.8ms（3800us）变换状态, 对于中音与高音变换时间更短, 得使用us级的延时函数delay(). 然后为了让unsigned char型的m（最大装值255）能表示所有音阶, 配上一个系数. 取延时最长的低音Do除以16差不多239, 接近255, 就这么愉快地决定了. 因为delay()函数中while(—i)大概8us执行一次, 所以把传过来的m的值乘2, 就能平衡前面除以16的影响发出正确的音. 好了, 所有音都处理后得到了一张表</p><p><img src="https://raw.githubusercontent.com/Granvallen/granvallen.github.io/master/img/%E9%9F%B3%E9%98%B6.png"  style="zoom:50%" alt="音阶与对应m值" align=center /></p><p>然后再稍微补充下学习乐理基础的知识吧, 既然是拿简谱开刀, 没有基础的乐理也是不够的, 其实这里只需关注每个音的延时, 然后利用50ms的计时器与变量n配合即可. </p><p>首先必须知道一个标准的拍子(比如四分音符为一拍)是多少时间, 这个我查了下与曲子有关, 不同曲子所要求的弹奏速度是不一样的, 有时还要加入弹奏者的理解自行发挥. 所幸在比较标准的简谱左上角会标出弹奏的标准速度. 比如♩=100, 也就是说一分钟弹奏100个四分音符, 600ms是标准一拍的时间, 此时简谱中纯数字的n写为12就行了(12*50ms=600ms), 然后数字下有一横的表示半拍(n=6), 两横的表示四分之一拍(n=3), 如果是数字后的短横表示延音, 也类似, 一条横线延长一拍(n=24), 以此类推就行了. 事实是有明确标明弹奏速度的简谱并不常见, 一般就以400/500ms一拍的速度就好了. </p><p>嗯, 首先找来了一个《小星星》简谱来试试, 顺便记一下, 左上角的1=D表示D调, 简谱可能还得辨识大小调, 从而重新确定音调. 不过实在没必要搞得太麻烦, 又没什么大的区别（我是音痴, 学音乐的不要打我ˋ( ° ▽、° )</p><p>4/4表示四分音符为一拍, 每小节四拍, 两条竖线之间为一节吧<br>这就是编的小星星（一闪一闪亮晶晶那个）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code music_tab[] =&#123;   </span><br><span class="line">    <span class="number">0xef</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0xef</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0x9f</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0x9f</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0x8e</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0x8e</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0x9f</span>,<span class="number">0x14</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="number">0xb3</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0xb3</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0xbe</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0xbe</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0xbe</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0xd5</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0xd5</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0xef</span>,<span class="number">0x14</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">0x00</span>   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好像不错再编个天空之城主题曲《君をのせて》<br>不过我打算把音调与拍子分开编, 也挺容易的就是有点…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code music_f[] = <span class="comment">//音调谱</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0x47</span>,</span><br><span class="line">    <span class="number">0x3f</span>,<span class="number">0x3b</span>,<span class="number">0x3f</span>,<span class="number">0x3b</span>,</span><br><span class="line">    <span class="number">0x2f</span>,<span class="number">0x3f</span>,<span class="number">0x5e</span>,<span class="number">0x5e</span>,</span><br><span class="line">    <span class="number">0x47</span>,<span class="number">0x4f</span>,<span class="number">0x47</span>,<span class="number">0x3b</span>,</span><br><span class="line">    <span class="number">0x4f</span>,</span><br><span class="line">    <span class="number">0x5e</span>,<span class="number">0x59</span>,<span class="number">0x5e</span>,<span class="number">0x59</span>,</span><br><span class="line">    <span class="number">0x3b</span>,<span class="number">0x5e</span>,<span class="number">0xff</span>,<span class="number">0x3b</span>,</span><br><span class="line">    <span class="number">0x3b</span>,<span class="number">0x3b</span>,<span class="number">0x3f</span>,<span class="number">0x54</span>,</span><br><span class="line">    <span class="number">0x59</span>,<span class="number">0x3f</span>,<span class="number">0x3f</span>,<span class="number">0xff</span>,</span><br><span class="line">    <span class="number">0x47</span>,<span class="number">0x3f</span>,<span class="number">0x3b</span>,<span class="number">0x3f</span>,</span><br><span class="line">    <span class="number">0x3b</span>,<span class="number">0x2f</span>,<span class="number">0x3f</span>,<span class="number">0x5e</span>,</span><br><span class="line">    <span class="number">0x5e</span>,<span class="number">0x47</span>,<span class="number">0x4f</span>,<span class="number">0x47</span>,</span><br><span class="line">    <span class="number">0x3b</span>,<span class="number">0x4f</span>,<span class="number">0x6a</span>,<span class="number">0x5e</span>,</span><br><span class="line">    <span class="number">0x59</span>,<span class="number">0x3b</span>,<span class="number">0x3f</span>,<span class="number">0x3f</span>,</span><br><span class="line">    <span class="number">0x3b</span>,<span class="number">0x3b</span>,<span class="number">0x35</span>,<span class="number">0x35</span>,</span><br><span class="line">    <span class="number">0x2f</span>,<span class="number">0x3b</span>,<span class="number">0x3b</span>,<span class="number">0x3b</span>,</span><br><span class="line">    <span class="number">0x3f</span>,<span class="number">0x47</span>,<span class="number">0x47</span>,<span class="number">0x3f</span>,</span><br><span class="line">    <span class="number">0x4b</span>,<span class="number">0x47</span>,</span><br><span class="line">    <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code <span class="type">music_t</span>[]= <span class="comment">//拍子谱</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x0a</span>,<span class="number">0x0a</span>,<span class="number">0x0a</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x0f</span>,<span class="number">0x05</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0x0a</span>,<span class="number">0x1e</span>,<span class="number">0x05</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x0f</span>,<span class="number">0x05</span>,<span class="number">0x0a</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0x1e</span>,</span><br><span class="line">    <span class="number">0x0a</span>,<span class="number">0x0f</span>,<span class="number">0x05</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0x0a</span>,<span class="number">0x14</span>,<span class="number">0x05</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x05</span>,<span class="number">0x0f</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x0a</span>,<span class="number">0x0a</span>,<span class="number">0x14</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x05</span>,<span class="number">0x0f</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x0a</span>,<span class="number">0x0a</span>,<span class="number">0x1e</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x0f</span>,<span class="number">0x05</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0x0a</span>,<span class="number">0x1e</span>,<span class="number">0x05</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x0a</span>,<span class="number">0x05</span>,<span class="number">0x05</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x0a</span>,<span class="number">0x05</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x05</span>,<span class="number">0x14</span>,<span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x05</span>,<span class="number">0x05</span>,<span class="number">0x05</span>,<span class="number">0x0a</span>,</span><br><span class="line">    <span class="number">0x0a</span>,<span class="number">0x1e</span>,</span><br><span class="line">    <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编了一半我傻了, 简单的十进制放着不用, 干嘛非用麻烦的十六进制, 果然是被例程带坏了 ಥ_ಥ</p><p>既然明白了原理, 就再改改放一个最终方案作为结束, 上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> </span></span><br><span class="line"><span class="comment">///////////////////中音部</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> c  120</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cp 113</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> d  106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dp 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> e  95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> f  90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fp 84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> g  80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gp 75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> a  71</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ap 67</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> b  63</span></span><br><span class="line"><span class="comment">///////////////////高音部</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C  60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Cp 56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D  53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Dp 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E  47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F  45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fp 42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G  40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Gp 38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A  36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Ap 34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B  32</span></span><br><span class="line"><span class="comment">///////////////////低音部</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cc  239</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ccp 226</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dd  213</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ddp 201</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ee  189</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff  179</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ffp 169</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gg  159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ggp 151</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aa  142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aap 134</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bb  127</span></span><br><span class="line"><span class="comment">///////////////////休止符</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xx  0</span></span><br><span class="line"></span><br><span class="line">sbit Beep =  P1^<span class="number">5</span> ;   </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> n=<span class="number">0</span>, i=<span class="number">0</span>, p, m;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code music_f[] =</span><br><span class="line">&#123;</span><br><span class="line">    C,b,C,E,b,</span><br><span class="line">    a,g,a,C,g,</span><br><span class="line">    f,e,f,C,b,g,</span><br><span class="line">    a,b,C,E,D,</span><br><span class="line">    C,b,C,E,b,g,</span><br><span class="line">    a,b,C,D,E,E,</span><br><span class="line">    F,E,D,C,b,E,gp,b,</span><br><span class="line">    a,a,b,C,D,</span><br><span class="line">    E,D,</span><br><span class="line">    G,F,E,D,C,</span><br><span class="line">    b,C,a,</span><br><span class="line">    a,a,g,</span><br><span class="line">    f,g,a,C,b,</span><br><span class="line">    b,C,D,b,</span><br><span class="line">    b,xx,a,</span><br><span class="line">    a,a,b,C,D,</span><br><span class="line">    E,D,</span><br><span class="line">    G,F,E,D,C,</span><br><span class="line">    b,C,a,</span><br><span class="line">    a,a,g,</span><br><span class="line">    f,g,a,C,b,</span><br><span class="line">    b,C,D,F,E,</span><br><span class="line">    E,D,C,</span><br><span class="line">    b,gp,</span><br><span class="line">    C,b,C,E,b,</span><br><span class="line">    a,g,a,C,g,</span><br><span class="line">    f,e,f,C,b,g,</span><br><span class="line">    a,b,C,E,D,</span><br><span class="line">    C,b,C,E,b,g,</span><br><span class="line">    a,b,C,D,E,E,</span><br><span class="line">    F,E,D,C,b,E,gp,b,</span><br><span class="line">    a,</span><br><span class="line">    <span class="number">0xff</span>   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code <span class="type">music_t</span>[]=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">24</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">24</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">12</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">24</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">12</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">12</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">36</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,</span><br><span class="line">    <span class="number">36</span>,<span class="number">12</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">36</span>,<span class="number">6</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">36</span>,<span class="number">6</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,</span><br><span class="line">    <span class="number">36</span>,<span class="number">6</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">36</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,</span><br><span class="line">    <span class="number">36</span>,<span class="number">12</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">36</span>,<span class="number">6</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">36</span>,<span class="number">6</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">36</span>,<span class="number">6</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">24</span>,<span class="number">24</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">24</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">24</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">12</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">24</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">12</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">12</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,</span><br><span class="line">    <span class="number">48</span>,</span><br><span class="line">    <span class="number">0xff</span></span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer0</span><span class="params">()</span>  interrupt 1   </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    TH0 = (<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>;</span><br><span class="line">    TL0 = (<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;  </span><br><span class="line">    n--;     </span><br><span class="line">&#125;   </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> m)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> h = <span class="number">2</span>*m;</span><br><span class="line">    <span class="keyword">while</span>(--h);   </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">delayms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;                             </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> k,j;</span><br><span class="line">    <span class="keyword">for</span>(j=n; j&gt;<span class="number">0</span>; j--)</span><br><span class="line">      <span class="keyword">for</span>(k=<span class="number">112</span>; k&gt;<span class="number">0</span>; k--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        </span><br><span class="line">    TMOD &amp;= <span class="number">0x0f</span>;   </span><br><span class="line">    TMOD |= <span class="number">0x01</span>;   </span><br><span class="line">    TH0 = (<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>;</span><br><span class="line">    TL0 = (<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;  </span><br><span class="line"></span><br><span class="line">    IE = <span class="number">0x82</span>;   </span><br><span class="line">    play:   </span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)   </span><br><span class="line">      &#123;   </span><br><span class="line">        p = music_f[i];   </span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">0xff</span>)       </span><br><span class="line">        &#123; </span><br><span class="line">           i = <span class="number">0</span>;</span><br><span class="line">           <span class="built_in">delayms</span>(<span class="number">3000</span>); </span><br><span class="line">           <span class="keyword">goto</span> play;     </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">else</span>         </span><br><span class="line">        &#123;</span><br><span class="line">            m = music_f[i], </span><br><span class="line">            n = <span class="type">music_t</span>[i++]; </span><br><span class="line">        &#125;               </span><br><span class="line">            TR0 = <span class="number">1</span>;                                </span><br><span class="line">            <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">           <span class="keyword">if</span> (p)</span><br><span class="line">           &#123;</span><br><span class="line">              Beep =~ Beep;</span><br><span class="line">              <span class="built_in">delay</span>(m);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TR0 = <span class="number">0</span>;                            </span><br><span class="line">      &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做了点改进<br>1.宏定义了一些符号常量, 便于编谱<br>2.改变了休止符表示方法, 并把休止符也看成一个音调, 不像原来那样goto语句特殊处理. 可以通过n来控制音长(虽然没有声音)</p><p>作为初学者就折腾到这里吧, 不知道结合键盘能不能自己演奏呢. 被蜂鸣器的声音折磨了几个小时, 赶紧听下原版获得救赎吧XD</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=731409&auto=0&height=66"></iframe><p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> Lab </category>
          
          <category> 电子工学 </category>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 不务正业 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读太宰治的《人間失格》</title>
      <link href="/renjianshige/"/>
      <url>/renjianshige/</url>
      
        <content type="html"><![CDATA[<p>因为对太宰治的简介颇感不理解, 好奇之下, 拜读了被人称为他内心独白的绝笔《人间失格》, 它给人的冲击是巨大的. </p><p>文章不是很长却涵盖了一个名叫叶藏的男人一步步走向沉沦的一生. 文笔简练却极具表现力, 作品中叶藏大量的心理描写使叶藏形象更加饱满. 第一人称的视角叙写极具感染力. 书一开头有一段前言, 写的是主人公叶藏不同时期的三张照片, 作者用外人的口吻评价了这三张照片, 评价照片上的男子让人怏怏不乐、焦躁不安, 想赶快移开视线, 长相诡异. 仿佛是想让读者先做好心理准备似的. 而叶藏的故事就从他的童年写起. </p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=26115506&auto=0&height=66"></iframe><p>第一手札. 叶藏出生在一个地主阶级的大户人家, 文中介绍到父亲是政客, 作为家中最小的孩子却没得到家人多少关爱. 与其他孩子一样爱玩, 对周遭的一切充满好奇. 叶藏家是传统守旧的乡下家庭, 各种家规自然少不了, 由于对全家人吃饭一声不吭和几乎一成不变的菜肴不满, 曾一度对吃饭起了厌恶之心, 又似大人般的思考起人类和幸福感来, 认为自己背负着别人没有的灾难, 对世人忍受着痛苦, 却不会发狂, 不会绝望, 不屈不挠与生活作斗争不解. 叶藏思考了很多很久, 思绪渐感困惑之时, 带来的却是无尽的恐惧与不安. 被“唯有自己一个人与众不同”的不安和恐惧牢牢攫住. </p><blockquote><p>“我与别人几乎不说话, 因为不知道该说什么, 该怎么说. 于是, 我想到一个办法, 那就是用滑稽的言行讨好别人. ”</p><p>“这是我对世人最后的求爱. 尽管我对世人感到极度恐惧, 但却怎么也没办法对世人死心. 于是, 我依靠滑稽这根细线, 维系着与世人的一丝联系. ”</p></blockquote><p>叶藏在不知不觉间变成了一个扮演“小丑”来取悦别人的孩子, 他总是黯然的接受来自外界的的攻击, 而内心承受着几乎为之发狂的恐惧. </p><blockquote><p>“不管是谁, 如果遭到别人的谴责或怒斥, 都是不会感到愉快的. 但我却从世人怒不可遏的面孔中发现了比狮子、鳄鱼、巨龙更可怕的动物本性. 平常他们总是隐藏起这种本性, 可一旦遇到某个时机, 世人可怕的真面目就会在愤怒中不经意间暴露出来. 就像那些温文尔雅地躺在草地上歇息的牛, 突然甩动尾巴拍死肚皮上的牛虻一般. 见此情景, 我总是不由得毛骨悚然. 可一旦想到, 这种本性或许是人类赖以生存的必备资质之一时, 便只能对自己感到由衷的绝望. ”</p></blockquote><p>叶藏的“计划”非常成功, 逗乐了令他感到可亲又可怕的父亲, 逗乐了那些佣人, 在学校里写一些滑稽的小段子, 常常故意出丑弄得老师和全班大笑. 他成功地从受人尊敬的恐惧中逃离出来. 同时, 父亲身边表里不一的一些朋友, 使叶藏更加无法相信人类. </p><blockquote><p>“相互欺骗, 却又令人惊奇地不受到任何伤害, 甚至于就好像没有察觉到彼此在欺骗似的. 我认为, 人类生活中无处不是这样单纯、明了的不信任之举. ”</p></blockquote><p>第二手札. 叶藏以优异的成绩离开家乡考入了某所中学, 尽管如此, 凭借着他惯用的逗笑本领, 日渐得到同班同学的拥戴. 但正当叶藏要为自己彻底掩盖了本人真面目而暗自庆幸时, 却被一个不起眼名叫竹一的同学看穿了. 一次早已安排好的出丑闹剧, 竹一在叶藏背后低声嘟囔道: “故意的, 你是故意的. ”</p><blockquote><p>“之后的每一天, 我都生活在不安与恐惧之中. ”</p><p>“无论我做什么, 都肯定会被那个竹一一一识破, 并迟早会把真相告诉每一个人. 一想到这里, 我额头上就会冒出密密麻麻的汗珠, 然后用怪异的眼神环顾四周, 神色慌张, 犹如一个疯子. 如果可能, 我甚至巴不得从早到晚二十四小时跟踪监视竹一, 以免他随口泄露了秘密. ”</p></blockquote><p>叶藏可谓殚精竭虑, 甚至不惜一切打定主意, 要成为他最好的朋友. 叶藏的“努力”总算换来了回报, 一次借伞事件. 使他们的关系得到了改善. 说也奇怪, 在竹一面前叶藏逐渐脱下了虚伪的人格面具. </p><blockquote><p>“唯有在竹一面前, 我可以放心展露自幼脆弱的神经. ”</p></blockquote><p>叶藏爱画画, 这点也得到了竹一的认同, 特别是当叶藏把那一幅阴森恐怖, 令人毛骨悚然的自画像给竹一看, 得到了竹一高度称赞. 似预言般的竹一的两句话, 叶藏一定永生难忘“肯定会被女人迷恋上”和“肯定会成为一个了不起的画家”. 随后因叶藏想去美术学校的愿望被父亲打碎后来到东京读高中. 高中的寄宿令叶藏无比厌恶, 于是找了个理由搬出学校, 住进了父亲在当地的一栋半闲置的别墅. 由于父亲每月在别墅住一到两周, 叶藏对于旁听般的讲课越发感到索然无味, 倒宁愿整天泡在一个画塾里学画. </p><blockquote><p>“不久, 在画塾里, 我从一个学生那儿得知了诸如酒、香烟、娼妓、当铺以及左翼思想之类的东西……”<br>这个学生正是掘木正雄. </p><p>“平生第一次见识了什么是真的都市痞子. 尽管对方与我装束不同, 但就举止完全脱离世俗、迷茫无措这一点来看, 我们的确是同类. 但掘木与我本质上不同, 在于他的搞笑是无意识的, 他完全意识不到自己搞笑的悲哀. ”</p></blockquote><p>叶藏把掘木当成一个玩伴有两方面的原因, 一是一旦把钱包交给他, 他很会玩乐, 而且能力超群, 即用最少的钱发挥最大的功效, 消费不高却颇感奢华, 这正与害怕人类的常闭门不出的叶藏相反, 其二掘木完全无视谈话对方的想法, 在某种意义上使叶藏得到了另一种救赎. 就这样还未成年的的叶藏带着恐惧不安、又渴望得到内心释放的心理被挤入了社会漩涡. 期间的很多故事令人唏嘘, 叶藏内心绝望的挣扎也令人心痛. 在经历了地下党派非法集会、爱情、自杀未遂、进入监狱变成罪人、妻子被人奸污、酗酒、药物上瘾、进入精神病院称为世人眼中的“废人”、丧父之后, 给自己打下了“人间失格”（失去做人资格）的烙印. </p><p>回过头来, 叶藏的三次感情令人印象最为深刻, 从中能看出叶藏, 更是太宰对于爱的理解. 正因为过于美好, 梦破灭时更令人心碎和绝望. 三段感情中, 第一段是与一个名叫常子的酒店女招待, 叶藏寻求的是同类的慰藉；第二段是与一个带着孩子的女强人静子, 叶藏寻求的是家庭的幸福；而第三段是与从不怀疑别人、纯洁的香烟铺的女儿良子, 叶藏寻求的是人性的纯洁. 可每一段都在以为自己获得幸福时, 被懦弱胆小所打败. 特别是与良子相处的一段时间, 叶藏变了很多, 生活逐渐规律, 叶藏第一次积极主动地去追求些什么, 知道自己去守护什么. 但良子最终却因为从不疑人而遭到践踏. 叶藏万念俱灰对人世失去了所有信心. 一个渴望爱又不懂爱的“胆小鬼”, 甚至会被幸福所伤. 作者阴暗绝望的笔触, 着实有一种强烈的代入感, 吸引着一代代青年读者, 从中窥探到自己的阴暗面. </p><p>碰巧找到一个NHK关于太宰治的纪录片, 了解了太宰治短暂一生经历的风风雨雨, 那个在《人间失格》中挣扎的叶藏又浮现在脑海中, 但仍能找到些许不同之处. 太宰治本名津岛修治, 出生在一个地主阶级的政客家中, 身为家中六男的他与继承家业无望, 未被家里重视. 太宰从小喜爱看书, 沉浸在文学中, 对芥川龙之介狂热崇拜. 学生时代就出道的他在年轻人中颇有名气, 受芥川影响, 文章以揭露社会黑暗和人的恶与伪善为主. 然而太宰青年时热衷于穿梭于花街柳巷与艺妓同居, 使他在写作上止步不前, 也因此事与家中断绝关系. 对未来绝望的他曾与一名女性殉情, 却只有他一人被救活了下来. 为了克服这一挫折痛苦, 太宰治再次投身文学创作, 渐渐受到文坛关注. 此时的太宰治不惜一切地想获得芥川奖, 想借此证明自己, 却与奖两次擦肩而过. 他写文章批评过评委, 也写长长的信恳求评委给予他希望, 不要见死不救. 然而第三届芥川奖他连提名也没有（因芥川奖新政出台）. 想要成为像芥川那样的作家, 这种心情越是强烈, 就越是止步不前, 太宰治认为自己的努力与创新被世人无情践踏而自甘堕落. 长期服用镇定剂, 造成药物中毒, 甚至连笔都无法握住. </p><p>之后, 太宰治有了自己的小家庭, 写了郑重的结婚书, 与妻子度过了最幸福的七年. 这七年里, 太宰治的心境安定了下来, 重新正视芥川奖, 坚持写作, 与妻子一起创造了新文体. 战争爆发时, 日本文坛到处是赞颂战争壮烈的时候, 太宰治写了不少幽默的作品, 慰藉因战争受伤、烦恼的人. 与小说中相反, 他成了能坦率描写柔怀的作家. 太宰治认为, 反省自身罪孽深重的人, 才能体会到爱的真谛, 才会亲切待人. </p><p>日本战败后, 当时赞美战争的一些作家又改口鼓吹民主主义, 同时日本民众没有战争罪恶感这一点, 也遭到太宰治的批判. 于是太宰治写了一部让人们反省自己罪孽的作品《斜阳》, 之后又提笔写下了自己曾经犯过的各种罪, 毫不留情地揭露人类共有的罪恶. 在写作《人间失格》期间, 他的生活又发生了巨变, 不顾家里人反对, 在外写作, 甚至有了情人. 他每晚饮酒无数, 自我放逐, 健康受损. 而他的妻子只是默默接受着这种自我毁灭式的写作. </p><p>小说最后, 叶藏从精神病院里出来, 给自己打上“人间失格”的烙印. 对此太宰治好像并不这样想, 那是在文章的后记中, 讲述了自己是如何得到这些故事时, 叶藏的相识, 酒吧老板娘说道: “我们所认识的小叶是个很诚实机灵的人, 只要不喝酒, 不, 即使喝了酒, 也是一个像神明一样的好孩子. ”结合太宰对爱的理解, 就不难理解了.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>終わり</p>]]></content>
      
      
      <categories>
          
          <category> ACGN </category>
          
          <category> 小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
            <tag> 太宰治 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
